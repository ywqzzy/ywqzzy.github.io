{"pages":[{"title":"About","permalink":"http://ywqzzy.github.io/about/index.html","text":""},{"title":"Categories","permalink":"http://ywqzzy.github.io/categories/index.html","text":""},{"title":"Tags","permalink":"http://ywqzzy.github.io/tags/index.html","text":""}],"posts":[{"title":"同步 IO 和异步 IO","permalink":"http://ywqzzy.github.io/2020/10/12/同步-IO-和异步-IO/","text":"Linux 系统中，所有的设备读写都可以看做文件的读写来操作，对文件的读写一般要经过内核态和用户态的切换， 正因为有切换才导致了 IO 有同步和异步的说法。 通常来讲 IO 可以分成两种： 来自网络的 IO 来自文件或者设备的 IO 并且完成 IO 操作可以简单的表述为两个步骤： 发起 IO 请求 执行 IO 操作 如何区分是同步 IO 还是异步 IO 呢？ “执行 IO 操作”是否阻塞 当请求被阻塞，就是同步 IO，否则就是异步 IO 同步 IO 的特点： 同步 IO 指的是用户进程触发 I/O 操作并等待或者轮询的去查看 I/O 操作是否就绪。同步 IO 的执行者是 IO 操作的发起者。同步 IO 需要发起者进行内核态到用户态的数据拷贝过程，所以这里必须由个阻塞 异步 IO 的特点： 异步 IO 是指用户进程触发 I/O 操作以后就立即返回，继续开始做自己的事情，而当 I/O 操作已经完成的时候会得到 I/O 完成的通知。异步 IO 的执行者是内核线程，内核线程将数据从内核态拷贝到用户态，所以这里没哟阻塞 如何区分是阻塞 IO 还是非阻塞 IO 呢？ 发起 IO 操作是否阻塞 如果阻塞直到完成，就是阻塞 IO，否则就是非阻塞 IO 讨论几个IO模型 阻塞 IO 模型(同步IO) 阻塞 IO 模型从发起 IO 操作到数据拷贝到用户空间，进程一直是阻塞的。 非阻塞 IO 模型(同步IO) 非阻塞 IO 模型从发起 IO 操作后就直接返回，定时轮询数据有没有准备好，后面还是需要拷贝数据到用户空间 IO 复用模型(同步 IO) IO 复用模型是发起 IO 操作前先调用 Select 或者 Poll。这两个函数都会在内核态准备好数据后告诉用户进程，相对于非阻塞 IO 模型来说，不需要轮询，用户进程可以做其他事情。但是本质上还是同步 IO但是它的优点在于可以同时触发多个 IO任务并在每个 IO 完成后依次处理。 信号驱动 IO 模型 通过 sigaction 注册信号，等内核准备好数据后内核态执行信号函数，本质还是同步 IO 异步 IO 模型采用 aio_read 让内核准备好数据并复制到用户进程空间，最后通知用户进程，这才是正真的异步 IO 参考资料 知乎"},{"title":"reactor & proactor","permalink":"http://ywqzzy.github.io/2020/10/12/reactor-proactor/","text":"标准定义两种I/O多路复用模式：Reactor 和 Proactor 一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的 read/write 事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。 两个与事件分离器有关的模式是Reactor和Proactor。Reactor 模式采用同步 IO，而 Proactor 采用异步 IO。 在 Reactor 中，事件分离器负责等待文件描述符或 socket 为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。 而在 Proactor 模式中，处理器–或者兼任处理器的事件分离器，只负责发起异步读写操作。IO 操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从 socket 读到的数据。事件分离器捕获 IO 操作完成事件，然后将事件传递给对应处理器。比如，在 windows 上，处理器发起一个异步 IO 操作，再由事件分离器等待 IOCompletion 事件。典型的异步模式实现，都建立在操作系统支持异步 API 的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。 举个例子，将有助于理解 Reactor 与 Proactor 二者的差异，以读操作为例（类操作类似）。 在 Reactor 中实现读： 注册读就绪事件和相应的事件处理器 事件分离器等待事件 事件到来，激活分离器，分离器调用事件对应的处理器。 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。 在 Proactor 中实现读： 处理器发起异步读操作（注意：操作系统必须支持异步 IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。 事件分离器等待操作完成事件 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。 事件分离器呼唤处理器。 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。 可以看出，两个模式的相同点，都是对某个 IO 事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调 handler 时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。 通俗理解使用Proactor框架和Reactor框架都可以极大的简化网络应用的开发，但它们的重点却不同。 Reactor 框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要向一个 SOCKET 写数据，那么当该S OCKET 可以接收数据的时候，你的操作就会被调用；而 Proactor 框架中用户定义的操作是在实际操作之后调用的。比如你定义了一个操作要显示从 SOCKET 中读入的数据，那么当读操作完成以后，你的操作才会被调用。 Proactor 和 Reactor 都是并发编程中的设计模式。在我看来，他们都是用于派发/分离 IO 操作事件的。这里所谓的 IO 事件也就是诸如 read/write 的 IO 操作。”派发/分离”就是将单独的 IO 事件通知到上层模块。两个模式不同的地方在于，Proactor 用于异步 IO，而 Reactor 用于同步 IO。 参考资料 知乎"},{"title":"cppcon2020 Back to basics: The structure of a Program","permalink":"http://ywqzzy.github.io/2020/10/09/cppcon2020-Back-to-basics-The-structure-of-a-Program/","text":"参考资料"},{"title":"cppcon2020 Back to basics: The Abstract Machine","permalink":"http://ywqzzy.github.io/2020/10/09/cppcon2020-Back-to-basics-The-Abstract-Machine/","text":"什么是 C++ Abstract Machine“The C++ Abstract machine is a portable abstraction of your operating system, kernel and hardware. The abstract machine is the intermediary between your c++ program and the system that it is run on.” C++ defines how programs work in terms of an abstract machine deliberately defined to be “close to the hardware”. When we write c++ code, we are writing to the c++ abstract machine. StructureMemory Objects Threads Memory A single flat space. No memory hierarchy No concept of statck, registers or cache No concept of heterogeneous memory All parts of memory are equally reachable by the am Access to memory hash uniform latency Objects Threads Summary 参考资料 cpp conference 2020 bilibili"},{"title":"testt","permalink":"http://ywqzzy.github.io/2020/09/15/在知乎上删除掉的保研经验/","text":"本科是帝都211，数字媒体技术专业（偏通信专业）。从大一下开始对编程产生了浓郁的兴趣，最开始的时候是自学c语言，当时快速学完了语法，以致于学校的c语言课都没怎么听过，考试轻松过。大一暑假接触前端，当时对于编程了解尚浅，所以更喜欢可视化的东西。跟着慕课网的课程看，也算是对前端有了初步的了解。大二课业繁重，加上大一成绩也不算特别好，就开始专心学习专业课（包括数电模电信号等课），最终得到了一个还不错的绩点，但是这段时间内对于编程的学习也就断断续续了。寒假期间陪女朋友学车的时候在驾校的咖啡厅看完了整套的邓俊辉数据结构，算是入了门，但是具体的代码也没有实践过。大二下学期由于要和做大创，又对unity浅尝辄止，算是了解了点面向对象的思想。之后参加了学校ACM集训，暑假在学校呆了一个月，每天刷题（虽然都是些简单题），倒也算是把基本的数据结构熟悉了，也锻炼了编程思维。同时又学了一些机器学习，看了《机器学习基石》系列教程，还有CS231n（当然仍然浅尝辄止）。大二下本想转专业去计科，后权衡再三，没有转。大三上。身边的大佬师哥拿到了很好的offer，交谈中其实很是振奋，觉得一直自学下去其实也是可行的，故决心放弃绩点专心刷计算机基础课，期间简略看完CSAPP,看了大半部SICP，刷了算法橙书，计算机网络（自顶向下），并且坚持ACM训练，6级考了577。有幸参加了两次ACM区域赛，均打铁（不过还是不甘）。寒假决定找工作，匆忙间看了李航的《统计学习方法》，一刷了《王道数据结构》和《剑指offer》。又知道自己基础薄弱，开始看操作系统，这门课起初学起来十分吃力，前后换了很多教程和课本，最终靠孙志岗老师的教程初步了解了操作系统。期间还看了点java和javaweb，跟着教程完成了小的项目。可以说那段时间是慌乱和迷茫的，知道自己很差却只能拼了命地弥补。 大三下继续ACM训练和计算机专业课的学习，先是看了东南徐立臻老师的《数据库》教程。又在一阵慌乱中继续着算法的训练。参加过春招（内推），打击过大，遂放弃（电话面试一问三不知，一点b-树都没有），还得感谢师哥模拟面试，虽然我最后砸的不行。决意考研，和女票一起考南大软件。在正式复习考研前，参加acm邀请赛，意外拿了银牌，算是一个很大的惊喜，可能是“杨超越附体”了。考研专业课有四门（数据结构，操作系统，计算机网络和软件工程）。从5月底到9月中旬，就是充实的考研复习阶段了。期间专业课至少过了2遍，数据结构的算法题应该都刷了不止一遍，基本的题目应该是很熟悉了。南软的软件工程专业课让我收获颇丰，一是面向对象的思想，二是一个中型系统项目对自己的启发。软件工程这门课包括了uml和一些设计模式和面向对象的知识，课程设置独树一帜。 ￼ 考研复习期间还做过php和java的项目。php项目算是学了设计模式之后的一次练兵，算是自己第一次不跟着教程写项目，对于代码不断进行重构，成就感max。 然后转机来了，机缘巧合，本不该进入保研圈的我因为之前得到的奖和相对较高的绩点幸运保研，真实的幸运，感激地一塌糊涂！！ 保研名单下来的迟，准备的少，还得感谢 @邱锐 大佬给的申请经验，成功推免至北邮网研院。 #update 更新下保研的过程吧。中秋去女票家的时候收到学校推免成功的消息后才开始投简历。之前一直准备考研，心里觉得只有拿到学校推免才能完全放下考研的复习全身心准备面试。 陆续投了一堆江浙沪和南方的学校（家在南京），包括华师，同济，复旦，华东理工，南大，中科大，中南大学之类的。当时想着就是海投了。北京投了北邮之后也就没管了。从女票家回来之后第一天就去北邮面试，上午面试计算机学院，下午网研院，网研院当场收到offer（面试官：这题你是不是都做过了？我：嗯，复习考研这些题刷过了）而且他们超棒啊，直接劝我别直博，因为我数学差的要死。王道数据结构课后题我从寒假开始刷，直到面试的时候已经刷了3遍了QAQ。 后来陆续收到科大，华师，中南的面试通知（貌似都稳了），再三考虑后全鸽了，对不起对不起对不起。 可能是大学前三年压抑太久了（翘过无数必修课选修课，就为了学会自己怎么都学不会的算法）最后想让我顺一回吧。 大学三年经历过各种迷茫困顿，总觉得无法消弭和科班大佬之间的差距，一直都在追赶，也一直在本专业的课程和计算机课程之间游离。所幸两者得兼，所幸不负韶华。 ￼￼ 一定得感谢体贴的女票一直的照顾和陪伴，你最终还是支持了我的决定。虽然你我将有短暂的分别，但是相信读完研后，我们都会是更好的自己了。 具体的学习历程还有恋爱历程之后可以更。 保研到北京还是心疼女票啊啊啊啊啊啊啊啊啊啊啊。 update 女票成功上岸南大软件。%%%%tql 转眼就到毕业。 最近才稍有些毕业的感觉。 四年是日渐拥挤的书架，日均12000步的行走，零星几个肝掉的深夜，几十张车票，“北境不遗忘”，“我要成为海贼王”，“Run as one”…. 少了许多少年心事，不再说华丽辞藻含蓄故事。多了肚子、大腿上的肉，愈发坚定且直抒胸臆。 前两天采访时候，问研究生规划我并未作答。并非毫无愿景。四年的际遇奇迹满满，三年后亦未可知，不设限，任我行。希望能够各自攀峰，山顶再会 毕业后要变成一个真正的男人，要控制情绪，处理好生活与工作，爱自己，爱他人，眼里有光。 感谢不可能的和可能的。 遇见你之前，幻想高考多对一道选择题，物理大题第一题没有算错，或许人生的轨迹就会大不相同。 遇见你之后，无法形容自己有多幸运。在人生的这条马氏链上，我似乎找到了Best policy，援引The big bang theroy剧内插曲的歌词。 I couldn’t have imagined How good my life would get From the moment that I met you 过去的遗憾也不能算是遗憾了，现在拥有的就是现在了。 穿过人潮汹涌灯火阑珊， 没有想过回头。 再 update 日期2020/9/15 经过一段阵痛期，之后再寒假后陪女票找实习，npy太强了，先后拿下跟谁学，美团，字节，阿里的实习offer，实习后更加知道了追求的东西和出路。 之前的一些幼稚想法也变得成熟起来。 前路坦荡，可别走歪了。"},{"title":"词法分析","permalink":"http://ywqzzy.github.io/2019/04/27/词法分析/","text":"标识符是一个大的集合。 记号的数据结构定义123456789101112enum kind &#123;IF,LPAREN,ID,INTLIT,...&#125;struct token&#123; enum kind k; char *lexeme;// 单词&#125;；/*eg if(x&gt;5) ===&gt;&gt; token&#123;k=IF,lexeme=0&#125;;token&#123;k=LPAREN,lexeme=0&#125;；token&#123;k=ID,lexeme=\"x\"&#125;;.....*/ 词法分析器的任务，字符流到记号流。 记号流是编译器内部定义的数据结构，编码所识别出的词法单元。 词法分析—手工构造法相对复杂，容易出错。 词法分析器的生成器（自动化）：可快速原型、代码量少，但难控制细节。 转移图 1234567891011121314151617token nextToken() &#123; c = getChar(); switch(c) &#123; case '&lt;': c= getChar(); switch(c)&#123; case '=': return LE; case='&gt;':return NE; default: rollback();return LT; &#125; case '=':return EQ; case '&gt;': c= getChar(); switch(c):&#123; .....//和上面类似 &#125; &#125;&#125; 标识符的转移图： 识别关键字 也可以弄关键字构成的哈希表，先统一按照关键符的转移图进行识别，进一步查表看是否是关键字。完美哈希 正则表达式 kleene闭包。 例子：标识符c语言：以字母或下划线开头，后面跟多个或0个字母数字或下划线 （a|b|c|…..z|A|B|C|….|Z|–)(a|b|c|…..z|A|B|C|….|Z|–|0|1|…|9|)* 有限状态自动机 非确定有限状态自动机（NFA） 确定有限状态自动机（DFA) NFA难以判断字符串是否可接受。需要进行搜索。需要将NFA转化为等价的DFA。 DFA的实现带有边和节点的有向图。 边上面有信息 节点上有信息 正则表达式到NFA（Thompson算法）RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码 对基本的RE直接构造 对复合的RE递归构造 NFA转化为DFA（子集构造法） 不动点算法：why能终止？ DFA最小化Hopcroft算法 什么叫做能切分？ 首先切分成非终结符和终结符两类 DFA的代码表示转移表 哈希表 跳转表 转移表：还要有词法分析驱动代码。 ​ 最长匹配思想。 跳转表: 跳转表不需要维护一个大的转移数组。"},{"title":"test","permalink":"http://ywqzzy.github.io/2019/01/22/test/","text":"IO模型Unix有五种IO模型， 阻塞式I/O 非阻塞式I/O I/0复用（select/poll） 信号驱动式（SIGIO） 异步I/O(AIO) 阻塞式I/O应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。 应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率效率会比较高。 下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。 1ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);"}]}