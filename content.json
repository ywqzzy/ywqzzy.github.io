{"pages":[{"title":"About","permalink":"http://ywqzzy.github.io/about/index.html","text":""},{"title":"Categories","permalink":"http://ywqzzy.github.io/categories/index.html","text":""},{"title":"Tags","permalink":"http://ywqzzy.github.io/tags/index.html","text":""}],"posts":[{"title":"实现string类","permalink":"http://ywqzzy.github.io/2020/10/19/实现string类/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class String&#123;public: String() :data_(new char[1]) &#123; *data_ = '\\0'; &#125; String(const char&amp; str) :data_(new char[strlen(str) + 1]) &#123; strcpy(data_, str); &#125; String(const String&amp; rhs) :data_(new char[rhs.size() + 1]) &#123; strcpy(data_, rhs.c_str()); &#125; ~String() &#123; delete[] data_; &#125; /* traditional String&amp; operator=(const String&amp; rhs) &#123; String tmp(rhs); swap(tmp); return *this &#125;*/ String&amp; operator=(String rhs) &#123; swap(rhs); return *this; &#125; // C++ 11 String(String&amp;&amp; rhs) : data_(rhs.data_) &#123; rhs.data_ = nullptr; &#125; String&amp; operator=(String&amp;&amp; rhs) &#123; swap(rhs); return *this; &#125; size_t size() const &#123; return strlen(data_); &#125; const char* c_str() const &#123; return data_; &#125; void swap(String&amp; rhs) &#123; std::swap(data_, rhs.data_); &#125; private: char* data_;&#125; 12345String&amp; operator=(String rhs) // yes, pass-by-value&#123; swap(rhs); return *this;&#125; 使用swap的原因是，这个String类涉及到内存分配操作，这个操作可能会抛出异常；上面的实现分3步： 把“源对象”拷贝到参数rhs里 rhs对象和this对象做一下交换（仅仅交换指针） 返回this对象 第一步有可能发生异常（new操作失败），然后在这一步退出；这是下两歩操作还没有进行，所以不会污染this对象。保证了： 赋值操作失败，但是this对象没有被污染，或者 赋值操作成功 参考资料 chenshuo coolshell"},{"title":"Noncopyable","permalink":"http://ywqzzy.github.io/2020/10/19/Noncopyable/","text":"在 Muduo 中，有一个 noncopyable 类，继承了该类的派生类不能被拷贝，只能被移动。涉及拷贝的函数有两个：拷贝构造函数和拷贝复制操作符。将这两个方法声明为不可访问或者删除，就可以达到不可拷贝的效果。 将函数声明为 private将拷贝构造函数和拷贝复制操作符声明为 private，能阻止编译器创建这两个函数，同时阻止用户调用他们，从而达到阻止拷贝的效果。 123456789class noncopyable&#123;protected: noncopyable() &#123;&#125; ~noncopyable() &#123;&#125;private:// emphasize the following members are private noncopyable( const noncopyable&amp; ); noncopyable&amp; operator=( const noncopyable&amp; );&#125;; 使用方法如下： 1class foo: private noncopyable&#123;&#125;; 一定要使用 private 来继承，防止 member 函数和 friend 函数访问。 c++11 使用 delete关键字代码如下： 12345678class noncopyable &#123;protected: noncopyable() = default; ~noncopyable() = default;private: noncopyable(const noncopyable&amp;) = delete; const noncopyable&amp; operator=( const noncopyable&amp; ) = delete;&#125;; 把构造函数和析构函数设置为 protected 权限，这样子类可以调用，外面的其他类不能调用。 使用 delete 关键字禁止编译器自动产生 copy 构造函数，和copy assignment ctor。 参考资料 muduo segmentfault"},{"title":"对象池","permalink":"http://ywqzzy.github.io/2020/10/18/对象池/","text":"对象池对于创建开销比较大的对象来说很有意义，为了避免重复创建开销比较大的对象，我们可以通过对象池来优化。对象池的思路比较简单，事先创建好一批对象，放到一个集合中，以后每当程序需要新的对象时候，都从对象池里获取，每当程序用完该对象后，都把该对象归还给对象池。这样会避免重复的对象创建，提高程序性能。 简单实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;list&gt; template&lt;typename Object&gt;class ObjectPool&#123;public: ObjectPool(size_t unSize) : m_unSize(unSize) &#123; for (size_t unIdx = 0; unIdx &lt; m_unSize; ++ unIdx) &#123; m_oPool.push_back(new Object()); &#125; &#125; ~ObjectPool() &#123; typename std::list&lt;Object *&gt;::iterator oIt = m_oPool.begin(); while (oIt != m_oPool.end()) &#123; delete (*oIt); ++ oIt; &#125; m_unSize = 0; &#125; Object * GetObject() &#123; Object * pObj = NULL; if (0 == m_unSize) &#123; pObj = new Object(); &#125; else &#123; pObj = m_oPool.front(); m_oPool.pop_front(); -- m_unSize; &#125; return pObj; &#125; void ReturnObject(Object * pObj) &#123; m_oPool.push_back(pObj); ++ m_unSize; &#125; private: size_t m_unSize; std::list&lt;object *&gt; m_oPool;&#125;; 不足点如下： 对象池ObjectPool只能容纳特定类型的对象，不能容纳所有类型的对象，可以支持重载的和参数不同的构造函数； 对象用完之后需要手动回收，用起来不够方便，更大的问题是存在忘记回收的风险； 希望能有一个更强大的对象池，这个对象池能容纳所有的对象，还能自动回收用完了对象，不需要手动回收，用起来更方便。要实现这样的对象池需要解决前面提到的两个问题，通过c++11就可以解决这两个问题。 对于问题1：容纳所有的对象。本质上需要将对象池中的对象类型擦除，这里用Any类型就可以解决。 对于问题2：自动回收用完的对象。这里用智能指针就可以解决，在创建智能指针时可以指定删除器，在删除器中不删除对象，而是回收到对象池中，而这个过程对外界来说是看不见的，由智能指针自己完成。 ​ 暂时不考虑解决问题一。 一个支持自动回收的对象池实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#ifndef IG_SHARED_OBJECT_POOL_H_#define IG_SHARED_OBJECT_POOL_H_#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;memory&gt;namespace ig &#123; static const size_t kObjectPoolDefaultSize = 100;static const size_t kObjectPoolDefaultExtendSize = 10;template &lt;typename ObjectType&gt;struct ObjectPoolDefaultInitializer &#123; void operator()(ObjectType *object) const &#123; &#125;&#125;;template &lt;typename ObjectType, size_t N = kObjectPoolDefaultSize, typename Initializer = ObjectPoolDefaultInitializer&lt;ObjectType&gt; &gt;class SharedObjectPool &#123; public: static SharedObjectPool&amp; Instance() &#123; static SharedObjectPool pool(N); return pool; &#125; std::shared_ptr&lt;ObjectType&gt; Get() &#123; ObjectType *ptr = nullptr; if (queue_.empty()) &#123; Extend(kObjectPoolDefaultExtendSize); &#125; ptr = queue_.front(); queue_.pop(); kInitializer(ptr); return std::shared_ptr&lt;ObjectType&gt;(ptr, [&amp;](ObjectType *p) &#123; queue_.push(p); &#125;); &#125; int capacity() const &#123; return capacity_; &#125; void set_capacity(const size_t capacity) &#123; if (capacity_ &lt; capacity) &#123; Extend(capacity - capacity_); &#125; &#125; private: explicit SharedObjectPool(const size_t pool_size) : kDefaultCacheSize(pool_size) &#123; cache_ = new ObjectType[kDefaultCacheSize]; for (size_t i = 0; i &lt; kDefaultCacheSize; ++i) &#123; queue_.push(&amp;cache_[i]); kInitializer(&amp;cache_[i]); &#125; capacity_ = kDefaultCacheSize; &#125; ~SharedObjectPool() &#123; if (cache_) &#123; delete[] cache_; cache_ = nullptr; &#125; for (auto &amp;ptr : extended_cache_) &#123; delete ptr; &#125; extended_cache_.clear(); &#125; void Extend(const size_t num) &#123; for (size_t i = 0; i &lt; num; ++i) &#123; ObjectType *ptr = new ObjectType; extended_cache_.push_back(ptr); queue_.push(ptr); kInitializer(ptr); &#125; capacity_ = kDefaultCacheSize + extended_cache_.size(); &#125; private: size_t capacity_ = 0; std::queue&lt;ObjectType*&gt; queue_; ObjectType *cache_ = nullptr; std::list&lt;ObjectType*&gt; extended_cache_; const size_t kDefaultCacheSize; static const Initializer kInitializer;&#125;; template &lt;typename ObjectType, size_t N, typename Initializer&gt;const Initializer SharedObjectPool&lt;ObjectType, N, Initializer&gt;::kInitializer;&#125; // namespace ig#endif // IG_SHARED_OBJECT_POOL_H_ 参考资料 对象池 一个超级对象池的实现"},{"title":"pImpl","permalink":"http://ywqzzy.github.io/2020/10/18/pImpl/","text":"pImpl（Private Implementation 或 Pointer to Implementation）是通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏。 优点： 降低模块的耦合。因为隐藏了类的实现，被隐藏的类相当于原类不可见，对隐藏的类进行修改，不需要重新编译原类。 降低编译依赖，提高编译速度。 接口与实现分离，提高接口的稳定性。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#ifndef __LINE_H__#define __LINE_H__ //设计模式: PIMPL//1. 实现信息隐藏//2. 减小编译依赖, 可以用最小的代价平滑的升级库文件，//3. 接口与实现进行解耦 class Line&#123;public: Line(int,int,int,int); ~Line(); void printLine() const;private: class LineImpl;private: LineImpl * _pimpl;&#125;;class Line::LineImpl&#123; class Point &#123; public: Point(int ix = 0, int iy = 0) : _ix(ix) , _iy(iy) &#123; cout &lt;&lt; \"Point(int=0, int=0)\" &lt;&lt; endl; &#125; void print() const &#123; cout &lt;&lt; \"(\" &lt;&lt; _ix &lt;&lt; \",\" &lt;&lt; _iy &lt;&lt; \")\"; &#125; private: int _ix; int _iy; &#125;;public: LineImpl(int x1, int y1, int x2, int y2) : _p1(x1, y1) , _p2(x2, y2) &#123; cout &lt;&lt; \"LineImpl(int,int,int,int)\" &lt;&lt; endl; &#125; ~LineImpl() &#123; cout &lt;&lt; \"~LineImpl()\" &lt;&lt; endl; &#125; void printLine() const;private: Point _p1; Point _p2;&#125;; void Line::LineImpl::printLine() const&#123; _p1.print(); cout &lt;&lt; \" --&gt; \"; _p2.print(); cout &lt;&lt; endl;&#125; Line::Line(int x1, int y1, int x2, int y2): _pimpl(new LineImpl(x1, y1, x2, y2))&#123; cout &lt;&lt; \"Line(int,int,int,int)\" &lt;&lt; endl;&#125; Line::~Line()&#123; delete _pimpl; cout &lt;&lt; \"~Line()\" &lt;&lt; endl;&#125; void Line::printLine() const&#123; _pimpl-&gt;printLine();&#125;#endif 参考资料 cnblogs"},{"title":"RAII","permalink":"http://ywqzzy.github.io/2020/10/18/RAII/","text":"什么是RAIIRAII（Resource Acquisition Is Initialization）是由 c++ 之父 Bjarne Stroustrup 提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入； RAII的原理资源的使用一般经历三个步骤 获取资源 使用资源 销毁资源。 但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++ 之父给出了解决问题的方案：RAII，它充分的利用了 C++ 语言局部对象自动销毁的特性来控制资源的生命周期。给一个简单的例子来看下局部对象的自动销毁的特性： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class person &#123; public: person(const std::string name = \"\", int age = 0) : name_(name), age_(age) &#123; std::cout &lt;&lt; \"Init a person!\" &lt;&lt; std::endl; &#125; ~person() &#123; std::cout &lt;&lt; \"Destory a person!\" &lt;&lt; std::endl; &#125; const std::string&amp; getname() const &#123; return this-&gt;name_; &#125; int getage() const &#123; return this-&gt;age_; &#125; private: const std::string name_; int age_; &#125;;int main() &#123; person p; return 0;&#125;/*编译并运行：g++ person.cpp -o person./person 运行结果：Init a person!Destory a person!*/ 从 person class 可以看出，当我们在 main 函数中声明一个局部对象的时候，会自动调用构造函数进行对象的初始化，当整个 main 函数执行完成后，自动调用析构函数来销毁对象，整个过程无需人工介入，由操作系统自动完成；于是，很自然联想到，当我们在使用资源的时候，在构造函数中进行初始化，在析构函数中进行销毁。整个RAII 过程我总结四个步骤： 设计一个类封装资源 在构造函数中初始化 在析构函数中执行销毁操作 使用时声明一个该对象的类 应用linux 下经常会使用多线程技术，说到多线程，就得提到互斥锁，互斥锁主要用于互斥，互斥是一种竞争关系，用来保护临界资源一次只被一个线程访问，按照我们前面的分析，封装一下 POSIX 标准的互斥锁： 123456789101112131415161718192021222324252627282930313233343536#include &lt;pthread.h&gt;#include &lt;cstdlib&gt;#include &lt;stdio.h&gt;class Mutex &#123; public: Mutex(); ~Mutex(); void Lock(); void Unlock(); private: pthread_mutex_t mu_; // No copying Mutex(const Mutex&amp;); void operator=(const Mutex&amp;);&#125;;#include \"mutex.h\"static void PthreadCall(const char* label, int result) &#123; if (result != 0) &#123; fprintf(stderr, \"pthread %s: %s\\n\", label, strerror(result)); &#125;&#125;Mutex::Mutex() &#123; PthreadCall(\"init mutex\", pthread_mutex_init(&amp;mu_, NULL)); &#125;Mutex::~Mutex() &#123; PthreadCall(\"destroy mutex\", pthread_mutex_destroy(&amp;mu_)); &#125;void Mutex::Lock() &#123; PthreadCall(\"lock\", pthread_mutex_lock(&amp;mu_)); &#125;void Mutex::Unlock() &#123; PthreadCall(\"unlock\", pthread_mutex_unlock(&amp;mu_)); &#125; 写到这里其实就可以使用 Mutex 来锁定临界区，但我们发现 Mutex 只是用来对锁的初始化和销毁，我们还得在代码中调用 Lock 和 Unlock 函数，这又是一个对立操作，所以我们可以继续使用 RAII 进行封装，代码如下： 12345678910111213141516#include \"mutex.h\"class MutexLock &#123; public: explicit MutexLock(Mutex *mu) : mu_(mu) &#123; this-&gt;mu_-&gt;Lock(); &#125; ~MutexLock() &#123; this-&gt;mu_-&gt;Unlock(); &#125; private: Mutex *const mu_; // No copying allowed MutexLock(const MutexLock&amp;); void operator=(const MutexLock&amp;);&#125;; 使用示例如下： 12345678910111213141516171819202122232425262728293031323334353637#include \"mutexlock.hpp\"#include &lt;unistd.h&gt;#include &lt;iostream&gt;#define NUM_THREADS 10000int num=0;Mutex mutex;void *count(void *args) &#123; MutexLock lock(&amp;mutex); num++;&#125;int main() &#123; int t; pthread_t thread[NUM_THREADS]; for( t = 0; t &lt; NUM_THREADS; t++) &#123; int ret = pthread_create(&amp;thread[t], NULL, count, NULL); if(ret) &#123; return -1; &#125; &#125; for( t = 0; t &lt; NUM_THREADS; t++) pthread_join(thread[t], NULL); std::cout &lt;&lt; num &lt;&lt; std::endl; return 0;&#125;/*编译并运行：g++ test_mutexlock.cpp mutexlock.hpp mutex.cpp mutex.h -o test_mutexlock -lpthread./test_mutexlock 运行结果：10000 符合预期（可以去掉MutexLock lock(&amp;mutex);试试看看结果如何？）*/ 参考资料 知乎"},{"title":"智能指针","permalink":"http://ywqzzy.github.io/2020/10/18/智能指针/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485template&lt;class T&gt;class SharedPointer&#123;public: SharedPointer():m_refCount(nullptr), m_pointer(nullptr) &#123;&#125; SharedPointer(T* adoptTarget):m_refCount(nullptr), m_pointer(adoptTarget) &#123; addReference(); &#125; SharedPointer(const SharedPointer&lt;T&gt;&amp; copy):m_refCount(copy.m_refCount), m_pointer(copy.m_pointer) &#123; addReference(); &#125; virtual ~SharedPointer() &#123; removeReference(); &#125; //赋值操作 //当左值被赋值时，表明它不再指向所指的资源，故引用计数减一 //之后，它指向了新的资源，所以对应这个资源的引用计数加一 SharedPointer&lt;T&gt;&amp; operator=(const SharedPointer&lt;T&gt;&amp; that) &#123; if (this != &amp;that) &#123; removeReference(); this-&gt;m_pointer = that.m_pointer; this-&gt;m_refCount = that.m_refCount; addReference(); &#125; return *this; &#125; //判断是否指向同一个资源 bool operator==(const SharedPointer&lt;T&gt;&amp; other) &#123; return m_pointer == other.m_pointer; &#125; bool operator!=(const SharedPointer&lt;T&gt;&amp; other) &#123; return !operator==(other); &#125; //指针解引用 T&amp; operator*() const &#123; return *m_pointer; &#125; //调用所知对象的公共成员 T* operator-&gt;() const &#123; return m_pointer; &#125; //获取引用计数个数 int GetReferenceCount() const &#123; if (m_refCount) &#123; return *m_refCount; &#125; else &#123; return -1; &#125; &#125; protected: //当为nullpter时，创建引用计数资源，并初始化为1 //否则，引用计数加1。 void addReference() &#123; if (m_refCount) &#123; (*m_refCount)++; &#125; else &#123; m_refCount = new int(0); *m_refCount = 1; &#125; &#125; void removeReference() &#123; if(m_refCount) &#123; (*m_refCount)--; if(*m_refCount == 0) &#123; delete m_refCount; delete m_pointer; m_refCount = 0; m_pointer = 0; &#125; &#125; &#125;private: int *m_refCount; T *m_pointer;&#125;;"},{"title":"Singleton--C++","permalink":"http://ywqzzy.github.io/2020/10/18/Singleton-c/","text":"懒汉版最简版123456789101112131415class Singleton &#123;private: static Singleton* instance; Singleton() &#123;&#125;; ~Singleton() &#123;&#125;; Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton* getInstance() &#123; if(instance == NULL) instance = new Singleton(); return instance; &#125;&#125;;Singleton* Singleton::instance = NULL; 存在内存泄漏的问题，解决方案： 使用智能指针 使用静态的嵌套类对象 使用静态的嵌套类对象1234567891011121314151617181920212223class Singleton &#123;private: static Singleton* instance; Singleton() &#123;&#125;; ~Singleton() &#123;&#125;; Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton* getInstance() &#123; if(instance == NULL) instance = new Singleton(); return instance; &#125;private: class Deletor &#123; public: ~Deletor() &#123; if(Singleton::instance != NULL) delete Singleton::instance; &#125; &#125;; static Deletor deletor;&#125;;Singleton* Singleton::instance = NULL; 在程序运行结束时，系统会调用静态成员 deletor 的析构函数，该析构函数会删除单例的唯一实例。 使用这种方法释放单例对象有以下特征： 在单例类内部定义专有的嵌套类。 在单例类内定义私有的专门用于释放的静态成员。 利用程序在结束时析构全局变量的特性，选择最终的释放时机。 上述代码不仅麻烦，并且在多线程环境下会出现竞争，考虑使用双检测锁模式（Double-Checked locking Pattern) 加锁123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;mutex&gt;using namespace std;std::mutex mt;class Singleton&#123;private: Singleton()&#123;&#125;public: static Singleton* instance() &#123; mt.lock(); // 加锁 if(_instance == 0) _instance = new Singleton(); mt.unlock(); // 解锁 return _instance; &#125;private: static Singleton* _instance;&#125;;Singleton* Singleton::_instance = 0; 上锁后是解决了线程安全问题，但是有些资源浪费。稍微分析一下：每次instance函数调用时候都需要请求加锁，其实并不需要，instance函数只需第一次调用的时候上锁就行了。这时可以用DCLP解决。 双检查锁，由于内存读写导致不安全Double-Checked Locking Pattern 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;mutex&gt;using namespace std;std::mutex mt;class Singleton&#123;private: Singleton()&#123;&#125;public: static Singleton* instance() &#123; if(_instance == 0) &#123; mt.lock(); if(_instance == 0) _instance = new Singleton(); mt.unlock(); &#125; return _instance; &#125;private: static Singleton* _instance;public: int atestvalue;&#125;;Singleton* Singleton::_instance = 0; 这个版本很不错，又叫“双重检查”Double-Check。下面是说明： 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。 不然，我们就开始同步线程。 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。 分析 1_instance = new Singleton(); 为了执行这句代码，机器需要做三样事儿： singleton对象分配空间。 在分配的空间中构造对象 使_instance指向分配的空间 遗憾的是编译器并不是严格按照上面的顺序来执行的。可以交换2和3. 将上面三个步骤标记到代码中就是这样： 123456789101112Singleton* Singleton::instance() &#123; if (_instance == 0) &#123; mt.lock(); if (_instance == 0) &#123; _instance = // Step 3 operator new(sizeof(Singleton)); // Step 1 new (_instance) Singleton; // Step 2 &#125; mt.unlock(); &#125; return _instance;&#125; 线程A进入了instance函数，并且执行了step1和step3，然后挂起。这时的状态是：_instance不 NULL，而_instance指向的内存区没有对象！ 线程B进入了instance函数，发现_instance不为null，就直接return _instance了。 local staticC++ 11 规定了 local static 在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。 12345678910111213class Singleton &#123;private: Singleton() &#123; &#125;; ~Singleton() &#123; &#125;; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;public: static Singleton&amp; getInstance() // 返回引用 &#123; static Singleton instance; // 静态局部变量 return instance; &#125;&#125;; gcc 4.0之后的编译器支持这种写法。 C++11及以后的版本（如C++14）的多线程下，正确。 C++11之前不能这么写。 C++11 call_once12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;std::once_flag flag;class Singleton&#123;public: static Singleton&amp; getInstance() &#123; std::call_once(flag, []() &#123;instance_.reset(new Singleton()); &#125;); return *instance_; &#125;private: static std::unique_ptr&lt;Singleton&gt; instance_;private: Singleton() = default; Singleton(const Singleton&amp; other) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;;std::unique_ptr&lt;Singleton&gt; Singleton::instance_;void do_onceflag()&#123; Singleton&amp; s = Singleton::getInstance(); cout &lt;&lt; &amp;s &lt;&lt; endl;&#125;int main()&#123; std::thread t1(do_onceflag); std::thread t2(do_onceflag); t1.join(); t2.join(); return 0;&#125; 饿汉版单例实例在程序运行时被立即执行初始化。 1234567891011121314class Singleton &#123;private: static Singleton instance;private: Singleton(); ~Singleton(); Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton&amp; getInstance() &#123; return instance; &#125;&#125;;Singleton Singleton::instance; 由于在 main 函数之前初始化，所以没有线程安全的问题。但是潜在问题在于 no-local static 对象（函数外的 static对象）在不同编译单元中的初始化顺序是未定义的。也即，static Singleton instance;和 static Singleton&amp; getInstance() 二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。"},{"title":"写一个 Move aware class","permalink":"http://ywqzzy.github.io/2020/10/16/写一个-move-aware-class/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class MyString &#123;public: static size_t DCtor; static size_t Ctor; static size_t CCtor; static size_t CAsgn; static size_t MCtor; static size_t Dtor;private: char* _data; size_t _len; void _init_data(const char *s) &#123; _data = new char[_len + 1]; memcpy(_data, s, _len); _data[_len] = '\\0'; &#125;public: // default ctor MyString(): _data(NULL), _len(0) &#123; ++DCtor; &#125; // ctor MyString(const char* p): _len(strlen(p)) &#123; ++Ctor; _init_data(p); &#125; // copy ctor MyString(const Mystring&amp; str):_len(str._len) &#123; ++CCtor; _init_data(str._data); &#125; // move ctor MyString(MyString&amp;&amp; str) noexcept :_data(str._data), _len(str._len) &#123; ++MCtor; str._len = 0; str._data = NULL;// IMPORTANT &#125; // copy assignment MyString&amp; operator=(const MyString&amp; str) &#123; ++CAsgn; if(this != &amp;str) &#123; // 自我赋值检查 if(_data) delete _data; _len = str._len; _init_data(str._data); &#125; else &#123; &#125; return *this; &#125; // move assignment MyString&amp; operator=(MyString&amp;&amp; str) noexcept&#123; ++MAsgn; if(this != &amp;str) &#123; // 自我赋值检查 if(_data) delete _data; _len = str._len; _data = str._data; str._len = 0; str._data = NULL; &#125; return *this; &#125; // dtor virtual ~MyString() &#123; ++Dtor; if(_data) delete _data; &#125; // operator&lt; bool operator&lt;(const MyString&amp; rhs) const &#123; return string(this-&gt;data) &lt; string(rhs._data); &#125; // operator== bool operator==(const MyString&amp; rhs) const &#123; return string(this-&gt;data) == string(rhs._data); &#125; char* get() const &#123; return _data; &#125; &#125;size_t MyString::DCtor = 0;size_t MyString::Ctor = 0;size_t MyString::CCtor = 0;size_t MyString::CAsgn = 0;size_t MyString::MCtor = 0;size_t MyString::Dtor = 0;size_t MyString::MAsgn = 0;namespace std &#123;template&lt;&gt;struct hash&lt;MyString&gt; &#123; // for unordered containers size_t operator() (const MyString&amp; s) const noexcept &#123; return hash&lt;string&gt;()(string(s.get())); // 借用现成的 hash&lt;string&gt; &#125;&#125;&#125;"},{"title":"Rvalue references","permalink":"http://ywqzzy.github.io/2020/10/16/Rvalue-references/","text":"Rvalue-referencesRvalue references are a new reference type introduced in C++0x that help solve the problem of unnecessary coping and enable perfect forwarding. When the right-hand side of an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a seperate allocation, thus enabling move semantics. Lvalue: 可以出现于 operator = 左侧者 Rvalue: 只能出现于 operator = 右侧者 只要在内存中有确定存储空间的都是左值。 1234567int foo() &#123; return 5;&#125;int x = foo(); // okint *p = &amp;foo(); // error 对着右值 5 取其 reference 是不可以的。没有所谓的 Rvalue reference（before C++0x)foo() = 7; // error 当 Rvalue 出现于 operator=(copy assignment)的右侧，我们认为对其资源进行偷取/搬移（move) 而非拷贝（copy）是可以的。 那么： 必须有语法让我们在调用端告诉编译器，这是个“Rvalue” 必须有语法让我们在被调用端写出一个专门处理 Rvalue 的所谓 move assignment 函数。 Perfect Forwarding Perfect forwarding allows you to write a single function template that takes n arbitrary arguments and forwards them transparently to another arbitrary function. The nature of the argument(modifiable, const, lvalue, rvalue) is preserved in the forwarding process. 1234template&lt;typename T1, typename T2&gt;void functionA(T1&amp;&amp; t1, T2&amp;&amp; t2) &#123; functionB(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));&#125;"},{"title":"lambda","permalink":"http://ywqzzy.github.io/2020/10/16/lambda/","text":"C++11 introduced lambdas, allowing the definition of inline functionality, which can be used as a parameter or a local object. Lambdas change the way the C++ statndard library is used. A lambda is a definition of functionality that can be defined inside statements and expressions. Thus, you can use a lambda as an inline function. The minimal lambda function has no parameters and simply does something. 12345678910111213[] &#123; std::cout &lt;&lt; \"hello lambda\"&lt;&lt;std::endl;&#125;[] &#123; std::cout&lt;&lt; \"hello lambda\"&lt;&lt;std::endl;&#125;();auto l = [] &#123; std::cout&lt;&lt; \"hello lambda\"&lt;&lt;std::endl;&#125;l();"},{"title":"decltype","permalink":"http://ywqzzy.github.io/2020/10/16/decltype/","text":"Defines a type equivalent to the type of an expression. By using the decltype keyword, you can let the compiler find out the type of an expression, this is the realization of the often requested typepf feature. One application of decltype is to declare return types; Another is to use it in metaprogramming or to pass the type of a lambda. 12345678910111213141516171819202122232425// 1. declare return typestemplate&lt;typename T1, typename T2&gt;decltype(x + y) add(T1 x, T2 y); // 不行template&lt;typename T1, typename T2&gt;auto add(T1 x, T2 y) -&gt; decltype(x + y);// 2. meta programmingtemplate&lt;typename T&gt;void test_decltype(T obj) &#123; map&lt;string, float&gt;::value_type elem1; map&lt;string, float&gt; coll; decltype(coll)::value_type elem2; typedef typename decltype(obj)::iterator iType; // =&gt; typedef typename T::iterator iType // test_decltype(complex&lt;int&gt;()) 编译失败 decltype(obj) anotherObj(obj);&#125;// 3. pass the type of lambdaauto cmp = [](const Person&amp; p1, const Person&amp; p2) &#123; return p1.lastname() &lt; p2.lastname() || (p1.lastname() == p2.lastname() &amp;&amp; p1.firstname() &lt; p2.firstname()); &#125;;std::set&lt;Person, decltype(cmp)&gt; coll(cmp);"},{"title":"noexcept","permalink":"http://ywqzzy.github.io/2020/10/16/noexcept/","text":""},{"title":"Type Alias & using","permalink":"http://ywqzzy.github.io/2020/10/16/Type-Alias/","text":"Type aliasSimilar to typedef 1234567891011// type alias, identical to// typedef void (*func)(int, int)using func = void (*)(int, int);void example(int, int) &#123;&#125;func fn = example;// alias templatetemplate&lt;class CharT&gt; using mystring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;mystring&lt;char&gt; str; 和 &lt;string_fwd.h&gt; 都有以下 typedef: typedef basic_string string; 12345678910// type alias can introduce a member typedef nametemplate&lt;typename T&gt;struct Container &#123; using value_type = T; // typedef T value_type;&#125;;template&lt;typename Cntr&gt;void fn2(const Cntr&amp; c) &#123; typename Cntr::value_type n;&#125; using using-directives for namespaces and using-declarations for namespace members; 12using namespace std;using std::count; using-declarations for class members 12345protected: using _Base::_M_allocate; using _Base::_M_deallocate; using _Base::_S_nword; using _Base::_M_get_Bit_allocator; type alias and alias template declaration"},{"title":"Range-based for statement","permalink":"http://ywqzzy.github.io/2020/10/16/range-based-for-statement/","text":"1234567891011121314151617/*for( decl : coll) &#123; statement&#125;*/for(int i: &#123;2，3，4，5，6，76，7，8，8&#125;) &#123; cout&lt;&lt;i&lt;&lt;endl;&#125;vector&lt;double&gt; vec;for(auto elem: vec) &#123; cout&lt;&lt; elem &lt;&lt;endl;&#125;for(auto&amp; elem: vec) &#123; elem *= 3;&#125;// 关联式容器不能修改值 No explicit type conversions are possible when elements are initialized as decl inside the for loop. Thus, the following does not compile: 12345678910class C &#123; public: explicit C(const string&amp; s); ....&#125;;vector&lt;string&gt; vs;for(const C&amp; elem: vs) &#123; // error no conversion from string to C defined cout&lt;&lt;elem&lt;&lt;endl;&#125;"},{"title":"explicit关键字","permalink":"http://ywqzzy.github.io/2020/10/16/explicit关键字/","text":"用在一个实参上的 explicit。123456789struct Complex &#123; int real, imag; Complex(int re, int im = 0): real(re), imag(im)&#123;&#125; Complex operator+(const Complex&amp; x) &#123; return Complex((real + x,real), (imag + x.imag)); &#125;&#125;Complex c1(12, 5);Complex c2 = c1 + 5; // 会调用构造函数 将 5 隐式转换为 Complex 123456789struct Complex &#123; int real, imag; explicit Complex(int re, int im = 0): real(re), imag(im)&#123;&#125; Complex operator+(const Complex&amp; x) &#123; return Complex((real + x,real), (imag + x.imag)); &#125;&#125;Complex c1(12, 5);Complex c2 = c1 + 5; // [Error] no match for 'operator+'(operand types are 'Complex' ands 'int') 用在多个实参上的 explicit"},{"title":"Variadic Templates","permalink":"http://ywqzzy.github.io/2020/10/15/Variadic-Templates/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;// 处理无参数的情况void printX() &#123; std::cout &lt;&lt; std::endl;&#125;// 任意参数类型template&lt;typename T, typename... Types&gt;void printX(const T&amp; firstArg, const Types&amp;... args) &#123; std::cout &lt;&lt; firstArg &lt;&lt; std::endl; std::cout &lt;&lt; \"left:\" &lt;&lt; sizeof...(args) &lt;&lt; \"params\" &lt;&lt; \" \"; // args 会被分为2部分 一部分是第一个参数 第二部分是args... printX(args...);&#125;// ... 是所谓的 pack// 用于 template parameters 就是 template parameters pack// 用于 function parameter types 就是 function parameter types pack// 用于 function parameters 就是 function parameters packvoid printf(const char *s) &#123; while(*s) &#123; if(*s=='%'&amp;&amp;*(++s)!='%') throw std::runtime_error(\"invalid format string\"); std::cout &lt;&lt; *s++; &#125;&#125;//printftemplate&lt;typename T, typename... Args&gt;void printf(const char* s, T value, Args... args) &#123; while(*s) &#123; if(*s=='%'&amp;&amp;*(++s)!='%') &#123; std::cout &lt;&lt; value; printf(++s, args...); return; &#125; std::cout &lt;&lt; *s++; &#125; throw std::runtime_error(\"invalid format string\");&#125;int maximum(int n) &#123;return n;&#125;template&lt;typename...Args&gt;int maximum(int n, Args... args) &#123; return std::max(n, maximum(args...));&#125;int main() &#123; printX(1,2,3,\"asa\"); std::cout &lt;&lt; maximum(1,2,3,4) &lt;&lt; std::endl;&#125;"},{"title":"uniform initialization","permalink":"http://ywqzzy.github.io/2020/10/15/uniform-initialization/","text":"123456int values[] &#123;1,2,3&#125;;vector&lt;int&gt; v&#123;2,3,5,6,7,11,13&#125;;vector&lt;string&gt; cities &#123; \"beijing\", \"shanghai\",\"nanjing\"&#125;;complex&lt;double&gt; c&#123;4.0, 3.0&#125;; 利用一个事实，编译器看到{t1,t2,…,tn} 便会做出一个 initializer_list, 它关联至一个 array&lt;T, n&gt;。 调用函数(例如 ctor)时改 array 内的元素可被编译器分解逐一传给函数。但若函数参数是个 initializer_list, 调用者却不能基于数个 T 参数然后以为他们会被自动转为一个 initializer_list 传入。 1234567void print(std::initializer_list&lt;int&gt; vals)&#123; for(auto p = vals.begin(); p != vals.end(); ++p) &#123; std::cout&lt;&lt; *p &lt;&lt;endl; &#125;&#125;print(&#123;1,2,3,4,5,6,7,8&#125;); The initializer_list object refers to the elements of this array without containing them: copy initializer_list object produces another object referring to the same underlying elements, not to new copies of them. 123456789101112131415161718vector&lt;int&gt; v1 &#123;2,5,7,13,69,83,50&#125;;vector&lt;int&gt; v2(&#123;2,5,7,13,69,83,50&#125;); // 调用接收 initializer_list 的构造函数vector&lt;int&gt; v3;v3 = &#123;2,5,7,13,69,83,50&#125;; //operator= v3.insert(v3.begin() + 2, &#123;0,1,2,3,4,5&#125;);cout&lt;&lt; max(&#123;1,2,3,4,5&#125;) &lt;&lt; endl;cout&lt;&lt; min(&#123;1,2,3,4,5&#125;) &lt;&lt; endl;template&lt;typename _Tp&gt;inline _Tp min(initializer_list&lt;_Tp&gt; __l) &#123; return *std::min_element(__l.beigin(), __l.end());&#125;template&lt;typename _Tp&gt;inline _Tp max(initializer_list&lt;_Tp&gt; __l) &#123; return *std::max_element(__l.beigin(), __l.end());&#125;"},{"title":"同步 IO 和异步 IO","permalink":"http://ywqzzy.github.io/2020/10/12/同步-IO-和异步-IO/","text":"Linux 系统中，所有的设备读写都可以看做文件的读写来操作，对文件的读写一般要经过内核态和用户态的切换， 正因为有切换才导致了 IO 有同步和异步的说法。 通常来讲 IO 可以分成两种： 来自网络的 IO 来自文件或者设备的 IO 并且完成 IO 操作可以简单的表述为两个步骤： 发起 IO 请求 执行 IO 操作 如何区分是同步 IO 还是异步 IO 呢？ “执行 IO 操作”是否阻塞 当请求被阻塞，就是同步 IO，否则就是异步 IO 同步 IO 的特点： 同步 IO 指的是用户进程触发 I/O 操作并等待或者轮询的去查看 I/O 操作是否就绪。同步 IO 的执行者是 IO 操作的发起者。同步 IO 需要发起者进行内核态到用户态的数据拷贝过程，所以这里必须由个阻塞 异步 IO 的特点： 异步 IO 是指用户进程触发 I/O 操作以后就立即返回，继续开始做自己的事情，而当 I/O 操作已经完成的时候会得到 I/O 完成的通知。异步 IO 的执行者是内核线程，内核线程将数据从内核态拷贝到用户态，所以这里没哟阻塞 如何区分是阻塞 IO 还是非阻塞 IO 呢？ 发起 IO 操作是否阻塞 如果阻塞直到完成，就是阻塞 IO，否则就是非阻塞 IO 讨论几个IO模型 阻塞 IO 模型(同步IO) 阻塞 IO 模型从发起 IO 操作到数据拷贝到用户空间，进程一直是阻塞的。 非阻塞 IO 模型(同步IO) 非阻塞 IO 模型从发起 IO 操作后就直接返回，定时轮询数据有没有准备好，后面还是需要拷贝数据到用户空间 IO 复用模型(同步 IO) IO 复用模型是发起 IO 操作前先调用 Select 或者 Poll。这两个函数都会在内核态准备好数据后告诉用户进程，相对于非阻塞 IO 模型来说，不需要轮询，用户进程可以做其他事情。但是本质上还是同步 IO但是它的优点在于可以同时触发多个 IO任务并在每个 IO 完成后依次处理。 信号驱动 IO 模型 通过 sigaction 注册信号，等内核准备好数据后内核态执行信号函数，本质还是同步 IO 异步 IO 模型采用 aio_read 让内核准备好数据并复制到用户进程空间，最后通知用户进程，这才是正真的异步 IO 参考资料 知乎"},{"title":"reactor & proactor","permalink":"http://ywqzzy.github.io/2020/10/12/reactor-proactor/","text":"标准定义两种I/O多路复用模式：Reactor 和 Proactor 一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的 read/write 事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。 两个与事件分离器有关的模式是Reactor和Proactor。Reactor 模式采用同步 IO，而 Proactor 采用异步 IO。 在 Reactor 中，事件分离器负责等待文件描述符或 socket 为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。 而在 Proactor 模式中，处理器–或者兼任处理器的事件分离器，只负责发起异步读写操作。IO 操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从 socket 读到的数据。事件分离器捕获 IO 操作完成事件，然后将事件传递给对应处理器。比如，在 windows 上，处理器发起一个异步 IO 操作，再由事件分离器等待 IOCompletion 事件。典型的异步模式实现，都建立在操作系统支持异步 API 的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。 举个例子，将有助于理解 Reactor 与 Proactor 二者的差异，以读操作为例（类操作类似）。 在 Reactor 中实现读： 注册读就绪事件和相应的事件处理器 事件分离器等待事件 事件到来，激活分离器，分离器调用事件对应的处理器。 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。 在 Proactor 中实现读： 处理器发起异步读操作（注意：操作系统必须支持异步 IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。 事件分离器等待操作完成事件 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。 事件分离器呼唤处理器。 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。 可以看出，两个模式的相同点，都是对某个 IO 事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调 handler 时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。 通俗理解使用Proactor框架和Reactor框架都可以极大的简化网络应用的开发，但它们的重点却不同。 Reactor 框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要向一个 SOCKET 写数据，那么当该S OCKET 可以接收数据的时候，你的操作就会被调用；而 Proactor 框架中用户定义的操作是在实际操作之后调用的。比如你定义了一个操作要显示从 SOCKET 中读入的数据，那么当读操作完成以后，你的操作才会被调用。 Proactor 和 Reactor 都是并发编程中的设计模式。在我看来，他们都是用于派发/分离 IO 操作事件的。这里所谓的 IO 事件也就是诸如 read/write 的 IO 操作。”派发/分离”就是将单独的 IO 事件通知到上层模块。两个模式不同的地方在于，Proactor 用于异步 IO，而 Reactor 用于同步 IO。 参考资料 知乎"},{"title":"cppcon2020 Back to basics: The structure of a Program","permalink":"http://ywqzzy.github.io/2020/10/09/cppcon2020-Back-to-basics-The-structure-of-a-Program/","text":"参考资料"},{"title":"cppcon2020 Back to basics: The Abstract Machine","permalink":"http://ywqzzy.github.io/2020/10/09/cppcon2020-Back-to-basics-The-Abstract-Machine/","text":"什么是 C++ Abstract Machine“The C++ Abstract machine is a portable abstraction of your operating system, kernel and hardware. The abstract machine is the intermediary between your c++ program and the system that it is run on.” C++ defines how programs work in terms of an abstract machine deliberately defined to be “close to the hardware”. When we write c++ code, we are writing to the c++ abstract machine. StructureMemory Objects Threads Memory A single flat space. No memory hierarchy No concept of statck, registers or cache No concept of heterogeneous memory All parts of memory are equally reachable by the am Access to memory hash uniform latency Objects Threads Summary 参考资料 cpp conference 2020 bilibili"},{"title":"在知乎上删掉的保研经历","permalink":"http://ywqzzy.github.io/2020/09/15/在知乎上删除掉的保研经验/","text":"本科是帝都211，数字媒体技术专业（偏通信专业）。从大一下开始对编程产生了浓郁的兴趣，最开始的时候是自学c语言，当时快速学完了语法，以致于学校的c语言课都没怎么听过，考试轻松过。大一暑假接触前端，当时对于编程了解尚浅，所以更喜欢可视化的东西。跟着慕课网的课程看，也算是对前端有了初步的了解。大二课业繁重，加上大一成绩也不算特别好，就开始专心学习专业课（包括数电模电信号等课），最终得到了一个还不错的绩点，但是这段时间内对于编程的学习也就断断续续了。寒假期间陪女朋友学车的时候在驾校的咖啡厅看完了整套的邓俊辉数据结构，算是入了门，但是具体的代码也没有实践过。大二下学期由于要和做大创，又对unity浅尝辄止，算是了解了点面向对象的思想。之后参加了学校ACM集训，暑假在学校呆了一个月，每天刷题（虽然都是些简单题），倒也算是把基本的数据结构熟悉了，也锻炼了编程思维。同时又学了一些机器学习，看了《机器学习基石》系列教程，还有CS231n（当然仍然浅尝辄止）。大二下本想转专业去计科，后权衡再三，没有转。大三上。身边的大佬师哥拿到了很好的offer，交谈中其实很是振奋，觉得一直自学下去其实也是可行的，故决心放弃绩点专心刷计算机基础课，期间简略看完CSAPP,看了大半部SICP，刷了算法橙书，计算机网络（自顶向下），并且坚持ACM训练，6级考了577。有幸参加了两次ACM区域赛，均打铁（不过还是不甘）。寒假决定找工作，匆忙间看了李航的《统计学习方法》，一刷了《王道数据结构》和《剑指offer》。又知道自己基础薄弱，开始看操作系统，这门课起初学起来十分吃力，前后换了很多教程和课本，最终靠孙志岗老师的教程初步了解了操作系统。期间还看了点java和javaweb，跟着教程完成了小的项目。可以说那段时间是慌乱和迷茫的，知道自己很差却只能拼了命地弥补。 大三下继续ACM训练和计算机专业课的学习，先是看了东南徐立臻老师的《数据库》教程。又在一阵慌乱中继续着算法的训练。参加过春招（内推），打击过大，遂放弃（电话面试一问三不知，一点b-树都没有），还得感谢师哥模拟面试，虽然我最后砸的不行。决意考研，和女票一起考南大软件。在正式复习考研前，参加acm邀请赛，意外拿了银牌，算是一个很大的惊喜，可能是“杨超越附体”了。考研专业课有四门（数据结构，操作系统，计算机网络和软件工程）。从5月底到9月中旬，就是充实的考研复习阶段了。期间专业课至少过了2遍，数据结构的算法题应该都刷了不止一遍，基本的题目应该是很熟悉了。南软的软件工程专业课让我收获颇丰，一是面向对象的思想，二是一个中型系统项目对自己的启发。软件工程这门课包括了uml和一些设计模式和面向对象的知识，课程设置独树一帜。 ￼ 考研复习期间还做过php和java的项目。php项目算是学了设计模式之后的一次练兵，算是自己第一次不跟着教程写项目，对于代码不断进行重构，成就感max。 然后转机来了，机缘巧合，本不该进入保研圈的我因为之前得到的奖和相对较高的绩点幸运保研，真实的幸运，感激地一塌糊涂！！ 保研名单下来的迟，准备的少，还得感谢 @邱锐 大佬给的申请经验，成功推免至北邮网研院。 #update 更新下保研的过程吧。中秋去女票家的时候收到学校推免成功的消息后才开始投简历。之前一直准备考研，心里觉得只有拿到学校推免才能完全放下考研的复习全身心准备面试。 陆续投了一堆江浙沪和南方的学校（家在南京），包括华师，同济，复旦，华东理工，南大，中科大，中南大学之类的。当时想着就是海投了。北京投了北邮之后也就没管了。从女票家回来之后第一天就去北邮面试，上午面试计算机学院，下午网研院，网研院当场收到offer（面试官：这题你是不是都做过了？我：嗯，复习考研这些题刷过了）而且他们超棒啊，直接劝我别直博，因为我数学差的要死。王道数据结构课后题我从寒假开始刷，直到面试的时候已经刷了3遍了QAQ。 后来陆续收到科大，华师，中南的面试通知（貌似都稳了），再三考虑后全鸽了，对不起对不起对不起。 可能是大学前三年压抑太久了（翘过无数必修课选修课，就为了学会自己怎么都学不会的算法）最后想让我顺一回吧。 大学三年经历过各种迷茫困顿，总觉得无法消弭和科班大佬之间的差距，一直都在追赶，也一直在本专业的课程和计算机课程之间游离。所幸两者得兼，所幸不负韶华。 ￼￼ 一定得感谢体贴的女票一直的照顾和陪伴，你最终还是支持了我的决定。虽然你我将有短暂的分别，但是相信读完研后，我们都会是更好的自己了。 具体的学习历程还有恋爱历程之后可以更。 保研到北京还是心疼女票啊啊啊啊啊啊啊啊啊啊啊。 update 女票成功上岸南大软件。%%%%tql 转眼就到毕业。 最近才稍有些毕业的感觉。 四年是日渐拥挤的书架，日均12000步的行走，零星几个肝掉的深夜，几十张车票，“北境不遗忘”，“我要成为海贼王”，“Run as one”…. 少了许多少年心事，不再说华丽辞藻含蓄故事。多了肚子、大腿上的肉，愈发坚定且直抒胸臆。 前两天采访时候，问研究生规划我并未作答。并非毫无愿景。四年的际遇奇迹满满，三年后亦未可知，不设限，任我行。希望能够各自攀峰，山顶再会 毕业后要变成一个真正的男人，要控制情绪，处理好生活与工作，爱自己，爱他人，眼里有光。 感谢不可能的和可能的。 遇见你之前，幻想高考多对一道选择题，物理大题第一题没有算错，或许人生的轨迹就会大不相同。 遇见你之后，无法形容自己有多幸运。在人生的这条马氏链上，我似乎找到了Best policy，援引The big bang theroy剧内插曲的歌词。 I couldn’t have imagined How good my life would get From the moment that I met you 过去的遗憾也不能算是遗憾了，现在拥有的就是现在了。 穿过人潮汹涌灯火阑珊， 没有想过回头。 再 update 日期2020/9/15 经过一段阵痛期，之后再寒假后陪女票找实习，npy太强了，先后拿下跟谁学，美团，字节，阿里的实习offer，实习后更加知道了追求的东西和出路。 之前的一些幼稚想法也变得成熟起来。 前路坦荡，可别走歪了。"},{"title":"词法分析","permalink":"http://ywqzzy.github.io/2019/04/27/词法分析/","text":"标识符是一个大的集合。 记号的数据结构定义123456789101112enum kind &#123;IF,LPAREN,ID,INTLIT,...&#125;struct token&#123; enum kind k; char *lexeme;// 单词&#125;；/*eg if(x&gt;5) ===&gt;&gt; token&#123;k=IF,lexeme=0&#125;;token&#123;k=LPAREN,lexeme=0&#125;；token&#123;k=ID,lexeme=\"x\"&#125;;.....*/ 词法分析器的任务，字符流到记号流。 记号流是编译器内部定义的数据结构，编码所识别出的词法单元。 词法分析—手工构造法相对复杂，容易出错。 词法分析器的生成器（自动化）：可快速原型、代码量少，但难控制细节。 转移图 1234567891011121314151617token nextToken() &#123; c = getChar(); switch(c) &#123; case '&lt;': c= getChar(); switch(c)&#123; case '=': return LE; case='&gt;':return NE; default: rollback();return LT; &#125; case '=':return EQ; case '&gt;': c= getChar(); switch(c):&#123; .....//和上面类似 &#125; &#125;&#125; 标识符的转移图： 识别关键字 也可以弄关键字构成的哈希表，先统一按照关键符的转移图进行识别，进一步查表看是否是关键字。完美哈希 正则表达式 kleene闭包。 例子：标识符c语言：以字母或下划线开头，后面跟多个或0个字母数字或下划线 （a|b|c|…..z|A|B|C|….|Z|–)(a|b|c|…..z|A|B|C|….|Z|–|0|1|…|9|)* 有限状态自动机 非确定有限状态自动机（NFA） 确定有限状态自动机（DFA) NFA难以判断字符串是否可接受。需要进行搜索。需要将NFA转化为等价的DFA。 DFA的实现带有边和节点的有向图。 边上面有信息 节点上有信息 正则表达式到NFA（Thompson算法）RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码 对基本的RE直接构造 对复合的RE递归构造 NFA转化为DFA（子集构造法） 不动点算法：why能终止？ DFA最小化Hopcroft算法 什么叫做能切分？ 首先切分成非终结符和终结符两类 DFA的代码表示转移表 哈希表 跳转表 转移表：还要有词法分析驱动代码。 ​ 最长匹配思想。 跳转表: 跳转表不需要维护一个大的转移数组。"}]}