{"pages":[{"title":"About","permalink":"http://ywqzzy.github.io/about/index.html","text":""},{"title":"Categories","permalink":"http://ywqzzy.github.io/categories/index.html","text":""},{"title":"Tags","permalink":"http://ywqzzy.github.io/tags/index.html","text":""}],"posts":[{"title":"yfs-源码剖析（2）--基本文件服务","permalink":"http://ywqzzy.github.io/2020/10/27/yfs-源码剖析（2）-基本文件服务/","text":"参考资料"},{"title":"yfs-源码剖析（1）--锁服务","permalink":"http://ywqzzy.github.io/2020/10/27/yfs-源码剖析（1）-锁服务/","text":"介绍yfs 需要一个锁服务来协调文件系统结构的更新。 其中包括两个模块，分别是锁客户端和锁服务器。 他们之间的 RPC 交互流程如下： 客户端发送请求从锁服务器请求锁。 锁服务器在一个时间点只能向一个客户端发送锁。 客户端不需要锁的时候，会向服务器发送释放请求。 释放锁后，服务端会把锁给其他正在请求的客户端。 lock_protocol.hlock123456789101112131415161718class lock &#123;public: enum lock_status &#123;FREE, LOCKED&#125;; // 用这个来标识每个锁 lock_protocol::lockid_t m_lid; // FREE or LOCKED int m_state; // 条件变量 std::condition_variable m_cv; // 构造函数 lock(lock_protocol::lockid_t lid, int state);&#125;;lock::lock(lock_protocol::lockid_t lid, int state) : m_lid(lid), m_state(state)&#123;&#125; lock_protocol1234567891011class lock_protocol &#123; public: enum xxstatus &#123; OK, RETRY, RPCERR, NOENT, IOERR &#125;; typedef int status; typedef unsigned long long lockid_t; enum rpc_numbers &#123; acquire = 0x7001, release, stat &#125;;&#125;; lock_client12345678910class lock_client &#123; protected: rpcc *cl; public: lock_client(std::string d); virtual ~lock_client() &#123;&#125;; virtual lock_protocol::status acquire(lock_protocol::lockid_t); // 获得锁的接口 virtual lock_protocol::status release(lock_protocol::lockid_t); // 释放锁的接口 virtual lock_protocol::status stat(lock_protocol::lockid_t); // 获得 status 的接口&#125;; 通过 lock_client 类发送 RPC 至 lock_server, 以获取来自 lock_server 的响应。 lock_client 的实现如下： 123456789101112131415161718192021222324252627282930313233343536lock_client::lock_client(std::string dst) // rpc 绑定至 dst &#123; sockaddr_in dstsock; make_sockaddr(dst.c_str(), &amp;dstsock); // rpc.h 里的辅助函数 cl = new rpcc(dstsock); if (cl-&gt;bind() &lt; 0) &#123; printf(\"lock_client: call bind\\n\"); &#125;&#125;intlock_client::stat(lock_protocol::lockid_t lid)&#123; int r; int ret = cl-&gt;call(lock_protocol::stat, cl-&gt;id(), lid, r); VERIFY (ret == lock_protocol::OK); return r;&#125;lock_protocol::statuslock_client::acquire(lock_protocol::lockid_t lid)&#123; int r; int ret = cl-&gt;call(lock_protocol::acquire, cl-&gt;id(), lid, r); VERIFY (ret == lock_protocol::OK); return r;&#125;lock_protocol::statuslock_client::release(lock_protocol::lockid_t lid)&#123; int r; int ret = cl-&gt;call(lock_protocol::release, cl-&gt;id(), lid, r); VERIFY (ret == lock_protocol::OK); return r;&#125; client 端都是些套路代码，主要实现都来自于 server 端的函数。 lock_server1234567891011121314151617181920212223242526#ifndef lock_server_h#define lock_server_h#include &lt;string&gt;#include &lt;map&gt;#include &lt;mutex&gt;#include \"lock_protocol.h\"#include \"lock_client.h\"#include \"rpc.h\"#include &lt;memory&gt;class lock_server &#123; protected: int nacquire; std::mutex m_mutex; std::map&lt;lock_protocol::lockid_t, lock*&gt; m_lockMap; public: lock_server(); ~lock_server() &#123;&#125;; lock_protocol::status stat(int clt, lock_protocol::lockid_t lid, int &amp;); lock_protocol::status acquire(int clt, lock_protocol::lockid_t lid, int &amp;); lock_protocol::status release(int clt, lock_protocol::lockid_t lid, int &amp;);&#125;;#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include \"lock_server.h\"#include &lt;sstream&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;// 上面 lock 的构造函数lock::lock(lock_protocol::lockid_t lid, int state) : m_lid(lid), m_state(state)&#123;&#125;// lock_server 的构造函数lock_server::lock_server(): nacquire (0)&#123;&#125;lock_protocol::statuslock_server::stat(int clt, lock_protocol::lockid_t lid, int &amp;r)&#123; lock_protocol::status ret = lock_protocol::OK; printf(\"stat request from clt %d\\n\", clt); r = nacquire; return ret;&#125;lock_protocol::statuslock_server::acquire(int clt, lock_protocol::lockid_t lid, int &amp;r)&#123; lock_protocol::status ret = lock_protocol::OK; // 初始化返回值 std::unique_lock&lt;std::mutex&gt; lck(m_mutex); auto iter = m_lockMap.find(lid); if (iter != m_lockMap.end()) &#123; while(iter-&gt;second-&gt;m_state != lock::FREE) &#123; iter-&gt;second-&gt;m_cv.wait(lck); // 在条件变量上 wait &#125; iter-&gt;second-&gt;m_state = lock::LOCKED; // 获得 lock &#125; else &#123; // 没找到就新建一个锁 auto p_mutex = new lock(lid, lock::LOCKED); m_lockMap.insert(std::pair&lt;lock_protocol::lockid_t, lock*&gt;(lid, p_mutex)); &#125; return ret;&#125;lock_protocol::statuslock_server::release(int clt, lock_protocol::lockid_t lid, int &amp;r)&#123; lock_protocol::status ret = lock_protocol::OK; std::unique_lock&lt;std::mutex&gt; lck(m_mutex); auto iter = m_lockMap.find(lid); if (iter != m_lockMap.end()) &#123; iter-&gt;second-&gt;m_state = lock::FREE; iter-&gt;second-&gt;m_cv.notify_all(); // 条件变量 notify_all 这样 wai t的会被唤醒 &#125; else &#123; ret = lock_protocol::IOERR; &#125; m_mutex.unlock(); return ret;&#125; 参考资料 yfs实现第一步——锁服务 yfsCpp11"},{"title":"muduo GzipFile","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-GzipFile/","text":"对 zlib 进行了简单封装，主要欣赏代码风格和规范。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#pragma once#include \"muduo/base/StringPiece.h\"#include \"muduo/base/noncopyable.h\"#include &lt;zlib.h&gt;namespace muduo&#123;class GzipFile : noncopyable&#123; public: GzipFile(GzipFile&amp;&amp; rhs) noexcept // move : file_(rhs.file_) &#123; rhs.file_ = NULL; &#125; ~GzipFile() &#123; if (file_) &#123; ::gzclose(file_); &#125; &#125; GzipFile&amp; operator=(GzipFile&amp;&amp; rhs) noexcept &#123; swap(rhs); return *this; &#125; bool valid() const &#123; return file_ != NULL; &#125; void swap(GzipFile&amp; rhs) &#123; std::swap(file_, rhs.file_); &#125;#if ZLIB_VERNUM &gt;= 0x1240 bool setBuffer(int size) &#123; return ::gzbuffer(file_, size) == 0; &#125;#endif // return the number of uncompressed bytes actually read, 0 for eof, -1 for error int read(void* buf, int len) &#123; return ::gzread(file_, buf, len); &#125; // return the number of uncompressed bytes actually written int write(StringPiece buf) &#123; return ::gzwrite(file_, buf.data(), buf.size()); &#125; // number of uncompressed bytes off_t tell() const &#123; return ::gztell(file_); &#125;#if ZLIB_VERNUM &gt;= 0x1240 // number of compressed bytes off_t offset() const &#123; return ::gzoffset(file_); &#125;#endif // int flush(int f) &#123; return ::gzflush(file_, f); &#125; static GzipFile openForRead(StringArg filename) &#123; return GzipFile(::gzopen(filename.c_str(), \"rbe\")); &#125; static GzipFile openForAppend(StringArg filename) &#123; return GzipFile(::gzopen(filename.c_str(), \"abe\")); &#125; static GzipFile openForWriteExclusive(StringArg filename) &#123; return GzipFile(::gzopen(filename.c_str(), \"wbxe\")); &#125; static GzipFile openForWriteTruncate(StringArg filename) &#123; return GzipFile(::gzopen(filename.c_str(), \"wbe\")); &#125; private: explicit GzipFile(gzFile file) : file_(file) &#123; &#125; gzFile file_;&#125;;&#125; // namespace muduo 参考资料 GzipFile"},{"title":"muduo ProcessInfo","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-ProcessInfo/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#ifndef MUDUO_BASE_PROCESSINFO_H#define MUDUO_BASE_PROCESSINFO_H#include \"muduo/base/StringPiece.h\"#include \"muduo/base/Types.h\"#include \"muduo/base/Timestamp.h\"#include &lt;vector&gt;#include &lt;sys/types.h&gt;namespace muduo&#123;namespace ProcessInfo&#123; pid_t pid(); // 进程 pid string pidString(); // pid字符串 uid_t uid(); // userid string username(); // uid字符串 uid_t euid(); // 有效用户id Timestamp startTime(); // 进程开始时间 int clockTicksPerSecond(); // 时钟频率 int pageSize(); // 内存页大小 // 是否以调试模式构建 bool isDebugBuild(); // constexpr // 主机名 string hostname(); // 进程名 string procname(); StringPiece procname(const string&amp; stat); /// read /proc/self/status string procStatus(); /// read /proc/self/stat string procStat(); /// read /proc/self/task/tid/stat string threadStat(); /// readlink /proc/self/exe string exePath(); int openedFiles(); int maxOpenFiles(); struct CpuTime &#123; double userSeconds; double systemSeconds; CpuTime() : userSeconds(0.0), systemSeconds(0.0) &#123; &#125; double total() const &#123; return userSeconds + systemSeconds; &#125; &#125;; CpuTime cpuTime(); int numThreads(); std::vector&lt;pid_t&gt; threads();&#125; // namespace ProcessInfo&#125; // namespace muduo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254// Use of this source code is governed by a BSD-style license// that can be found in the License file.//// Author: Shuo Chen (chenshuo at chenshuo dot com)#include \"muduo/base/ProcessInfo.h\"#include \"muduo/base/CurrentThread.h\"#include \"muduo/base/FileUtil.h\"#include &lt;algorithm&gt;#include &lt;assert.h&gt;#include &lt;dirent.h&gt;#include &lt;pwd.h&gt;#include &lt;stdio.h&gt; // snprintf#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/times.h&gt;namespace muduo&#123;namespace detail&#123; // threadlocal__thread int t_numOpenedFiles = 0;int fdDirFilter(const struct dirent* d)&#123; if (::isdigit(d-&gt;d_name[0])) &#123; ++t_numOpenedFiles; &#125; return 0;&#125;__thread std::vector&lt;pid_t&gt;* t_pids = NULL; // 线程id列表int taskDirFilter(const struct dirent* d)&#123; if (::isdigit(d-&gt;d_name[0])) &#123; t_pids-&gt;push_back(atoi(d-&gt;d_name)); &#125; return 0;&#125;int scanDir(const char *dirpath, int (*filter)(const struct dirent *))&#123; struct dirent** namelist = NULL; int result = ::scandir(dirpath, &amp;namelist, filter, alphasort); // alphasort 用来排序 assert(namelist == NULL); return result;&#125;Timestamp g_startTime = Timestamp::now();// assume those won't change during the life time of a process.int g_clockTicks = static_cast&lt;int&gt;(::sysconf(_SC_CLK_TCK));int g_pageSize = static_cast&lt;int&gt;(::sysconf(_SC_PAGE_SIZE));&#125; // namespace detail&#125; // namespace muduousing namespace muduo;using namespace muduo::detail;pid_t ProcessInfo::pid()&#123; return ::getpid();&#125;string ProcessInfo::pidString()&#123; char buf[32]; snprintf(buf, sizeof buf, \"%d\", pid()); return buf;&#125;uid_t ProcessInfo::uid()&#123; return ::getuid();&#125;string ProcessInfo::username()&#123; struct passwd pwd; struct passwd* result = NULL; char buf[8192]; const char* name = \"unknownuser\"; getpwuid_r(uid(), &amp;pwd, buf, sizeof buf, &amp;result); // 从密码文件中获取记录 if (result) &#123; name = pwd.pw_name; &#125; return name;&#125;uid_t ProcessInfo::euid()&#123; return ::geteuid();&#125;Timestamp ProcessInfo::startTime()&#123; return g_startTime;&#125;int ProcessInfo::clockTicksPerSecond()&#123; return g_clockTicks;&#125;int ProcessInfo::pageSize()&#123; return g_pageSize;&#125;bool ProcessInfo::isDebugBuild()&#123;#ifdef NDEBUG return false;#else return true;#endif&#125;string ProcessInfo::hostname()&#123; // HOST_NAME_MAX 64 // _POSIX_HOST_NAME_MAX 255 char buf[256]; if (::gethostname(buf, sizeof buf) == 0) &#123; buf[sizeof(buf)-1] = '\\0'; return buf; &#125; else &#123; return \"unknownhost\"; &#125;&#125;string ProcessInfo::procname()&#123; return procname(procStat()).as_string();&#125;StringPiece ProcessInfo::procname(const string&amp; stat)&#123; StringPiece name; size_t lp = stat.find('('); size_t rp = stat.rfind(')'); if (lp != string::npos &amp;&amp; rp != string::npos &amp;&amp; lp &lt; rp) &#123; name.set(stat.data()+lp+1, static_cast&lt;int&gt;(rp-lp-1)); &#125; return name;&#125;string ProcessInfo::procStatus()&#123; string result; FileUtil::readFile(\"/proc/self/status\", 65536, &amp;result); return result;&#125;string ProcessInfo::procStat()&#123; string result; FileUtil::readFile(\"/proc/self/stat\", 65536, &amp;result); return result;&#125;string ProcessInfo::threadStat()&#123; char buf[64]; snprintf(buf, sizeof buf, \"/proc/self/task/%d/stat\", CurrentThread::tid()); string result; FileUtil::readFile(buf, 65536, &amp;result); return result;&#125;string ProcessInfo::exePath()&#123; string result; char buf[1024]; ssize_t n = ::readlink(\"/proc/self/exe\", buf, sizeof buf); if (n &gt; 0) &#123; result.assign(buf, n); &#125; return result;&#125;int ProcessInfo::openedFiles()&#123; t_numOpenedFiles = 0; scanDir(\"/proc/self/fd\", fdDirFilter); return t_numOpenedFiles;&#125;/* struct rlimit &#123; rlim_t rlim_cur; // 软上限 rlim_t rlim_max; // 硬上限&#125;; */int ProcessInfo::maxOpenFiles()&#123; struct rlimit rl; if (::getrlimit(RLIMIT_NOFILE, &amp;rl)) &#123; return openedFiles(); &#125; else &#123; return static_cast&lt;int&gt;(rl.rlim_cur); &#125;&#125;ProcessInfo::CpuTime ProcessInfo::cpuTime()&#123; ProcessInfo::CpuTime t; struct tms tms; if (::times(&amp;tms) &gt;= 0) &#123; const double hz = static_cast&lt;double&gt;(clockTicksPerSecond()); t.userSeconds = static_cast&lt;double&gt;(tms.tms_utime) / hz; t.systemSeconds = static_cast&lt;double&gt;(tms.tms_stime) / hz; &#125; return t;&#125;int ProcessInfo::numThreads()&#123; int result = 0; string status = procStatus(); size_t pos = status.find(\"Threads:\"); if (pos != string::npos) &#123; result = ::atoi(status.c_str() + pos + 8); &#125; return result;&#125;std::vector&lt;pid_t&gt; ProcessInfo::threads()&#123; std::vector&lt;pid_t&gt; result; t_pids = &amp;result; scanDir(\"/proc/self/task\", taskDirFilter); t_pids = NULL; std::sort(result.begin(), result.end()); return result;&#125; 参考资料 ProcessInfo"},{"title":"muduo atomic","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-atomic/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#ifndef MUDUO_BASE_ATOMIC_H#define MUDUO_BASE_ATOMIC_H#include \"muduo/base/noncopyable.h\"#include &lt;stdint.h&gt;namespace muduo&#123;namespace detail&#123;template&lt;typename T&gt;class AtomicIntegerT : noncopyable&#123; public: AtomicIntegerT() : value_(0) &#123; &#125; // uncomment if you need copying and assignment // // AtomicIntegerT(const AtomicIntegerT&amp; that) // : value_(that.get()) // &#123;&#125; // // AtomicIntegerT&amp; operator=(const AtomicIntegerT&amp; that) // &#123; // getAndSet(that.get()); // return *this; // &#125; T get() &#123; // in gcc &gt;= 4.7: __atomic_load_n(&amp;value_, __ATOMIC_SEQ_CST) // 实现原子操作 return __sync_val_compare_and_swap(&amp;value_, 0, 0); &#125; T getAndAdd(T x) &#123; // in gcc &gt;= 4.7: __atomic_fetch_add(&amp;value_, x, __ATOMIC_SEQ_CST) return __sync_fetch_and_add(&amp;value_, x); &#125; T addAndGet(T x) &#123; return getAndAdd(x) + x; &#125; T incrementAndGet() &#123; return addAndGet(1); &#125; T decrementAndGet() &#123; return addAndGet(-1); &#125; void add(T x) &#123; getAndAdd(x); &#125; void increment() &#123; incrementAndGet(); &#125; void decrement() &#123; decrementAndGet(); &#125; T getAndSet(T newValue) &#123; // in gcc &gt;= 4.7: __atomic_exchange_n(&amp;value_, newValue, __ATOMIC_SEQ_CST) // 实现原子操作 return __sync_lock_test_and_set(&amp;value_, newValue); &#125; private: volatile T value_; // 直接在内存占用进行存取&#125;;&#125; // namespace detailtypedef detail::AtomicIntegerT&lt;int32_t&gt; AtomicInt32;typedef detail::AtomicIntegerT&lt;int64_t&gt; AtomicInt64;&#125; // namespace muduo#endif // MUDUO_BASE_ATOMIC_H 参考资料 Atomic muduo源码解析2-AtomicIntegerT类"},{"title":"muduo date","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-date/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#ifndef MUDUO_BASE_DATE_H#define MUDUO_BASE_DATE_H#include \"muduo/base/copyable.h\"#include \"muduo/base/Types.h\"struct tm;namespace muduo&#123;////// Date in Gregorian calendar.////// This class is immutable./// It's recommended to pass it by value, since it's passed in register on x64.///class Date : public muduo::copyable // public boost::less_than_comparable&lt;Date&gt;, // public boost::equality_comparable&lt;Date&gt;&#123; public: struct YearMonthDay &#123; int year; // [1900..2500] int month; // [1..12] int day; // [1..31] &#125;; static const int kDaysPerWeek = 7; static const int kJulianDayOf1970_01_01; /// /// Constucts an invalid Date. /// Date() : julianDayNumber_(0) &#123;&#125; /// /// Constucts a yyyy-mm-dd Date. /// /// 1 &lt;= month &lt;= 12 Date(int year, int month, int day); /// /// Constucts a Date from Julian Day Number. /// explicit Date(int julianDayNum) : julianDayNumber_(julianDayNum) &#123;&#125; /// /// Constucts a Date from struct tm /// explicit Date(const struct tm&amp;); // default copy/assignment/dtor are Okay void swap(Date&amp; that) &#123; std::swap(julianDayNumber_, that.julianDayNumber_); &#125; bool valid() const &#123; return julianDayNumber_ &gt; 0; &#125; /// /// Converts to yyyy-mm-dd format. /// string toIsoString() const; struct YearMonthDay yearMonthDay() const; int year() const &#123; return yearMonthDay().year; &#125; int month() const &#123; return yearMonthDay().month; &#125; int day() const &#123; return yearMonthDay().day; &#125; // [0, 1, ..., 6] =&gt; [Sunday, Monday, ..., Saturday ] int weekDay() const &#123; return (julianDayNumber_+1) % kDaysPerWeek; &#125; int julianDayNumber() const &#123; return julianDayNumber_; &#125; private: int julianDayNumber_;&#125;;inline bool operator&lt;(Date x, Date y)&#123; return x.julianDayNumber() &lt; y.julianDayNumber();&#125;inline bool operator==(Date x, Date y)&#123; return x.julianDayNumber() == y.julianDayNumber();&#125;&#125; // namespace muduo#endif // MUDUO_BASE_DATE_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566namespace muduo&#123;namespace detail&#123;char require_32_bit_integer_at_least[sizeof(int) &gt;= sizeof(int32_t) ? 1 : -1];// algorithm and explanation see:// http://www.faqs.org/faqs/calendars/faq/part2/// http://blog.csdn.net/Solsticeint getJulianDayNumber(int year, int month, int day)&#123; (void) require_32_bit_integer_at_least; // no warning please int a = (14 - month) / 12; int y = year + 4800 - a; int m = month + 12 * a - 3; return day + (153*m + 2) / 5 + y*365 + y/4 - y/100 + y/400 - 32045;&#125;struct Date::YearMonthDay getYearMonthDay(int julianDayNumber)&#123; int a = julianDayNumber + 32044; int b = (4 * a + 3) / 146097; int c = a - ((b * 146097) / 4); int d = (4 * c + 3) / 1461; int e = c - ((1461 * d) / 4); int m = (5 * e + 2) / 153; Date::YearMonthDay ymd; ymd.day = e - ((153 * m + 2) / 5) + 1; ymd.month = m + 3 - 12 * (m / 10); ymd.year = b * 100 + d - 4800 + (m / 10); return ymd;&#125;&#125; // namespace detailconst int Date::kJulianDayOf1970_01_01 = detail::getJulianDayNumber(1970, 1, 1);&#125; // namespace muduousing namespace muduo;using namespace muduo::detail;Date::Date(int y, int m, int d) : julianDayNumber_(getJulianDayNumber(y, m, d))&#123;&#125;Date::Date(const struct tm&amp; t) : julianDayNumber_(getJulianDayNumber( t.tm_year+1900, t.tm_mon+1, t.tm_mday))&#123;&#125;string Date::toIsoString() const&#123; char buf[32]; YearMonthDay ymd(yearMonthDay()); snprintf(buf, sizeof buf, \"%4d-%02d-%02d\", ymd.year, ymd.month, ymd.day); return buf;&#125;Date::YearMonthDay Date::yearMonthDay() const&#123; return getYearMonthDay(julianDayNumber_);&#125; 参考资料 date"},{"title":"muduo FileUtil","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-FileUtil/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#ifndef MUDUO_BASE_FILEUTIL_H#define MUDUO_BASE_FILEUTIL_H#include \"muduo/base/noncopyable.h\"#include \"muduo/base/StringPiece.h\"#include &lt;sys/types.h&gt; // for off_tnamespace muduo&#123;namespace FileUtil&#123;// read small file &lt; 64KBclass ReadSmallFile : noncopyable&#123; public: ReadSmallFile(StringArg filename); ~ReadSmallFile(); // return errno template&lt;typename String&gt; int readToString(int maxSize, String* content, int64_t* fileSize, int64_t* modifyTime, int64_t* createTime); /// Read at maxium kBufferSize into buf_ // return errno int readToBuffer(int* size); const char* buffer() const &#123; return buf_; &#125; static const int kBufferSize = 64*1024; private: int fd_; int err_; char buf_[kBufferSize];&#125;;// read the file content, returns errno if error happens.template&lt;typename String&gt;int readFile(StringArg filename, int maxSize, String* content, int64_t* fileSize = NULL, int64_t* modifyTime = NULL, int64_t* createTime = NULL)&#123; ReadSmallFile file(filename); return file.readToString(maxSize, content, fileSize, modifyTime, createTime);&#125;// not thread safeclass AppendFile : noncopyable&#123; public: explicit AppendFile(StringArg filename); ~AppendFile(); void append(const char* logline, size_t len); void flush(); off_t writtenBytes() const &#123; return writtenBytes_; &#125; private: size_t write(const char* logline, size_t len); FILE* fp_; char buffer_[64*1024]; off_t writtenBytes_;&#125;;&#125; // namespace FileUtil&#125; // namespace muduo#endif // MUDUO_BASE_FILEUTIL_H AppendFile12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152FileUtil::AppendFile::AppendFile(StringArg filename) : fp_(::fopen(filename.c_str(), \"ae\")), // 'e' for O_CLOEXEC 'a' 表示追加 writtenBytes_(0)&#123; assert(fp_); ::setbuffer(fp_, buffer_, sizeof buffer_); // posix_fadvise POSIX_FADV_DONTNEED ?&#125;FileUtil::AppendFile::~AppendFile()&#123; ::fclose(fp_);&#125;void FileUtil::AppendFile::append(const char* logline, const size_t len)&#123; // 写入文件 size_t n = write(logline, len); size_t remain = len - n; while (remain &gt; 0) &#123; size_t x = write(logline + n, remain); // 写入失败 if (x == 0) &#123; int err = ferror(fp_); if (err) &#123; fprintf(stderr, \"AppendFile::append() failed %s\\n\", strerror_tl(err)); &#125; break; &#125; // 继续写入 n += x; remain = len - n; // remain -= x &#125; // 更新已经写入的总字节数 writtenBytes_ += len;&#125;// 刷新文件流void FileUtil::AppendFile::flush()&#123; ::fflush(fp_);&#125;size_t FileUtil::AppendFile::write(const char* logline, size_t len)&#123; // #undef fwrite_unlocked // 写文件的不加锁版本，线程不安全 return ::fwrite_unlocked(logline, 1, len, fp_);&#125; ReadSmallFile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125FileUtil::ReadSmallFile::ReadSmallFile(StringArg filename) : fd_(::open(filename.c_str(), O_RDONLY | O_CLOEXEC)), // 只读 打开文件并记录文件描述符 err_(0)&#123; // 清空缓冲区 buf_[0] = '\\0'; if (fd_ &lt; 0) &#123; err_ = errno; &#125;&#125;FileUtil::ReadSmallFile::~ReadSmallFile()&#123; if (fd_ &gt;= 0) &#123; ::close(fd_); // FIXME: check EINTR &#125;&#125;// return errnotemplate&lt;typename String&gt;int FileUtil::ReadSmallFile::readToString(int maxSize, String* content, int64_t* fileSize, int64_t* modifyTime, int64_t* createTime)&#123; // 判断是否占 8 位 static_assert(sizeof(off_t) == 8, \"_FILE_OFFSET_BITS = 64\"); assert(content != NULL); int err = err_; if (fd_ &gt;= 0) &#123; content-&gt;clear(); if (fileSize) &#123; // 获取文件信息 struct stat statbuf; if (::fstat(fd_, &amp;statbuf) == 0) &#123; // 是否是常规文件 if (S_ISREG(statbuf.st_mode)) &#123; // 获得文件大小 *fileSize = statbuf.st_size; // 申请空间 content-&gt;reserve(static_cast&lt;int&gt;(std::min(implicit_cast&lt;int64_t&gt;(maxSize), *fileSize))); &#125; else if (S_ISDIR(statbuf.st_mode)) // 是目录 &#123; err = EISDIR; &#125; if (modifyTime) // 更新时间 &#123; *modifyTime = statbuf.st_mtime; &#125; if (createTime) // 创建时间 &#123; *createTime = statbuf.st_ctime; &#125; &#125; else &#123; err = errno; &#125; &#125; while (content-&gt;size() &lt; implicit_cast&lt;size_t&gt;(maxSize)) &#123; // 要读的字节数 size_t toRead = std::min(implicit_cast&lt;size_t&gt;(maxSize) - content-&gt;size(), sizeof(buf_)); ssize_t n = ::read(fd_, buf_, toRead); if (n &gt; 0) &#123; content-&gt;append(buf_, n); &#125; else &#123; if (n &lt; 0) &#123; err = errno; &#125; break; &#125; &#125; &#125; return err;&#125;// 将文件内容读入缓冲区, 将文件大小赋值给 sizeint FileUtil::ReadSmallFile::readToBuffer(int* size)&#123; int err = err_; if (fd_ &gt;= 0) &#123; //pread() reads up to count bytes from file descriptor fd at offset offset (from the start of the //file) into the buffer starting at buf. The file offset is not changed. ssize_t n = ::pread(fd_, buf_, sizeof(buf_)-1, 0); if (n &gt;= 0) &#123; if (size) &#123; *size = static_cast&lt;int&gt;(n); &#125; buf_[n] = '\\0'; &#125; else &#123; err = errno; &#125; &#125; return err;&#125;template int FileUtil::readFile(StringArg filename, int maxSize, string* content, int64_t*, int64_t*, int64_t*);template int FileUtil::ReadSmallFile::readToString( int maxSize, string* content, int64_t*, int64_t*, int64_t*); 参考资料 FileUtil"},{"title":"muduo CurrentThread","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-CurrentThread/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef MUDUO_BASE_CURRENTTHREAD_H#define MUDUO_BASE_CURRENTTHREAD_H#include \"muduo/base/Types.h\"namespace muduo&#123;namespace CurrentThread&#123; // internal // 使用 __thread 修饰变量 使得每一个线程都有一份独立实体，各个线程的值互不干扰 extern __thread int t_cachedTid; // 当前线程id extern __thread char t_tidString[32]; // 当前线程id extern __thread int t_tidStringLength; // char 的大小 extern __thread const char* t_threadName; // 线程名字 void cacheTid(); inline int tid() &#123; if (__builtin_expect(t_cachedTid == 0, 0)) &#123; cacheTid(); &#125; return t_cachedTid; &#125; inline const char* tidString() // for logging &#123; return t_tidString; &#125; inline int tidStringLength() // for logging &#123; return t_tidStringLength; &#125; inline const char* name() &#123; return t_threadName; &#125; bool isMainThread(); void sleepUsec(int64_t usec); // for testing string stackTrace(bool demangle);&#125; // namespace CurrentThread&#125; // namespace muduo#endif // MUDUO_BASE_CURRENTTHREAD_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566namespace muduo&#123;namespace CurrentThread&#123;__thread int t_cachedTid = 0;__thread char t_tidString[32];__thread int t_tidStringLength = 6;__thread const char* t_threadName = \"unknown\";static_assert(std::is_same&lt;int, pid_t&gt;::value, \"pid_t should be int\");string stackTrace(bool demangle)&#123; string stack; const int max_frames = 200; void* frame[max_frames]; int nptrs = ::backtrace(frame, max_frames); char** strings = ::backtrace_symbols(frame, nptrs); if (strings) &#123; size_t len = 256; char* demangled = demangle ? static_cast&lt;char*&gt;(::malloc(len)) : nullptr; for (int i = 1; i &lt; nptrs; ++i) // skipping the 0-th, which is this function &#123; if (demangle) &#123; // https://panthema.net/2008/0901-stacktrace-demangled/ // bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909] char* left_par = nullptr; char* plus = nullptr; for (char* p = strings[i]; *p; ++p) &#123; if (*p == '(') left_par = p; else if (*p == '+') plus = p; &#125; if (left_par &amp;&amp; plus) &#123; *plus = '\\0'; int status = 0; char* ret = abi::__cxa_demangle(left_par+1, demangled, &amp;len, &amp;status); *plus = '+'; if (status == 0) &#123; demangled = ret; // ret could be realloc() stack.append(strings[i], left_par+1); stack.append(demangled); stack.append(plus); stack.push_back('\\n'); continue; &#125; &#125; &#125; // Fallback to mangled names stack.append(strings[i]); stack.push_back('\\n'); &#125; free(demangled); free(strings); &#125; return stack;&#125;&#125; // namespace CurrentThread&#125; // namespace muduo 参考资料 currentThread"},{"title":"muduo exception","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-exception/","text":"1234567891011121314151617181920212223242526272829303132333435#ifndef MUDUO_BASE_EXCEPTION_H#define MUDUO_BASE_EXCEPTION_H#include \"muduo/base/Types.h\"#include &lt;exception&gt;namespace muduo&#123;class Exception : public std::exception&#123; public: Exception(string what); ~Exception() noexcept override = default; // default copy-ctor and operator= are okay. const char* what() const noexcept override &#123; return message_.c_str(); &#125; const char* stackTrace() const noexcept &#123; return stack_.c_str(); &#125; private: string message_; string stack_;&#125;;&#125; // namespace muduo#endif // MUDUO_BASE_EXCEPTION_H 12345678910111213#include \"muduo/base/Exception.h\"#include \"muduo/base/CurrentThread.h\"namespace muduo&#123;Exception::Exception(string msg) : message_(std::move(msg)), stack_(CurrentThread::stackTrace(/*demangle=*/false))&#123;&#125;&#125; // namespace muduo 参考资料 exception"},{"title":"muduo Timestamp ","permalink":"http://ywqzzy.github.io/2020/10/27/muduo-Timestamp/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class Timestamp : public muduo::copyable, public boost::equality_comparable&lt;Timestamp&gt;, public boost::less_than_comparable&lt;Timestamp&gt;&#123; public: /// /// Constucts an invalid Timestamp. /// Timestamp() : microSecondsSinceEpoch_(0) &#123; &#125; /// /// Constucts a Timestamp at specific time /// /// @param microSecondsSinceEpoch explicit Timestamp(int64_t microSecondsSinceEpochArg) : microSecondsSinceEpoch_(microSecondsSinceEpochArg) &#123; &#125; void swap(Timestamp&amp; that) &#123; std::swap(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_); &#125; // default copy/assignment/dtor are Okay string toString() const; string toFormattedString(bool showMicroseconds = true) const; bool valid() const &#123; return microSecondsSinceEpoch_ &gt; 0; &#125; // for internal usage. int64_t microSecondsSinceEpoch() const &#123; return microSecondsSinceEpoch_; &#125; time_t secondsSinceEpoch() const &#123; return static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); &#125; /// /// Get time of now. /// static Timestamp now(); static Timestamp invalid() &#123; return Timestamp(); &#125; static Timestamp fromUnixTime(time_t t) &#123; return fromUnixTime(t, 0); &#125; static Timestamp fromUnixTime(time_t t, int microseconds) &#123; return Timestamp(static_cast&lt;int64_t&gt;(t) * kMicroSecondsPerSecond + microseconds); &#125; static const int kMicroSecondsPerSecond = 1000 * 1000; private: int64_t microSecondsSinceEpoch_;&#125;;inline bool operator&lt;(Timestamp lhs, Timestamp rhs)&#123; return lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();&#125;inline bool operator==(Timestamp lhs, Timestamp rhs)&#123; return lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();&#125;////// Gets time difference of two timestamps, result in seconds.////// @param high, low/// @return (high-low) in seconds/// @c double has 52-bit precision, enough for one-microsecond/// resolution for next 100 years.inline double timeDifference(Timestamp high, Timestamp low)&#123; int64_t diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch(); return static_cast&lt;double&gt;(diff) / Timestamp::kMicroSecondsPerSecond;&#125;////// Add @c seconds to given timestamp.////// @return timestamp+seconds as Timestamp///inline Timestamp addTime(Timestamp timestamp, double seconds)&#123; int64_t delta = static_cast&lt;int64_t&gt;(seconds * Timestamp::kMicroSecondsPerSecond); return Timestamp(timestamp.microSecondsSinceEpoch() + delta);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940string Timestamp::toString() const&#123; char buf[32] = &#123;0&#125;; int64_t seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond; int64_t microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond; snprintf(buf, sizeof(buf), \"%\" PRId64 \".%06\" PRId64 \"\", seconds, microseconds); return buf;&#125;string Timestamp::toFormattedString(bool showMicroseconds) const&#123; char buf[64] = &#123;0&#125;; time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); struct tm tm_time; gmtime_r(&amp;seconds, &amp;tm_time); if (showMicroseconds) &#123; int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond); snprintf(buf, sizeof(buf), \"%4d%02d%02d %02d:%02d:%02d.%06d\", tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec, microseconds); &#125; else &#123; snprintf(buf, sizeof(buf), \"%4d%02d%02d %02d:%02d:%02d\", tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec); &#125; return buf;&#125;Timestamp Timestamp::now()&#123; struct timeval tv; gettimeofday(&amp;tv, NULL); int64_t seconds = tv.tv_sec; return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);&#125; 参考资料 timestamp"},{"title":"leetcode148排序链表","permalink":"http://ywqzzy.github.io/2020/10/23/leetcode148排序链表/","text":"在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 不能用递归法来解，所以按照链表长度从 1 到 len，倍增进行合并。需要依次合并长度为 1，2，4…..len的链表。 主要需要将链表分割成一个个长度为 size 的小段，并且将长度为 size 的小段进行合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: // cut n个节点，然后返回剩下的链表的头节点 ListNode* cut(ListNode* head, int n) &#123; ListNode* node = head; while(--n &amp;&amp; node) node = node-&gt;next; if(node == NULL) return NULL; ListNode* next = node-&gt;next; node-&gt;next = NULL; return next; &#125; ListNode* merge(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(0); ListNode* node = dummy; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val &lt; l2-&gt; val) &#123; node-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; node-&gt;next = l2; l2 = l2-&gt;next; &#125; node = node-&gt;next; &#125; if(l1) node-&gt;next = l1; else node-&gt;next = l2; return dummy-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; int len = 0; ListNode* node = head; while(node) &#123; len++; node = node-&gt;next; &#125; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; for(int sz = 1; sz &lt; len; sz*=2) &#123; ListNode* cur = dummy-&gt;next; // 待分割链表的第一个节点 tail为已经合并好的链表的最后一个节点 ListNode* tail = dummy; while(cur) &#123; ListNode* left = cur; ListNode* right = cut(left, sz); cur = cut(right, sz); tail-&gt;next = merge(left, right); while(tail-&gt;next) tail = tail-&gt;next; &#125; &#125; return dummy-&gt;next; &#125;&#125;; 参考资料"},{"title":"muduo Thread","permalink":"http://ywqzzy.github.io/2020/10/23/muduo-Thread/","text":"12 参考资料"},{"title":"muduo BoundedBlockingQueue","permalink":"http://ywqzzy.github.io/2020/10/22/muduo-BoundedBlockingQueue/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Use of this source code is governed by a BSD-style license// that can be found in the License file.//// Author: Shuo Chen (chenshuo at chenshuo dot com)#ifndef MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H#define MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H#include \"muduo/base/Condition.h\"#include \"muduo/base/Mutex.h\"#include &lt;boost/circular_buffer.hpp&gt;#include &lt;assert.h&gt;namespace muduo&#123;template&lt;typename T&gt;class BoundedBlockingQueue : noncopyable&#123; public: explicit BoundedBlockingQueue(int maxSize) : mutex_(), notEmpty_(mutex_), notFull_(mutex_), queue_(maxSize) &#123; &#125; void put(const T&amp; x) &#123; MutexLockGuard lock(mutex_); while (queue_.full()) &#123; notFull_.wait(); &#125; assert(!queue_.full()); queue_.push_back(x); notEmpty_.notify(); &#125; void put(T&amp;&amp; x) &#123; MutexLockGuard lock(mutex_); while (queue_.full()) &#123; notFull_.wait(); &#125; assert(!queue_.full()); queue_.push_back(std::move(x)); notEmpty_.notify(); &#125; T take() &#123; MutexLockGuard lock(mutex_); while (queue_.empty()) &#123; notEmpty_.wait(); &#125; assert(!queue_.empty()); T front(std::move(queue_.front())); queue_.pop_front(); notFull_.notify(); return front; &#125; bool empty() const &#123; MutexLockGuard lock(mutex_); return queue_.empty(); &#125; bool full() const &#123; MutexLockGuard lock(mutex_); return queue_.full(); &#125; size_t size() const &#123; MutexLockGuard lock(mutex_); return queue_.size(); &#125; size_t capacity() const &#123; MutexLockGuard lock(mutex_); return queue_.capacity(); &#125; private: mutable MutexLock mutex_; Condition notEmpty_ GUARDED_BY(mutex_); Condition notFull_ GUARDED_BY(mutex_); boost::circular_buffer&lt;T&gt; queue_ GUARDED_BY(mutex_);&#125;;&#125; // namespace muduo#endif // MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H 参考资料 BoundedBlockingQueue"},{"title":"muduo封装MutexLock MutexLockGuard Condition","permalink":"http://ywqzzy.github.io/2020/10/21/muduo封装MutexLock-MutexLockGuard-Condition/","text":"MutexLock12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class CAPABILITY(\"mutex\") MutexLock : noncopyable&#123; public: MutexLock() : holder_(0) &#123; MCHECK(pthread_mutex_init(&amp;mutex_, NULL)); &#125; ~MutexLock() &#123; assert(holder_ == 0); MCHECK(pthread_mutex_destroy(&amp;mutex_)); &#125; // must be called when locked, i.e. for assertion bool isLockedByThisThread() const &#123; return holder_ == CurrentThread::tid(); &#125; void assertLocked() const ASSERT_CAPABILITY(this) &#123; assert(isLockedByThisThread()); &#125; // internal usage void lock() ACQUIRE() &#123; MCHECK(pthread_mutex_lock(&amp;mutex_)); assignHolder(); &#125; void unlock() RELEASE() &#123; unassignHolder(); MCHECK(pthread_mutex_unlock(&amp;mutex_)); &#125; pthread_mutex_t* getPthreadMutex() /* non-const */ &#123; return &amp;mutex_; &#125; private: friend class Condition; class UnassignGuard : noncopyable &#123; public: explicit UnassignGuard(MutexLock&amp; owner) : owner_(owner) &#123; owner_.unassignHolder(); &#125; ~UnassignGuard() &#123; owner_.assignHolder(); &#125; private: MutexLock&amp; owner_; &#125;; void unassignHolder() &#123; holder_ = 0; &#125; void assignHolder() &#123; holder_ = CurrentThread::tid(); &#125; pthread_mutex_t mutex_; pid_t holder_;&#125;; MutexLockGuard12345678910111213141516171819202122232425class SCOPED_CAPABILITY MutexLockGuard : noncopyable&#123; public: explicit MutexLockGuard(MutexLock&amp; mutex) ACQUIRE(mutex) : mutex_(mutex) &#123; mutex_.lock(); &#125; ~MutexLockGuard() RELEASE() &#123; mutex_.unlock(); &#125; private: MutexLock&amp; mutex_;&#125;;&#125; // namespace muduo// Prevent misuse like:// MutexLockGuard(mutex_);// A tempory object doesn't hold the lock for long!#define MutexLockGuard(x) error \"Missing guard object name\" Condition1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Use of this source code is governed by a BSD-style license// that can be found in the License file.//// Author: Shuo Chen (chenshuo at chenshuo dot com)#ifndef MUDUO_BASE_CONDITION_H#define MUDUO_BASE_CONDITION_H#include \"muduo/base/Mutex.h\"#include &lt;pthread.h&gt;namespace muduo&#123;class Condition : noncopyable&#123; public: explicit Condition(MutexLock&amp; mutex) : mutex_(mutex) &#123; MCHECK(pthread_cond_init(&amp;pcond_, NULL)); &#125; ~Condition() &#123; MCHECK(pthread_cond_destroy(&amp;pcond_)); &#125; void wait() &#123; MutexLock::UnassignGuard ug(mutex_); MCHECK(pthread_cond_wait(&amp;pcond_, mutex_.getPthreadMutex())); &#125; // returns true if time out, false otherwise. bool waitForSeconds(double seconds); void notify() &#123; MCHECK(pthread_cond_signal(&amp;pcond_)); &#125; void notifyAll() &#123; MCHECK(pthread_cond_broadcast(&amp;pcond_)); &#125; private: MutexLock&amp; mutex_; pthread_cond_t pcond_;&#125;;&#125; // namespace muduo#endif // MUDUO_BASE_CONDITION_H 123456789101112131415bool muduo::Condition::waitForSeconds(double seconds)&#123; struct timespec abstime; // FIXME: use CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW to prevent time rewind. clock_gettime(CLOCK_REALTIME, &amp;abstime); const int64_t kNanoSecondsPerSecond = 1000000000; int64_t nanoseconds = static_cast&lt;int64_t&gt;(seconds * kNanoSecondsPerSecond); abstime.tv_sec += static_cast&lt;time_t&gt;((abstime.tv_nsec + nanoseconds) / kNanoSecondsPerSecond); abstime.tv_nsec = static_cast&lt;long&gt;((abstime.tv_nsec + nanoseconds) % kNanoSecondsPerSecond); MutexLock::UnassignGuard ug(mutex_); return ETIMEDOUT == pthread_cond_timedwait(&amp;pcond_, mutex_.getPthreadMutex(), &amp;abstime);&#125; 参考资料 muduo base Linux 多线程服务端编程–使用 muduo C++ 网络库"},{"title":"muduo CountdownLatch","permalink":"http://ywqzzy.github.io/2020/10/21/muduo-CountdownLatch/","text":"CountDownLatch用途如下： 主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。 主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出起跑命令。 代码大赏12345678910111213141516171819202122232425262728293031323334// Use of this source code is governed by a BSD-style license// that can be found in the License file.//// Author: Shuo Chen (chenshuo at chenshuo dot com)#ifndef MUDUO_BASE_COUNTDOWNLATCH_H#define MUDUO_BASE_COUNTDOWNLATCH_H#include \"muduo/base/Condition.h\"#include \"muduo/base/Mutex.h\"namespace muduo&#123;class CountDownLatch : noncopyable&#123; public: explicit CountDownLatch(int count); void wait(); void countDown(); int getCount() const; private: mutable MutexLock mutex_; Condition condition_ GUARDED_BY(mutex_); int count_ GUARDED_BY(mutex_);&#125;;&#125; // namespace muduo#endif // MUDUO_BASE_COUNTDOWNLATCH_H 12345678910111213141516171819202122232425262728293031323334353637383940// Use of this source code is governed by a BSD-style license// that can be found in the License file.//// Author: Shuo Chen (chenshuo at chenshuo dot com)#include \"muduo/base/CountDownLatch.h\"using namespace muduo;CountDownLatch::CountDownLatch(int count) : mutex_(), condition_(mutex_), count_(count)&#123;&#125;void CountDownLatch::wait()&#123; MutexLockGuard lock(mutex_); while (count_ &gt; 0) &#123; condition_.wait(); &#125;&#125;void CountDownLatch::countDown()&#123; MutexLockGuard lock(mutex_); --count_; if (count_ == 0) &#123; condition_.notifyAll(); &#125;&#125;int CountDownLatch::getCount() const&#123; MutexLockGuard lock(mutex_); return count_;&#125; 参考资料 CountDownLacth Linux 多线程服务端编程–使用 muduo C++ 网络库"},{"title":"muduo Blocking queue","permalink":"http://ywqzzy.github.io/2020/10/21/muduo-Blocking-queue/","text":"条件变量的使用对于 wait 端 必须与 mutex 一起使用，该布尔表达式的读写需受此 mutex 保护。 在 mutex 已上锁的时候才能调用 wait。 把判断布尔条件和 wait() 放在 while 循环中。 （不用 if 的原因 spurious wakeup） 对于 signal/broadcast 端 不一定要在 mutex 已上锁的情况下调用 signal 在 signal 之前一般要修改布尔表达式 修改布尔表达式通常要用 mutex 保护 注意区分 signal 和 broadcast： broadcast 一般用于表明状态变化，signal 通常用于表明资源可用 代码大赏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Use of this source code is governed by a BSD-style license// that can be found in the License file.//// Author: Shuo Chen (chenshuo at chenshuo dot com)#ifndef MUDUO_BASE_BLOCKINGQUEUE_H#define MUDUO_BASE_BLOCKINGQUEUE_H#include \"muduo/base/Condition.h\"#include \"muduo/base/Mutex.h\"#include &lt;deque&gt;#include &lt;assert.h&gt;namespace muduo&#123;template&lt;typename T&gt;class BlockingQueue : noncopyable&#123; public: BlockingQueue() : mutex_(), notEmpty_(mutex_), queue_() &#123; &#125; void put(const T&amp; x) &#123; MutexLockGuard lock(mutex_); queue_.push_back(x); notEmpty_.notify(); // wait morphing saves us // http://www.domaigne.com/blog/computing/condvars-signal-with-mutex-locked-or-not/ &#125; void put(T&amp;&amp; x) &#123; MutexLockGuard lock(mutex_); queue_.push_back(std::move(x)); notEmpty_.notify(); &#125; T take() &#123; MutexLockGuard lock(mutex_); // always use a while-loop, due to spurious wakeup while (queue_.empty()) &#123; notEmpty_.wait(); // 这一步会原子地 unlock mutex 并进入等待，不会与 put 思索， 执行完毕时会自动重新加锁。 &#125; assert(!queue_.empty()); T front(std::move(queue_.front())); queue_.pop_front(); return front; &#125; size_t size() const &#123; MutexLockGuard lock(mutex_); return queue_.size(); &#125; private: mutable MutexLock mutex_; Condition notEmpty_ GUARDED_BY(mutex_); std::deque&lt;T&gt; queue_ GUARDED_BY(mutex_);&#125;;&#125; // namespace muduo#endif // MUDUO_BASE_BLOCKINGQUEUE_H 参考资料 BlockingQueue linux 多线程服务端编程–使用 muduo c++ 网络库"},{"title":"std:function&std:bind&","permalink":"http://ywqzzy.github.io/2020/10/20/std-bind-std-function/","text":"function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//代码出自链接：http://www.jellythink.com/archives/771#include &lt;functional&gt;#include &lt;iostream&gt;using namespace std;std::function&lt; int(int)&gt; Functional;// 普通函数int TestFunc(int a)&#123; return a;&#125;// Lambda表达式auto lambda = [](int a)-&gt;int&#123; return a; &#125;;// 仿函数(functor)class Functor&#123;public: int operator()(int a) &#123; return a; &#125;&#125;;// 1.类成员函数// 2.类静态函数class TestClass&#123;public: int ClassMember(int a) &#123; return a; &#125; static int StaticMember(int a) &#123; return a; &#125;&#125;;int main()&#123; // 普通函数 Functional = TestFunc; int result = Functional(10); cout &lt;&lt; \"普通函数：\"&lt;&lt; result &lt;&lt; endl; // Lambda表达式 Functional = lambda; result = Functional(20); cout &lt;&lt; \"Lambda表达式：\"&lt;&lt; result &lt;&lt; endl; // 仿函数 Functor testFunctor; Functional = testFunctor; result = Functional(30); cout &lt;&lt; \"仿函数：\"&lt;&lt; result &lt;&lt; endl; // 类成员函数 TestClass testObj; Functional = std::bind(&amp;TestClass::ClassMember, testObj, std::placeholders::_1); result = Functional(40); cout &lt;&lt; \"类成员函数：\"&lt;&lt; result &lt;&lt; endl; // 类静态函数 Functional = TestClass::StaticMember; result = Functional(50); cout &lt;&lt; \"类静态函数：\"&lt;&lt; result &lt;&lt; endl; return 0;&#125; bind123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; // std::cout#include &lt;functional&gt; // std::bind// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)double my_divide(double x, double y) &#123; return x / y; &#125;struct MyPair &#123; double a, b; double multiply() &#123; return a*b; &#125;&#125;;int main() &#123; using namespace std::placeholders; // adds visibility of _1, _2, _3,... // binding functions: auto fn_five = std::bind(my_divide, 10, 2); // returns 10/2 std::cout &lt;&lt; fn_five() &lt;&lt; '\\n'; // 5 auto fn_half = std::bind(my_divide, _1, 2); // returns x/2 std::cout &lt;&lt; fn_half(10) &lt;&lt; '\\n'; // 5 auto fn_invert = std::bind(my_divide, _2, _1); // returns y/x std::cout &lt;&lt; fn_invert(10, 2) &lt;&lt; '\\n'; // 0.2 auto fn_rounding = std::bind&lt;int&gt;(my_divide, _1, _2); // returns int(x/y) std::cout &lt;&lt; fn_rounding(10, 3) &lt;&lt; '\\n'; // 3 MyPair ten_two&#123; 10,2 &#125;; // binding members: // returns x.multiply() auto bound_member_fn = std::bind(&amp;MyPair::multiply, _1); std::cout &lt;&lt; bound_member_fn(ten_two) &lt;&lt; '\\n'; // 20 // returns ten_two.a auto bound_member_data = std::bind(&amp;MyPair::a, ten_two); std::cout &lt;&lt; bound_member_data() &lt;&lt; '\\n'; // 10 return 0;&#125; function 和 bind 结合12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;functional&gt;class A &#123;public: int i_ = 0; void output(int x, int y) &#123; std::cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; std::endl; &#125;&#125;;int main()&#123; A a; std::function&lt;void(int, int)&gt; func1 = std::bind(&amp;A::output, &amp;a, std::placeholders::_1, std::placeholders::_2); func1(1, 2); std::function&lt;int&amp;(void)&gt; func2 = std::bind(&amp;A::i_, &amp;a); func2() = 888; std::cout &lt;&lt; a.i_ &lt;&lt; std::endl; return 0;&#125; 参考资料 C++11新特性应用–实现延时求值"},{"title":"实现blockingqueue","permalink":"http://ywqzzy.github.io/2020/10/19/实现blockingqueue/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//SyncQueue.hpp#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;iostream&gt;template&lt;typename T&gt;class SyncQueue&#123;private: bool IsFull() const &#123; return m_queue.size() == m_maxSize; &#125; bool IsEmpty() const &#123; return m_queue.empty(); &#125;public: SyncQueue(int maxSize) : m_maxSize(maxSize) &#123; &#125; void Put(const T&amp; x) &#123; std::lock_guard&lt;std::mutex&gt; locker(m_mutex); while (IsFull()) &#123; std::cout &lt;&lt; \"the blocking queue is full,waiting...\" &lt;&lt; std::endl; m_notFull.wait(m_mutex); &#125; m_queue.push_back(x); m_notEmpty.notify_one(); &#125; void Take(T&amp; x) &#123; std::lock_guard&lt;std::mutex&gt; locker(m_mutex); while (IsEmpty()) &#123; std::cout &lt;&lt; \"the blocking queue is empty,wating...\" &lt;&lt; std::endl; m_notEmpty.wait(m_mutex); &#125; x = m_queue.front(); m_queue.pop_front(); m_notFull.notify_one(); &#125;private: std::list&lt;T&gt; m_queue; //缓冲区 std::mutex m_mutex; //互斥量和条件变量结合起来使用 std::condition_variable_any m_notEmpty;//不为空的条件变量 std::condition_variable_any m_notFull; //没有满的条件变量 int m_maxSize; //同步队列最大的size&#125;; 测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//test.cpp#include \"SyncQueue.hpp\"#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;SyncQueue&lt;int&gt; syncQueue(5);void Produce()&#123; for (int i = 0; i &lt; 15; ++i) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); syncQueue.Put(888); std::cout&lt;&lt;\"put(888)\"&lt;&lt;std::endl; &#125;&#125;void Consume()&#123; int x = 0; for (int i = 0; i &lt; 5; ++i) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); syncQueue.Take(x); std::cout &lt;&lt; \"take(888)\" &lt;&lt; std::endl; &#125;&#125;int main(void)&#123; std::thread producer(Produce); std::thread consumer1(Consume); std::thread consumer2(Consume); std::thread consumer3(Consume); producer.join(); consumer1.join(); consumer2.join(); consumer3.join(); return 0;&#125; 参考资料"},{"title":"实现数据库连接池","permalink":"http://ywqzzy.github.io/2020/10/19/实现数据库连接池/","text":"数据库连接池采用单例模式创建，使用 RAII 机制释放数据库连接。 单例模式创建连接池12345678910111213141516class connection_pool&#123;public: //局部静态变量单例模式 static connection_pool *GetInstance();private: connection_pool(); ~connection_pool();&#125;connection_pool *connection_pool::GetInstance()&#123; static connection_pool connPool; return &amp;connPool;&#125; 初始化1234567891011121314151617181920212223242526272829303132333435363738394041connection_pool::connection_pool()&#123; m_CurConn = 0; m_FreeConn = 0;&#125;//构造初始化void connection_pool::init(string url, string User, string PassWord, string DBName, int Port, int MaxConn, int close_log)&#123; m_url = url; m_Port = Port; m_User = User; m_PassWord = PassWord; m_DatabaseName = DBName; m_close_log = close_log; for (int i = 0; i &lt; MaxConn; i++) &#123; MYSQL *con = NULL; con = mysql_init(con); if (con == NULL) &#123; LOG_ERROR(\"MySQL Error\"); exit(1); &#125; con = mysql_real_connect(con, url.c_str(), User.c_str(), PassWord.c_str(), DBName.c_str(), Port, NULL, 0); if (con == NULL) &#123; LOG_ERROR(\"MySQL Error\"); exit(1); &#125; connList.push_back(con); ++m_FreeConn; &#125; reserve = sem(m_FreeConn); m_MaxConn = m_FreeConn;&#125; 获取&amp;释放连接123456789101112131415161718192021222324252627282930313233343536373839//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数MYSQL *connection_pool::GetConnection()&#123; MYSQL *con = NULL; if (0 == connList.size()) return NULL; reserve.wait(); // 取出连接，信号量原子 -1， 为0则等待 lock.lock(); con = connList.front(); connList.pop_front(); --m_FreeConn; ++m_CurConn; lock.unlock(); return con;&#125;//释放当前使用的连接bool connection_pool::ReleaseConnection(MYSQL *con)&#123; if (NULL == con) return false; lock.lock(); connList.push_back(con); ++m_FreeConn; --m_CurConn; lock.unlock(); reserve.post(); // 释放连接 原子+1 return true;&#125; 销毁连接池1234567891011121314151617181920//销毁数据库连接池void connection_pool::DestroyPool()&#123; lock.lock(); if (connList.size() &gt; 0) &#123; list&lt;MYSQL *&gt;::iterator it; for (it = connList.begin(); it != connList.end(); ++it) &#123; MYSQL *con = *it; mysql_close(con); &#125; m_CurConn = 0; m_FreeConn = 0; connList.clear(); &#125; lock.unlock();&#125; RAII 释放数据库连接1234567891011class connectionRAII&#123;public: //双指针对MYSQL *con修改 connectionRAII(MYSQL **con, connection_pool *connPool); ~connectionRAII();private: MYSQL *conRAII; connection_pool *poolRAII;&#125;; 不直接调用获取和释放连接的接口，将其封装起来，通过RAII机制进行获取和释放。 12345678910connectionRAII::connectionRAII(MYSQL **SQL, connection_pool *connPool)&#123; *SQL = connPool-&gt;GetConnection(); conRAII = *SQL; poolRAII = connPool;&#125;connectionRAII::~connectionRAII()&#123; poolRAII-&gt;ReleaseConnection(conRAII);&#125; 参考资料 sql_connection_pool 11 数据库连接池"},{"title":"实现时间轮","permalink":"http://ywqzzy.github.io/2020/10/19/实现时间轮/","text":"参考资料 [游双-linux高性能服务器编程]"},{"title":"C++11 计时器","permalink":"http://ywqzzy.github.io/2020/10/19/c-11计时器/","text":"chrono这里主要介绍时间点和时钟两个点： ​ 一般计时器就是从某个时间点开始，然后到某个时间点之间的计数，就是我们一般称之为耗时； 时间点： 12template &lt;class Clock, class Duration = typename Clock::duration&gt; class time_point; std::chrono::time_point 表示一个具体时间 第一个模板参数Clock用来指定所要使用的时钟,在标准库中有三种时钟，分别为： system_clock：当前系统范围(即对各进程都一致)的一个实时的日历时钟(wallclock) steady_clock：当前系统实现的一个维定时钟，该时钟的每个时间嘀嗒单位是均匀的(即长度相等)。 high_resolution_clock：当前系统实现的一个高分辨率时钟。 第二个模板函数参数用来表示时间的计量单位(特化的std::chrono::duration&lt;&gt; ) 时间点都有一个时间戳，即时间原点。chrono库中采用的是Unix的时间戳1970年1月1日 00:00。所以time_point也就是距离时间戳(epoch)的时间长度（duration) 实现高精度计时器12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef _TimerClock_hpp_#define _TimerClock_hpp_#include &lt;iostream&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;class TimerClock&#123;public: TimerClock() &#123; update(); &#125; ~TimerClock() &#123; &#125; void update() &#123; _start = high_resolution_clock::now(); &#125; //获取秒 double getTimerSecond() &#123; return getTimerMicroSec() * 0.000001; &#125; //获取毫秒 double getTimerMilliSec() &#123; return getTimerMicroSec()*0.001; &#125; //获取微妙 long long getTimerMicroSec() &#123; //当前时钟减去开始时钟的count return duration_cast&lt;microseconds&gt;(high_resolution_clock::now() - _start).count(); &#125;private: time_point&lt;high_resolution_clock&gt;_start;&#125;;#endif 测试12345678910111213141516#include \"TimerClock.hpp\"int main()&#123; TimerClock TC; int sum = 0; TC.update(); for (int i = 0; i &gt; 100000; i++) &#123; sum++; &#125; cout &lt;&lt; \"cost time:\" &lt;&lt; TC.getTimerMilliSec() &lt;&lt;\"ms\"&lt;&lt; endl; cout &lt;&lt; \"cost time:\" &lt;&lt; TC.getTimerMicroSec() &lt;&lt; \"us\" &lt;&lt; endl; return 0;&#125; 参考资料 飞翔的猪"},{"title":"实现简单的固定线程数的线程池","permalink":"http://ywqzzy.github.io/2020/10/19/实现简单的固定线程数的线程池/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566作者：Graphene链接：https://www.zhihu.com/question/27908489/answer/355105668来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;#include &lt;queue&gt;#include &lt;thread&gt;class fixed_thread_pool &#123; public: explicit fixed_thread_pool(size_t thread_count) : data_(std::make_shared&lt;data&gt;()) &#123; for (size_t i = 0; i &lt; thread_count; ++i) &#123; std::thread([data = data_] &#123; std::unique_lock&lt;std::mutex&gt; lk(data-&gt;mtx_); for (;;) &#123; if (!data-&gt;tasks_.empty()) &#123; auto current = std::move(data-&gt;tasks_.front()); data-&gt;tasks_.pop(); lk.unlock(); current(); lk.lock(); &#125; else if (data-&gt;is_shutdown_) &#123; break; &#125; else &#123; data-&gt;cond_.wait(lk); &#125; &#125; &#125;).detach(); &#125; &#125; fixed_thread_pool() = default; fixed_thread_pool(fixed_thread_pool&amp;&amp;) = default; ~fixed_thread_pool() &#123; if ((bool) data_) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lk(data_-&gt;mtx_); data_-&gt;is_shutdown_ = true; &#125; data_-&gt;cond_.notify_all(); &#125; &#125; template &lt;class F&gt; void execute(F&amp;&amp; task) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lk(data_-&gt;mtx_); data_-&gt;tasks_.emplace(std::forward&lt;F&gt;(task)); &#125; data_-&gt;cond_.notify_one(); &#125; private: struct data &#123; std::mutex mtx_; std::condition_variable cond_; bool is_shutdown_ = false; std::queue&lt;std::function&lt;void()&gt;&gt; tasks_; &#125;; std::shared_ptr&lt;data&gt; data_;&#125;; 非常僵硬的看不懂了，之后再来回味。。。。 参考资料 Graphene"},{"title":"实现简单的线程安全Queue","permalink":"http://ywqzzy.github.io/2020/10/19/实现简单的线程安全Queue/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#pragma once#include &lt;mutex&gt;#include &lt;queue&gt;// Thread safe implementation of a Queue using an std::queuetemplate &lt;typename T&gt;class SafeQueue &#123;private: std::queue&lt;T&gt; m_queue; std::mutex m_mutex;public: SafeQueue() &#123; &#125; SafeQueue(SafeQueue&amp; other) &#123; //TODO: &#125; ~SafeQueue() &#123; &#125; bool empty() &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); return m_queue.empty(); &#125; int size() &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); return m_queue.size(); &#125; void enqueue(T&amp; t) &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); m_queue.push(t); &#125; bool dequeue(T&amp; t) &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); if (m_queue.empty()) &#123; return false; &#125; t = std::move(m_queue.front()); m_queue.pop(); return true; &#125;&#125;; 参考资料 SafeQueue"},{"title":"实现string类","permalink":"http://ywqzzy.github.io/2020/10/19/实现string类/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class String&#123;public: String() :data_(new char[1]) &#123; *data_ = '\\0'; &#125; String(const char&amp; str) :data_(new char[strlen(str) + 1]) &#123; strcpy(data_, str); &#125; String(const String&amp; rhs) :data_(new char[rhs.size() + 1]) &#123; strcpy(data_, rhs.c_str()); &#125; ~String() &#123; delete[] data_; &#125; /* traditional String&amp; operator=(const String&amp; rhs) &#123; String tmp(rhs); swap(tmp); return *this &#125;*/ String&amp; operator=(String rhs) &#123; swap(rhs); return *this; &#125; // C++ 11 String(String&amp;&amp; rhs) : data_(rhs.data_) &#123; rhs.data_ = nullptr; &#125; String&amp; operator=(String&amp;&amp; rhs) &#123; swap(rhs); return *this; &#125; size_t size() const &#123; return strlen(data_); &#125; const char* c_str() const &#123; return data_; &#125; void swap(String&amp; rhs) &#123; std::swap(data_, rhs.data_); &#125; private: char* data_;&#125; 12345String&amp; operator=(String rhs) // yes, pass-by-value&#123; swap(rhs); return *this;&#125; 使用swap的原因是，这个String类涉及到内存分配操作，这个操作可能会抛出异常；上面的实现分3步： 把“源对象”拷贝到参数rhs里 rhs对象和this对象做一下交换（仅仅交换指针） 返回this对象 第一步有可能发生异常（new操作失败），然后在这一步退出；这是下两歩操作还没有进行，所以不会污染this对象。保证了： 赋值操作失败，但是this对象没有被污染，或者 赋值操作成功 参考资料 chenshuo coolshell"},{"title":"Noncopyable","permalink":"http://ywqzzy.github.io/2020/10/19/Noncopyable/","text":"在 Muduo 中，有一个 noncopyable 类，继承了该类的派生类不能被拷贝，只能被移动。涉及拷贝的函数有两个：拷贝构造函数和拷贝复制操作符。将这两个方法声明为不可访问或者删除，就可以达到不可拷贝的效果。 将函数声明为 private将拷贝构造函数和拷贝复制操作符声明为 private，能阻止编译器创建这两个函数，同时阻止用户调用他们，从而达到阻止拷贝的效果。 123456789class noncopyable&#123;protected: noncopyable() &#123;&#125; ~noncopyable() &#123;&#125;private:// emphasize the following members are private noncopyable( const noncopyable&amp; ); noncopyable&amp; operator=( const noncopyable&amp; );&#125;; 使用方法如下： 1class foo: private noncopyable&#123;&#125;; 一定要使用 private 来继承，防止 member 函数和 friend 函数访问。 c++11 使用 delete关键字代码如下： 12345678class noncopyable &#123;protected: noncopyable() = default; ~noncopyable() = default;private: noncopyable(const noncopyable&amp;) = delete; const noncopyable&amp; operator=( const noncopyable&amp; ) = delete;&#125;; 把构造函数和析构函数设置为 protected 权限，这样子类可以调用，外面的其他类不能调用。 使用 delete 关键字禁止编译器自动产生 copy 构造函数，和copy assignment ctor。 参考资料 muduo segmentfault"},{"title":"对象池","permalink":"http://ywqzzy.github.io/2020/10/18/对象池/","text":"对象池对于创建开销比较大的对象来说很有意义，为了避免重复创建开销比较大的对象，我们可以通过对象池来优化。对象池的思路比较简单，事先创建好一批对象，放到一个集合中，以后每当程序需要新的对象时候，都从对象池里获取，每当程序用完该对象后，都把该对象归还给对象池。这样会避免重复的对象创建，提高程序性能。 简单实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;list&gt; template&lt;typename Object&gt;class ObjectPool&#123;public: ObjectPool(size_t unSize) : m_unSize(unSize) &#123; for (size_t unIdx = 0; unIdx &lt; m_unSize; ++ unIdx) &#123; m_oPool.push_back(new Object()); &#125; &#125; ~ObjectPool() &#123; typename std::list&lt;Object *&gt;::iterator oIt = m_oPool.begin(); while (oIt != m_oPool.end()) &#123; delete (*oIt); ++ oIt; &#125; m_unSize = 0; &#125; Object * GetObject() &#123; Object * pObj = NULL; if (0 == m_unSize) &#123; pObj = new Object(); &#125; else &#123; pObj = m_oPool.front(); m_oPool.pop_front(); -- m_unSize; &#125; return pObj; &#125; void ReturnObject(Object * pObj) &#123; m_oPool.push_back(pObj); ++ m_unSize; &#125; private: size_t m_unSize; std::list&lt;object *&gt; m_oPool;&#125;; 不足点如下： 对象池ObjectPool只能容纳特定类型的对象，不能容纳所有类型的对象，可以支持重载的和参数不同的构造函数； 对象用完之后需要手动回收，用起来不够方便，更大的问题是存在忘记回收的风险； 希望能有一个更强大的对象池，这个对象池能容纳所有的对象，还能自动回收用完了对象，不需要手动回收，用起来更方便。要实现这样的对象池需要解决前面提到的两个问题，通过c++11就可以解决这两个问题。 对于问题1：容纳所有的对象。本质上需要将对象池中的对象类型擦除，这里用Any类型就可以解决。 对于问题2：自动回收用完的对象。这里用智能指针就可以解决，在创建智能指针时可以指定删除器，在删除器中不删除对象，而是回收到对象池中，而这个过程对外界来说是看不见的，由智能指针自己完成。 ​ 暂时不考虑解决问题一。 一个支持自动回收的对象池实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#ifndef IG_SHARED_OBJECT_POOL_H_#define IG_SHARED_OBJECT_POOL_H_#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;memory&gt;namespace ig &#123; static const size_t kObjectPoolDefaultSize = 100;static const size_t kObjectPoolDefaultExtendSize = 10;template &lt;typename ObjectType&gt;struct ObjectPoolDefaultInitializer &#123; void operator()(ObjectType *object) const &#123; &#125;&#125;;template &lt;typename ObjectType, size_t N = kObjectPoolDefaultSize, typename Initializer = ObjectPoolDefaultInitializer&lt;ObjectType&gt; &gt;class SharedObjectPool &#123; public: static SharedObjectPool&amp; Instance() &#123; static SharedObjectPool pool(N); return pool; &#125; std::shared_ptr&lt;ObjectType&gt; Get() &#123; ObjectType *ptr = nullptr; if (queue_.empty()) &#123; Extend(kObjectPoolDefaultExtendSize); &#125; ptr = queue_.front(); queue_.pop(); kInitializer(ptr); return std::shared_ptr&lt;ObjectType&gt;(ptr, [&amp;](ObjectType *p) &#123; queue_.push(p); &#125;); &#125; int capacity() const &#123; return capacity_; &#125; void set_capacity(const size_t capacity) &#123; if (capacity_ &lt; capacity) &#123; Extend(capacity - capacity_); &#125; &#125; private: explicit SharedObjectPool(const size_t pool_size) : kDefaultCacheSize(pool_size) &#123; cache_ = new ObjectType[kDefaultCacheSize]; for (size_t i = 0; i &lt; kDefaultCacheSize; ++i) &#123; queue_.push(&amp;cache_[i]); kInitializer(&amp;cache_[i]); &#125; capacity_ = kDefaultCacheSize; &#125; ~SharedObjectPool() &#123; if (cache_) &#123; delete[] cache_; cache_ = nullptr; &#125; for (auto &amp;ptr : extended_cache_) &#123; delete ptr; &#125; extended_cache_.clear(); &#125; void Extend(const size_t num) &#123; for (size_t i = 0; i &lt; num; ++i) &#123; ObjectType *ptr = new ObjectType; extended_cache_.push_back(ptr); queue_.push(ptr); kInitializer(ptr); &#125; capacity_ = kDefaultCacheSize + extended_cache_.size(); &#125; private: size_t capacity_ = 0; std::queue&lt;ObjectType*&gt; queue_; ObjectType *cache_ = nullptr; std::list&lt;ObjectType*&gt; extended_cache_; const size_t kDefaultCacheSize; static const Initializer kInitializer;&#125;; template &lt;typename ObjectType, size_t N, typename Initializer&gt;const Initializer SharedObjectPool&lt;ObjectType, N, Initializer&gt;::kInitializer;&#125; // namespace ig#endif // IG_SHARED_OBJECT_POOL_H_ 参考资料 对象池 一个超级对象池的实现"},{"title":"pImpl","permalink":"http://ywqzzy.github.io/2020/10/18/pImpl/","text":"pImpl（Private Implementation 或 Pointer to Implementation）是通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏。 优点： 降低模块的耦合。因为隐藏了类的实现，被隐藏的类相当于原类不可见，对隐藏的类进行修改，不需要重新编译原类。 降低编译依赖，提高编译速度。 接口与实现分离，提高接口的稳定性。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#ifndef __LINE_H__#define __LINE_H__ //设计模式: PIMPL//1. 实现信息隐藏//2. 减小编译依赖, 可以用最小的代价平滑的升级库文件，//3. 接口与实现进行解耦 class Line&#123;public: Line(int,int,int,int); ~Line(); void printLine() const;private: class LineImpl;private: LineImpl * _pimpl;&#125;;class Line::LineImpl&#123; class Point &#123; public: Point(int ix = 0, int iy = 0) : _ix(ix) , _iy(iy) &#123; cout &lt;&lt; \"Point(int=0, int=0)\" &lt;&lt; endl; &#125; void print() const &#123; cout &lt;&lt; \"(\" &lt;&lt; _ix &lt;&lt; \",\" &lt;&lt; _iy &lt;&lt; \")\"; &#125; private: int _ix; int _iy; &#125;;public: LineImpl(int x1, int y1, int x2, int y2) : _p1(x1, y1) , _p2(x2, y2) &#123; cout &lt;&lt; \"LineImpl(int,int,int,int)\" &lt;&lt; endl; &#125; ~LineImpl() &#123; cout &lt;&lt; \"~LineImpl()\" &lt;&lt; endl; &#125; void printLine() const;private: Point _p1; Point _p2;&#125;; void Line::LineImpl::printLine() const&#123; _p1.print(); cout &lt;&lt; \" --&gt; \"; _p2.print(); cout &lt;&lt; endl;&#125; Line::Line(int x1, int y1, int x2, int y2): _pimpl(new LineImpl(x1, y1, x2, y2))&#123; cout &lt;&lt; \"Line(int,int,int,int)\" &lt;&lt; endl;&#125; Line::~Line()&#123; delete _pimpl; cout &lt;&lt; \"~Line()\" &lt;&lt; endl;&#125; void Line::printLine() const&#123; _pimpl-&gt;printLine();&#125;#endif 参考资料 cnblogs"},{"title":"RAII","permalink":"http://ywqzzy.github.io/2020/10/18/RAII/","text":"什么是RAIIRAII（Resource Acquisition Is Initialization）是由 c++ 之父 Bjarne Stroustrup 提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入； RAII的原理资源的使用一般经历三个步骤 获取资源 使用资源 销毁资源。 但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++ 之父给出了解决问题的方案：RAII，它充分的利用了 C++ 语言局部对象自动销毁的特性来控制资源的生命周期。给一个简单的例子来看下局部对象的自动销毁的特性： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class person &#123; public: person(const std::string name = \"\", int age = 0) : name_(name), age_(age) &#123; std::cout &lt;&lt; \"Init a person!\" &lt;&lt; std::endl; &#125; ~person() &#123; std::cout &lt;&lt; \"Destory a person!\" &lt;&lt; std::endl; &#125; const std::string&amp; getname() const &#123; return this-&gt;name_; &#125; int getage() const &#123; return this-&gt;age_; &#125; private: const std::string name_; int age_; &#125;;int main() &#123; person p; return 0;&#125;/*编译并运行：g++ person.cpp -o person./person 运行结果：Init a person!Destory a person!*/ 从 person class 可以看出，当我们在 main 函数中声明一个局部对象的时候，会自动调用构造函数进行对象的初始化，当整个 main 函数执行完成后，自动调用析构函数来销毁对象，整个过程无需人工介入，由操作系统自动完成；于是，很自然联想到，当我们在使用资源的时候，在构造函数中进行初始化，在析构函数中进行销毁。整个RAII 过程我总结四个步骤： 设计一个类封装资源 在构造函数中初始化 在析构函数中执行销毁操作 使用时声明一个该对象的类 应用linux 下经常会使用多线程技术，说到多线程，就得提到互斥锁，互斥锁主要用于互斥，互斥是一种竞争关系，用来保护临界资源一次只被一个线程访问，按照我们前面的分析，封装一下 POSIX 标准的互斥锁： 123456789101112131415161718192021222324252627282930313233343536#include &lt;pthread.h&gt;#include &lt;cstdlib&gt;#include &lt;stdio.h&gt;class Mutex &#123; public: Mutex(); ~Mutex(); void Lock(); void Unlock(); private: pthread_mutex_t mu_; // No copying Mutex(const Mutex&amp;); void operator=(const Mutex&amp;);&#125;;#include \"mutex.h\"static void PthreadCall(const char* label, int result) &#123; if (result != 0) &#123; fprintf(stderr, \"pthread %s: %s\\n\", label, strerror(result)); &#125;&#125;Mutex::Mutex() &#123; PthreadCall(\"init mutex\", pthread_mutex_init(&amp;mu_, NULL)); &#125;Mutex::~Mutex() &#123; PthreadCall(\"destroy mutex\", pthread_mutex_destroy(&amp;mu_)); &#125;void Mutex::Lock() &#123; PthreadCall(\"lock\", pthread_mutex_lock(&amp;mu_)); &#125;void Mutex::Unlock() &#123; PthreadCall(\"unlock\", pthread_mutex_unlock(&amp;mu_)); &#125; 写到这里其实就可以使用 Mutex 来锁定临界区，但我们发现 Mutex 只是用来对锁的初始化和销毁，我们还得在代码中调用 Lock 和 Unlock 函数，这又是一个对立操作，所以我们可以继续使用 RAII 进行封装，代码如下： 12345678910111213141516#include \"mutex.h\"class MutexLock &#123; public: explicit MutexLock(Mutex *mu) : mu_(mu) &#123; this-&gt;mu_-&gt;Lock(); &#125; ~MutexLock() &#123; this-&gt;mu_-&gt;Unlock(); &#125; private: Mutex *const mu_; // No copying allowed MutexLock(const MutexLock&amp;); void operator=(const MutexLock&amp;);&#125;; 使用示例如下： 12345678910111213141516171819202122232425262728293031323334353637#include \"mutexlock.hpp\"#include &lt;unistd.h&gt;#include &lt;iostream&gt;#define NUM_THREADS 10000int num=0;Mutex mutex;void *count(void *args) &#123; MutexLock lock(&amp;mutex); num++;&#125;int main() &#123; int t; pthread_t thread[NUM_THREADS]; for( t = 0; t &lt; NUM_THREADS; t++) &#123; int ret = pthread_create(&amp;thread[t], NULL, count, NULL); if(ret) &#123; return -1; &#125; &#125; for( t = 0; t &lt; NUM_THREADS; t++) pthread_join(thread[t], NULL); std::cout &lt;&lt; num &lt;&lt; std::endl; return 0;&#125;/*编译并运行：g++ test_mutexlock.cpp mutexlock.hpp mutex.cpp mutex.h -o test_mutexlock -lpthread./test_mutexlock 运行结果：10000 符合预期（可以去掉MutexLock lock(&amp;mutex);试试看看结果如何？）*/ 参考资料 知乎"},{"title":"智能指针","permalink":"http://ywqzzy.github.io/2020/10/18/智能指针/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485template&lt;class T&gt;class SharedPointer&#123;public: SharedPointer():m_refCount(nullptr), m_pointer(nullptr) &#123;&#125; SharedPointer(T* adoptTarget):m_refCount(nullptr), m_pointer(adoptTarget) &#123; addReference(); &#125; SharedPointer(const SharedPointer&lt;T&gt;&amp; copy):m_refCount(copy.m_refCount), m_pointer(copy.m_pointer) &#123; addReference(); &#125; virtual ~SharedPointer() &#123; removeReference(); &#125; //赋值操作 //当左值被赋值时，表明它不再指向所指的资源，故引用计数减一 //之后，它指向了新的资源，所以对应这个资源的引用计数加一 SharedPointer&lt;T&gt;&amp; operator=(const SharedPointer&lt;T&gt;&amp; that) &#123; if (this != &amp;that) &#123; removeReference(); this-&gt;m_pointer = that.m_pointer; this-&gt;m_refCount = that.m_refCount; addReference(); &#125; return *this; &#125; //判断是否指向同一个资源 bool operator==(const SharedPointer&lt;T&gt;&amp; other) &#123; return m_pointer == other.m_pointer; &#125; bool operator!=(const SharedPointer&lt;T&gt;&amp; other) &#123; return !operator==(other); &#125; //指针解引用 T&amp; operator*() const &#123; return *m_pointer; &#125; //调用所知对象的公共成员 T* operator-&gt;() const &#123; return m_pointer; &#125; //获取引用计数个数 int GetReferenceCount() const &#123; if (m_refCount) &#123; return *m_refCount; &#125; else &#123; return -1; &#125; &#125; protected: //当为nullpter时，创建引用计数资源，并初始化为1 //否则，引用计数加1。 void addReference() &#123; if (m_refCount) &#123; (*m_refCount)++; &#125; else &#123; m_refCount = new int(0); *m_refCount = 1; &#125; &#125; void removeReference() &#123; if(m_refCount) &#123; (*m_refCount)--; if(*m_refCount == 0) &#123; delete m_refCount; delete m_pointer; m_refCount = 0; m_pointer = 0; &#125; &#125; &#125;private: int *m_refCount; T *m_pointer;&#125;;"},{"title":"Singleton--C++","permalink":"http://ywqzzy.github.io/2020/10/18/Singleton-c/","text":"懒汉版最简版123456789101112131415class Singleton &#123;private: static Singleton* instance; Singleton() &#123;&#125;; ~Singleton() &#123;&#125;; Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton* getInstance() &#123; if(instance == NULL) instance = new Singleton(); return instance; &#125;&#125;;Singleton* Singleton::instance = NULL; 存在内存泄漏的问题，解决方案： 使用智能指针 使用静态的嵌套类对象 使用静态的嵌套类对象1234567891011121314151617181920212223class Singleton &#123;private: static Singleton* instance; Singleton() &#123;&#125;; ~Singleton() &#123;&#125;; Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton* getInstance() &#123; if(instance == NULL) instance = new Singleton(); return instance; &#125;private: class Deletor &#123; public: ~Deletor() &#123; if(Singleton::instance != NULL) delete Singleton::instance; &#125; &#125;; static Deletor deletor;&#125;;Singleton* Singleton::instance = NULL; 在程序运行结束时，系统会调用静态成员 deletor 的析构函数，该析构函数会删除单例的唯一实例。 使用这种方法释放单例对象有以下特征： 在单例类内部定义专有的嵌套类。 在单例类内定义私有的专门用于释放的静态成员。 利用程序在结束时析构全局变量的特性，选择最终的释放时机。 上述代码不仅麻烦，并且在多线程环境下会出现竞争，考虑使用双检测锁模式（Double-Checked locking Pattern) 加锁123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;mutex&gt;using namespace std;std::mutex mt;class Singleton&#123;private: Singleton()&#123;&#125;public: static Singleton* instance() &#123; mt.lock(); // 加锁 if(_instance == 0) _instance = new Singleton(); mt.unlock(); // 解锁 return _instance; &#125;private: static Singleton* _instance;&#125;;Singleton* Singleton::_instance = 0; 上锁后是解决了线程安全问题，但是有些资源浪费。稍微分析一下：每次instance函数调用时候都需要请求加锁，其实并不需要，instance函数只需第一次调用的时候上锁就行了。这时可以用DCLP解决。 双检查锁，由于内存读写导致不安全Double-Checked Locking Pattern 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;mutex&gt;using namespace std;std::mutex mt;class Singleton&#123;private: Singleton()&#123;&#125;public: static Singleton* instance() &#123; if(_instance == 0) &#123; mt.lock(); if(_instance == 0) _instance = new Singleton(); mt.unlock(); &#125; return _instance; &#125;private: static Singleton* _instance;public: int atestvalue;&#125;;Singleton* Singleton::_instance = 0; 这个版本很不错，又叫“双重检查”Double-Check。下面是说明： 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。 不然，我们就开始同步线程。 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。 分析 1_instance = new Singleton(); 为了执行这句代码，机器需要做三样事儿： singleton对象分配空间。 在分配的空间中构造对象 使_instance指向分配的空间 遗憾的是编译器并不是严格按照上面的顺序来执行的。可以交换2和3. 将上面三个步骤标记到代码中就是这样： 123456789101112Singleton* Singleton::instance() &#123; if (_instance == 0) &#123; mt.lock(); if (_instance == 0) &#123; _instance = // Step 3 operator new(sizeof(Singleton)); // Step 1 new (_instance) Singleton; // Step 2 &#125; mt.unlock(); &#125; return _instance;&#125; 线程A进入了instance函数，并且执行了step1和step3，然后挂起。这时的状态是：_instance不 NULL，而_instance指向的内存区没有对象！ 线程B进入了instance函数，发现_instance不为null，就直接return _instance了。 local staticC++ 11 规定了 local static 在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。 12345678910111213class Singleton &#123;private: Singleton() &#123; &#125;; ~Singleton() &#123; &#125;; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;public: static Singleton&amp; getInstance() // 返回引用 &#123; static Singleton instance; // 静态局部变量 return instance; &#125;&#125;; gcc 4.0之后的编译器支持这种写法。 C++11及以后的版本（如C++14）的多线程下，正确。 C++11之前不能这么写。 C++11 call_once12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;std::once_flag flag;class Singleton&#123;public: static Singleton&amp; getInstance() &#123; std::call_once(flag, []() &#123;instance_.reset(new Singleton()); &#125;); return *instance_; &#125;private: static std::unique_ptr&lt;Singleton&gt; instance_;private: Singleton() = default; Singleton(const Singleton&amp; other) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;;std::unique_ptr&lt;Singleton&gt; Singleton::instance_;void do_onceflag()&#123; Singleton&amp; s = Singleton::getInstance(); cout &lt;&lt; &amp;s &lt;&lt; endl;&#125;int main()&#123; std::thread t1(do_onceflag); std::thread t2(do_onceflag); t1.join(); t2.join(); return 0;&#125; 饿汉版单例实例在程序运行时被立即执行初始化。 1234567891011121314class Singleton &#123;private: static Singleton instance;private: Singleton(); ~Singleton(); Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);public: static Singleton&amp; getInstance() &#123; return instance; &#125;&#125;;Singleton Singleton::instance; 由于在 main 函数之前初始化，所以没有线程安全的问题。但是潜在问题在于 no-local static 对象（函数外的 static对象）在不同编译单元中的初始化顺序是未定义的。也即，static Singleton instance;和 static Singleton&amp; getInstance() 二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。"},{"title":"写一个 Move aware class","permalink":"http://ywqzzy.github.io/2020/10/16/写一个-move-aware-class/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class MyString &#123;public: static size_t DCtor; static size_t Ctor; static size_t CCtor; static size_t CAsgn; static size_t MCtor; static size_t Dtor;private: char* _data; size_t _len; void _init_data(const char *s) &#123; _data = new char[_len + 1]; memcpy(_data, s, _len); _data[_len] = '\\0'; &#125;public: // default ctor MyString(): _data(NULL), _len(0) &#123; ++DCtor; &#125; // ctor MyString(const char* p): _len(strlen(p)) &#123; ++Ctor; _init_data(p); &#125; // copy ctor MyString(const Mystring&amp; str):_len(str._len) &#123; ++CCtor; _init_data(str._data); &#125; // move ctor MyString(MyString&amp;&amp; str) noexcept :_data(str._data), _len(str._len) &#123; ++MCtor; str._len = 0; str._data = NULL;// IMPORTANT &#125; // copy assignment MyString&amp; operator=(const MyString&amp; str) &#123; ++CAsgn; if(this != &amp;str) &#123; // 自我赋值检查 if(_data) delete _data; _len = str._len; _init_data(str._data); &#125; else &#123; &#125; return *this; &#125; // move assignment MyString&amp; operator=(MyString&amp;&amp; str) noexcept&#123; ++MAsgn; if(this != &amp;str) &#123; // 自我赋值检查 if(_data) delete _data; _len = str._len; _data = str._data; str._len = 0; str._data = NULL; &#125; return *this; &#125; // dtor virtual ~MyString() &#123; ++Dtor; if(_data) delete _data; &#125; // operator&lt; bool operator&lt;(const MyString&amp; rhs) const &#123; return string(this-&gt;data) &lt; string(rhs._data); &#125; // operator== bool operator==(const MyString&amp; rhs) const &#123; return string(this-&gt;data) == string(rhs._data); &#125; char* get() const &#123; return _data; &#125; &#125;size_t MyString::DCtor = 0;size_t MyString::Ctor = 0;size_t MyString::CCtor = 0;size_t MyString::CAsgn = 0;size_t MyString::MCtor = 0;size_t MyString::Dtor = 0;size_t MyString::MAsgn = 0;namespace std &#123;template&lt;&gt;struct hash&lt;MyString&gt; &#123; // for unordered containers size_t operator() (const MyString&amp; s) const noexcept &#123; return hash&lt;string&gt;()(string(s.get())); // 借用现成的 hash&lt;string&gt; &#125;&#125;&#125;"},{"title":"Rvalue references","permalink":"http://ywqzzy.github.io/2020/10/16/Rvalue-references/","text":"Rvalue-referencesRvalue references are a new reference type introduced in C++0x that help solve the problem of unnecessary coping and enable perfect forwarding. When the right-hand side of an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a seperate allocation, thus enabling move semantics. Lvalue: 可以出现于 operator = 左侧者 Rvalue: 只能出现于 operator = 右侧者 只要在内存中有确定存储空间的都是左值。 1234567int foo() &#123; return 5;&#125;int x = foo(); // okint *p = &amp;foo(); // error 对着右值 5 取其 reference 是不可以的。没有所谓的 Rvalue reference（before C++0x)foo() = 7; // error 当 Rvalue 出现于 operator=(copy assignment)的右侧，我们认为对其资源进行偷取/搬移（move) 而非拷贝（copy）是可以的。 那么： 必须有语法让我们在调用端告诉编译器，这是个“Rvalue” 必须有语法让我们在被调用端写出一个专门处理 Rvalue 的所谓 move assignment 函数。 Perfect Forwarding Perfect forwarding allows you to write a single function template that takes n arbitrary arguments and forwards them transparently to another arbitrary function. The nature of the argument(modifiable, const, lvalue, rvalue) is preserved in the forwarding process. 1234template&lt;typename T1, typename T2&gt;void functionA(T1&amp;&amp; t1, T2&amp;&amp; t2) &#123; functionB(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));&#125;"},{"title":"lambda","permalink":"http://ywqzzy.github.io/2020/10/16/lambda/","text":"C++11 introduced lambdas, allowing the definition of inline functionality, which can be used as a parameter or a local object. Lambdas change the way the C++ statndard library is used. A lambda is a definition of functionality that can be defined inside statements and expressions. Thus, you can use a lambda as an inline function. The minimal lambda function has no parameters and simply does something. 12345678910111213[] &#123; std::cout &lt;&lt; \"hello lambda\"&lt;&lt;std::endl;&#125;[] &#123; std::cout&lt;&lt; \"hello lambda\"&lt;&lt;std::endl;&#125;();auto l = [] &#123; std::cout&lt;&lt; \"hello lambda\"&lt;&lt;std::endl;&#125;l();"},{"title":"decltype","permalink":"http://ywqzzy.github.io/2020/10/16/decltype/","text":"Defines a type equivalent to the type of an expression. By using the decltype keyword, you can let the compiler find out the type of an expression, this is the realization of the often requested typepf feature. One application of decltype is to declare return types; Another is to use it in metaprogramming or to pass the type of a lambda. 12345678910111213141516171819202122232425// 1. declare return typestemplate&lt;typename T1, typename T2&gt;decltype(x + y) add(T1 x, T2 y); // 不行template&lt;typename T1, typename T2&gt;auto add(T1 x, T2 y) -&gt; decltype(x + y);// 2. meta programmingtemplate&lt;typename T&gt;void test_decltype(T obj) &#123; map&lt;string, float&gt;::value_type elem1; map&lt;string, float&gt; coll; decltype(coll)::value_type elem2; typedef typename decltype(obj)::iterator iType; // =&gt; typedef typename T::iterator iType // test_decltype(complex&lt;int&gt;()) 编译失败 decltype(obj) anotherObj(obj);&#125;// 3. pass the type of lambdaauto cmp = [](const Person&amp; p1, const Person&amp; p2) &#123; return p1.lastname() &lt; p2.lastname() || (p1.lastname() == p2.lastname() &amp;&amp; p1.firstname() &lt; p2.firstname()); &#125;;std::set&lt;Person, decltype(cmp)&gt; coll(cmp);"},{"title":"noexcept","permalink":"http://ywqzzy.github.io/2020/10/16/noexcept/","text":""},{"title":"Type Alias & using","permalink":"http://ywqzzy.github.io/2020/10/16/Type-Alias/","text":"Type aliasSimilar to typedef 1234567891011// type alias, identical to// typedef void (*func)(int, int)using func = void (*)(int, int);void example(int, int) &#123;&#125;func fn = example;// alias templatetemplate&lt;class CharT&gt; using mystring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;mystring&lt;char&gt; str; 和 &lt;string_fwd.h&gt; 都有以下 typedef: typedef basic_string string; 12345678910// type alias can introduce a member typedef nametemplate&lt;typename T&gt;struct Container &#123; using value_type = T; // typedef T value_type;&#125;;template&lt;typename Cntr&gt;void fn2(const Cntr&amp; c) &#123; typename Cntr::value_type n;&#125; using using-directives for namespaces and using-declarations for namespace members; 12using namespace std;using std::count; using-declarations for class members 12345protected: using _Base::_M_allocate; using _Base::_M_deallocate; using _Base::_S_nword; using _Base::_M_get_Bit_allocator; type alias and alias template declaration"},{"title":"Range-based for statement","permalink":"http://ywqzzy.github.io/2020/10/16/range-based-for-statement/","text":"1234567891011121314151617/*for( decl : coll) &#123; statement&#125;*/for(int i: &#123;2，3，4，5，6，76，7，8，8&#125;) &#123; cout&lt;&lt;i&lt;&lt;endl;&#125;vector&lt;double&gt; vec;for(auto elem: vec) &#123; cout&lt;&lt; elem &lt;&lt;endl;&#125;for(auto&amp; elem: vec) &#123; elem *= 3;&#125;// 关联式容器不能修改值 No explicit type conversions are possible when elements are initialized as decl inside the for loop. Thus, the following does not compile: 12345678910class C &#123; public: explicit C(const string&amp; s); ....&#125;;vector&lt;string&gt; vs;for(const C&amp; elem: vs) &#123; // error no conversion from string to C defined cout&lt;&lt;elem&lt;&lt;endl;&#125;"},{"title":"explicit关键字","permalink":"http://ywqzzy.github.io/2020/10/16/explicit关键字/","text":"用在一个实参上的 explicit。123456789struct Complex &#123; int real, imag; Complex(int re, int im = 0): real(re), imag(im)&#123;&#125; Complex operator+(const Complex&amp; x) &#123; return Complex((real + x,real), (imag + x.imag)); &#125;&#125;Complex c1(12, 5);Complex c2 = c1 + 5; // 会调用构造函数 将 5 隐式转换为 Complex 123456789struct Complex &#123; int real, imag; explicit Complex(int re, int im = 0): real(re), imag(im)&#123;&#125; Complex operator+(const Complex&amp; x) &#123; return Complex((real + x,real), (imag + x.imag)); &#125;&#125;Complex c1(12, 5);Complex c2 = c1 + 5; // [Error] no match for 'operator+'(operand types are 'Complex' ands 'int') 用在多个实参上的 explicit"},{"title":"Variadic Templates","permalink":"http://ywqzzy.github.io/2020/10/15/Variadic-Templates/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;// 处理无参数的情况void printX() &#123; std::cout &lt;&lt; std::endl;&#125;// 任意参数类型template&lt;typename T, typename... Types&gt;void printX(const T&amp; firstArg, const Types&amp;... args) &#123; std::cout &lt;&lt; firstArg &lt;&lt; std::endl; std::cout &lt;&lt; \"left:\" &lt;&lt; sizeof...(args) &lt;&lt; \"params\" &lt;&lt; \" \"; // args 会被分为2部分 一部分是第一个参数 第二部分是args... printX(args...);&#125;// ... 是所谓的 pack// 用于 template parameters 就是 template parameters pack// 用于 function parameter types 就是 function parameter types pack// 用于 function parameters 就是 function parameters packvoid printf(const char *s) &#123; while(*s) &#123; if(*s=='%'&amp;&amp;*(++s)!='%') throw std::runtime_error(\"invalid format string\"); std::cout &lt;&lt; *s++; &#125;&#125;//printftemplate&lt;typename T, typename... Args&gt;void printf(const char* s, T value, Args... args) &#123; while(*s) &#123; if(*s=='%'&amp;&amp;*(++s)!='%') &#123; std::cout &lt;&lt; value; printf(++s, args...); return; &#125; std::cout &lt;&lt; *s++; &#125; throw std::runtime_error(\"invalid format string\");&#125;int maximum(int n) &#123;return n;&#125;template&lt;typename...Args&gt;int maximum(int n, Args... args) &#123; return std::max(n, maximum(args...));&#125;int main() &#123; printX(1,2,3,\"asa\"); std::cout &lt;&lt; maximum(1,2,3,4) &lt;&lt; std::endl;&#125;"},{"title":"uniform initialization","permalink":"http://ywqzzy.github.io/2020/10/15/uniform-initialization/","text":"123456int values[] &#123;1,2,3&#125;;vector&lt;int&gt; v&#123;2,3,5,6,7,11,13&#125;;vector&lt;string&gt; cities &#123; \"beijing\", \"shanghai\",\"nanjing\"&#125;;complex&lt;double&gt; c&#123;4.0, 3.0&#125;; 利用一个事实，编译器看到{t1,t2,…,tn} 便会做出一个 initializer_list, 它关联至一个 array&lt;T, n&gt;。 调用函数(例如 ctor)时改 array 内的元素可被编译器分解逐一传给函数。但若函数参数是个 initializer_list, 调用者却不能基于数个 T 参数然后以为他们会被自动转为一个 initializer_list 传入。 1234567void print(std::initializer_list&lt;int&gt; vals)&#123; for(auto p = vals.begin(); p != vals.end(); ++p) &#123; std::cout&lt;&lt; *p &lt;&lt;endl; &#125;&#125;print(&#123;1,2,3,4,5,6,7,8&#125;); The initializer_list object refers to the elements of this array without containing them: copy initializer_list object produces another object referring to the same underlying elements, not to new copies of them. 123456789101112131415161718vector&lt;int&gt; v1 &#123;2,5,7,13,69,83,50&#125;;vector&lt;int&gt; v2(&#123;2,5,7,13,69,83,50&#125;); // 调用接收 initializer_list 的构造函数vector&lt;int&gt; v3;v3 = &#123;2,5,7,13,69,83,50&#125;; //operator= v3.insert(v3.begin() + 2, &#123;0,1,2,3,4,5&#125;);cout&lt;&lt; max(&#123;1,2,3,4,5&#125;) &lt;&lt; endl;cout&lt;&lt; min(&#123;1,2,3,4,5&#125;) &lt;&lt; endl;template&lt;typename _Tp&gt;inline _Tp min(initializer_list&lt;_Tp&gt; __l) &#123; return *std::min_element(__l.beigin(), __l.end());&#125;template&lt;typename _Tp&gt;inline _Tp max(initializer_list&lt;_Tp&gt; __l) &#123; return *std::max_element(__l.beigin(), __l.end());&#125;"},{"title":"同步 IO 和异步 IO","permalink":"http://ywqzzy.github.io/2020/10/12/同步-IO-和异步-IO/","text":"Linux 系统中，所有的设备读写都可以看做文件的读写来操作，对文件的读写一般要经过内核态和用户态的切换， 正因为有切换才导致了 IO 有同步和异步的说法。 通常来讲 IO 可以分成两种： 来自网络的 IO 来自文件或者设备的 IO 并且完成 IO 操作可以简单的表述为两个步骤： 发起 IO 请求 执行 IO 操作 如何区分是同步 IO 还是异步 IO 呢？ “执行 IO 操作”是否阻塞 当请求被阻塞，就是同步 IO，否则就是异步 IO 同步 IO 的特点： 同步 IO 指的是用户进程触发 I/O 操作并等待或者轮询的去查看 I/O 操作是否就绪。同步 IO 的执行者是 IO 操作的发起者。同步 IO 需要发起者进行内核态到用户态的数据拷贝过程，所以这里必须由个阻塞 异步 IO 的特点： 异步 IO 是指用户进程触发 I/O 操作以后就立即返回，继续开始做自己的事情，而当 I/O 操作已经完成的时候会得到 I/O 完成的通知。异步 IO 的执行者是内核线程，内核线程将数据从内核态拷贝到用户态，所以这里没哟阻塞 如何区分是阻塞 IO 还是非阻塞 IO 呢？ 发起 IO 操作是否阻塞 如果阻塞直到完成，就是阻塞 IO，否则就是非阻塞 IO 讨论几个IO模型 阻塞 IO 模型(同步IO) 阻塞 IO 模型从发起 IO 操作到数据拷贝到用户空间，进程一直是阻塞的。 非阻塞 IO 模型(同步IO) 非阻塞 IO 模型从发起 IO 操作后就直接返回，定时轮询数据有没有准备好，后面还是需要拷贝数据到用户空间 IO 复用模型(同步 IO) IO 复用模型是发起 IO 操作前先调用 Select 或者 Poll。这两个函数都会在内核态准备好数据后告诉用户进程，相对于非阻塞 IO 模型来说，不需要轮询，用户进程可以做其他事情。但是本质上还是同步 IO但是它的优点在于可以同时触发多个 IO任务并在每个 IO 完成后依次处理。 信号驱动 IO 模型 通过 sigaction 注册信号，等内核准备好数据后内核态执行信号函数，本质还是同步 IO 异步 IO 模型采用 aio_read 让内核准备好数据并复制到用户进程空间，最后通知用户进程，这才是正真的异步 IO 参考资料 知乎"},{"title":"reactor & proactor","permalink":"http://ywqzzy.github.io/2020/10/12/reactor-proactor/","text":"标准定义两种I/O多路复用模式：Reactor 和 Proactor 一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的 read/write 事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。 两个与事件分离器有关的模式是Reactor和Proactor。Reactor 模式采用同步 IO，而 Proactor 采用异步 IO。 在 Reactor 中，事件分离器负责等待文件描述符或 socket 为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。 而在 Proactor 模式中，处理器–或者兼任处理器的事件分离器，只负责发起异步读写操作。IO 操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从 socket 读到的数据。事件分离器捕获 IO 操作完成事件，然后将事件传递给对应处理器。比如，在 windows 上，处理器发起一个异步 IO 操作，再由事件分离器等待 IOCompletion 事件。典型的异步模式实现，都建立在操作系统支持异步 API 的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。 举个例子，将有助于理解 Reactor 与 Proactor 二者的差异，以读操作为例（类操作类似）。 在 Reactor 中实现读： 注册读就绪事件和相应的事件处理器 事件分离器等待事件 事件到来，激活分离器，分离器调用事件对应的处理器。 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。 在 Proactor 中实现读： 处理器发起异步读操作（注意：操作系统必须支持异步 IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。 事件分离器等待操作完成事件 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。 事件分离器呼唤处理器。 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。 可以看出，两个模式的相同点，都是对某个 IO 事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调 handler 时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。 通俗理解使用Proactor框架和Reactor框架都可以极大的简化网络应用的开发，但它们的重点却不同。 Reactor 框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要向一个 SOCKET 写数据，那么当该S OCKET 可以接收数据的时候，你的操作就会被调用；而 Proactor 框架中用户定义的操作是在实际操作之后调用的。比如你定义了一个操作要显示从 SOCKET 中读入的数据，那么当读操作完成以后，你的操作才会被调用。 Proactor 和 Reactor 都是并发编程中的设计模式。在我看来，他们都是用于派发/分离 IO 操作事件的。这里所谓的 IO 事件也就是诸如 read/write 的 IO 操作。”派发/分离”就是将单独的 IO 事件通知到上层模块。两个模式不同的地方在于，Proactor 用于异步 IO，而 Reactor 用于同步 IO。 参考资料 知乎"},{"title":"cppcon2020 Back to basics: The structure of a Program","permalink":"http://ywqzzy.github.io/2020/10/09/cppcon2020-Back-to-basics-The-structure-of-a-Program/","text":"参考资料"},{"title":"cppcon2020 Back to basics: The Abstract Machine","permalink":"http://ywqzzy.github.io/2020/10/09/cppcon2020-Back-to-basics-The-Abstract-Machine/","text":"什么是 C++ Abstract Machine“The C++ Abstract machine is a portable abstraction of your operating system, kernel and hardware. The abstract machine is the intermediary between your c++ program and the system that it is run on.” C++ defines how programs work in terms of an abstract machine deliberately defined to be “close to the hardware”. When we write c++ code, we are writing to the c++ abstract machine. StructureMemory Objects Threads Memory A single flat space. No memory hierarchy No concept of statck, registers or cache No concept of heterogeneous memory All parts of memory are equally reachable by the am Access to memory hash uniform latency Objects Threads Summary 参考资料 cpp conference 2020 bilibili"},{"title":"在知乎上删掉的保研经历","permalink":"http://ywqzzy.github.io/2020/09/15/在知乎上删除掉的保研经验/","text":"本科是帝都211，数字媒体技术专业（偏通信专业）。从大一下开始对编程产生了浓郁的兴趣，最开始的时候是自学c语言，当时快速学完了语法，以致于学校的c语言课都没怎么听过，考试轻松过。大一暑假接触前端，当时对于编程了解尚浅，所以更喜欢可视化的东西。跟着慕课网的课程看，也算是对前端有了初步的了解。大二课业繁重，加上大一成绩也不算特别好，就开始专心学习专业课（包括数电模电信号等课），最终得到了一个还不错的绩点，但是这段时间内对于编程的学习也就断断续续了。寒假期间陪女朋友学车的时候在驾校的咖啡厅看完了整套的邓俊辉数据结构，算是入了门，但是具体的代码也没有实践过。大二下学期由于要和做大创，又对unity浅尝辄止，算是了解了点面向对象的思想。之后参加了学校ACM集训，暑假在学校呆了一个月，每天刷题（虽然都是些简单题），倒也算是把基本的数据结构熟悉了，也锻炼了编程思维。同时又学了一些机器学习，看了《机器学习基石》系列教程，还有CS231n（当然仍然浅尝辄止）。大二下本想转专业去计科，后权衡再三，没有转。大三上。身边的大佬师哥拿到了很好的offer，交谈中其实很是振奋，觉得一直自学下去其实也是可行的，故决心放弃绩点专心刷计算机基础课，期间简略看完CSAPP,看了大半部SICP，刷了算法橙书，计算机网络（自顶向下），并且坚持ACM训练，6级考了577。有幸参加了两次ACM区域赛，均打铁（不过还是不甘）。寒假决定找工作，匆忙间看了李航的《统计学习方法》，一刷了《王道数据结构》和《剑指offer》。又知道自己基础薄弱，开始看操作系统，这门课起初学起来十分吃力，前后换了很多教程和课本，最终靠孙志岗老师的教程初步了解了操作系统。期间还看了点java和javaweb，跟着教程完成了小的项目。可以说那段时间是慌乱和迷茫的，知道自己很差却只能拼了命地弥补。 大三下继续ACM训练和计算机专业课的学习，先是看了东南徐立臻老师的《数据库》教程。又在一阵慌乱中继续着算法的训练。参加过春招（内推），打击过大，遂放弃（电话面试一问三不知，一点b-树都没有），还得感谢师哥模拟面试，虽然我最后砸的不行。决意考研，和女票一起考南大软件。在正式复习考研前，参加acm邀请赛，意外拿了银牌，算是一个很大的惊喜，可能是“杨超越附体”了。考研专业课有四门（数据结构，操作系统，计算机网络和软件工程）。从5月底到9月中旬，就是充实的考研复习阶段了。期间专业课至少过了2遍，数据结构的算法题应该都刷了不止一遍，基本的题目应该是很熟悉了。南软的软件工程专业课让我收获颇丰，一是面向对象的思想，二是一个中型系统项目对自己的启发。软件工程这门课包括了uml和一些设计模式和面向对象的知识，课程设置独树一帜。 ￼ 考研复习期间还做过php和java的项目。php项目算是学了设计模式之后的一次练兵，算是自己第一次不跟着教程写项目，对于代码不断进行重构，成就感max。 然后转机来了，机缘巧合，本不该进入保研圈的我因为之前得到的奖和相对较高的绩点幸运保研，真实的幸运，感激地一塌糊涂！！ 保研名单下来的迟，准备的少，还得感谢 @邱锐 大佬给的申请经验，成功推免至北邮网研院。 #update 更新下保研的过程吧。中秋去女票家的时候收到学校推免成功的消息后才开始投简历。之前一直准备考研，心里觉得只有拿到学校推免才能完全放下考研的复习全身心准备面试。 陆续投了一堆江浙沪和南方的学校（家在南京），包括华师，同济，复旦，华东理工，南大，中科大，中南大学之类的。当时想着就是海投了。北京投了北邮之后也就没管了。从女票家回来之后第一天就去北邮面试，上午面试计算机学院，下午网研院，网研院当场收到offer（面试官：这题你是不是都做过了？我：嗯，复习考研这些题刷过了）而且他们超棒啊，直接劝我别直博，因为我数学差的要死。王道数据结构课后题我从寒假开始刷，直到面试的时候已经刷了3遍了QAQ。 后来陆续收到科大，华师，中南的面试通知（貌似都稳了），再三考虑后全鸽了，对不起对不起对不起。 可能是大学前三年压抑太久了（翘过无数必修课选修课，就为了学会自己怎么都学不会的算法）最后想让我顺一回吧。 大学三年经历过各种迷茫困顿，总觉得无法消弭和科班大佬之间的差距，一直都在追赶，也一直在本专业的课程和计算机课程之间游离。所幸两者得兼，所幸不负韶华。 ￼￼ 一定得感谢体贴的女票一直的照顾和陪伴，你最终还是支持了我的决定。虽然你我将有短暂的分别，但是相信读完研后，我们都会是更好的自己了。 具体的学习历程还有恋爱历程之后可以更。 保研到北京还是心疼女票啊啊啊啊啊啊啊啊啊啊啊。 update 女票成功上岸南大软件。%%%%tql 转眼就到毕业。 最近才稍有些毕业的感觉。 四年是日渐拥挤的书架，日均12000步的行走，零星几个肝掉的深夜，几十张车票，“北境不遗忘”，“我要成为海贼王”，“Run as one”…. 少了许多少年心事，不再说华丽辞藻含蓄故事。多了肚子、大腿上的肉，愈发坚定且直抒胸臆。 前两天采访时候，问研究生规划我并未作答。并非毫无愿景。四年的际遇奇迹满满，三年后亦未可知，不设限，任我行。希望能够各自攀峰，山顶再会 毕业后要变成一个真正的男人，要控制情绪，处理好生活与工作，爱自己，爱他人，眼里有光。 感谢不可能的和可能的。 遇见你之前，幻想高考多对一道选择题，物理大题第一题没有算错，或许人生的轨迹就会大不相同。 遇见你之后，无法形容自己有多幸运。在人生的这条马氏链上，我似乎找到了Best policy，援引The big bang theroy剧内插曲的歌词。 I couldn’t have imagined How good my life would get From the moment that I met you 过去的遗憾也不能算是遗憾了，现在拥有的就是现在了。 穿过人潮汹涌灯火阑珊， 没有想过回头。 再 update 日期2020/9/15 经过一段阵痛期，之后再寒假后陪女票找实习，npy太强了，先后拿下跟谁学，美团，字节，阿里的实习offer，实习后更加知道了追求的东西和出路。 之前的一些幼稚想法也变得成熟起来。 前路坦荡，可别走歪了。"},{"title":"词法分析","permalink":"http://ywqzzy.github.io/2019/04/27/词法分析/","text":"标识符是一个大的集合。 记号的数据结构定义123456789101112enum kind &#123;IF,LPAREN,ID,INTLIT,...&#125;struct token&#123; enum kind k; char *lexeme;// 单词&#125;；/*eg if(x&gt;5) ===&gt;&gt; token&#123;k=IF,lexeme=0&#125;;token&#123;k=LPAREN,lexeme=0&#125;；token&#123;k=ID,lexeme=\"x\"&#125;;.....*/ 词法分析器的任务，字符流到记号流。 记号流是编译器内部定义的数据结构，编码所识别出的词法单元。 词法分析—手工构造法相对复杂，容易出错。 词法分析器的生成器（自动化）：可快速原型、代码量少，但难控制细节。 转移图 1234567891011121314151617token nextToken() &#123; c = getChar(); switch(c) &#123; case '&lt;': c= getChar(); switch(c)&#123; case '=': return LE; case='&gt;':return NE; default: rollback();return LT; &#125; case '=':return EQ; case '&gt;': c= getChar(); switch(c):&#123; .....//和上面类似 &#125; &#125;&#125; 标识符的转移图： 识别关键字 也可以弄关键字构成的哈希表，先统一按照关键符的转移图进行识别，进一步查表看是否是关键字。完美哈希 正则表达式 kleene闭包。 例子：标识符c语言：以字母或下划线开头，后面跟多个或0个字母数字或下划线 （a|b|c|…..z|A|B|C|….|Z|–)(a|b|c|…..z|A|B|C|….|Z|–|0|1|…|9|)* 有限状态自动机 非确定有限状态自动机（NFA） 确定有限状态自动机（DFA) NFA难以判断字符串是否可接受。需要进行搜索。需要将NFA转化为等价的DFA。 DFA的实现带有边和节点的有向图。 边上面有信息 节点上有信息 正则表达式到NFA（Thompson算法）RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码 对基本的RE直接构造 对复合的RE递归构造 NFA转化为DFA（子集构造法） 不动点算法：why能终止？ DFA最小化Hopcroft算法 什么叫做能切分？ 首先切分成非终结符和终结符两类 DFA的代码表示转移表 哈希表 跳转表 转移表：还要有词法分析驱动代码。 ​ 最长匹配思想。 跳转表: 跳转表不需要维护一个大的转移数组。"}]}