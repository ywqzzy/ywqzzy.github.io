<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SimpleEpollServer源码阅读</title>
      <link href="/2020/10/29/SimpleEpollServer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/10/29/SimpleEpollServer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="AsyncServer"><a href="#AsyncServer" class="headerlink" title="AsyncServer"></a>AsyncServer</h2><p>首先看一下 Server 的 data member.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> listen_fd_, epoll_fd_;</span><br><span class="line">epoll_event *events_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, ClientDescriptor *&gt; clients_;</span><br><span class="line"><span class="keyword">uint32_t</span> timeout_secs_;</span><br><span class="line"><span class="keyword">time_t</span> last_socket_check_;</span><br></pre></td></tr></table></figure><p>AsynceServer 的构造函数如下， 首先初始化了 socket 连接， 绑定端口号，设置 listenfd， 又设置了 epoll 的 event 和 nonblocking。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">AsyncServer(<span class="keyword">const</span> <span class="keyword">char</span> *listen_addr, <span class="keyword">uint16_t</span> listen_port, <span class="keyword">uint32_t</span> timeout_secs) :</span><br><span class="line">listen_fd_(<span class="number">-1</span>),</span><br><span class="line">epoll_fd_(<span class="number">-1</span>),</span><br><span class="line">timeout_secs_(timeout_secs),</span><br><span class="line">last_socket_check_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sockaddr_in <span class="built_in">sin</span> = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(listen_addr);</span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(listen_port);</span><br><span class="line"></span><br><span class="line">listen_fd_ = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(listen_fd_ &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"socket() failed, error code: "</span> + <span class="built_in">std</span>::to_string(errno));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bind(listen_fd_, <span class="keyword">reinterpret_cast</span>&lt;sockaddr *&gt;(&amp;<span class="built_in">sin</span>), <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)))</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"bind() failed, error code: "</span> + <span class="built_in">std</span>::to_string(errno));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SetNonblocking(listen_fd_) == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"SetNonBlocking() failed, error code: "</span> + <span class="built_in">std</span>::to_string(errno));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(listen(listen_fd_, SOMAXCONN) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"listen() failed, error code: "</span> + <span class="built_in">std</span>::to_string(errno));</span><br><span class="line"></span><br><span class="line">epoll_fd_ = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(epoll_fd_ == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"epoll_create1() failed, error code: "</span> + <span class="built_in">std</span>::to_string(errno));</span><br><span class="line"></span><br><span class="line">epoll_event e_event;</span><br><span class="line">e_event.events = EPOLLIN;</span><br><span class="line">e_event.data.fd = listen_fd_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, listen_fd_, &amp;e_event) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"epoll_ctl() failed, error code: "</span> + <span class="built_in">std</span>::to_string(errno));</span><br><span class="line"></span><br><span class="line">events_ = <span class="keyword">new</span> epoll_event[<span class="number">64</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中的 SetNonblocking 的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SetNonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(flags == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">flags |= O_NONBLOCK;  <span class="comment">// set nonblocking</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属于常规操作</span></span><br></pre></td></tr></table></figure><p>析构函数比较简单，就是销毁资源， 包括 listen_fd, epoll_fd 和 events。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~AsyncServer()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(listen_fd_ != <span class="number">-1</span>)</span><br><span class="line">close(listen_fd_);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(epoll_fd_ != <span class="number">-1</span>)</span><br><span class="line">close(epoll_fd_);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] events_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑在 EventLoop() 函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num_fds = epoll_wait(epoll_fd_, events_, <span class="number">64</span>, <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 最大事件数 64， 最多等待时间 1000 ms</span></span><br><span class="line"><span class="keyword">if</span>(num_fds != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//iterate signaled fds</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_fds; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//notifications on listening fd are incoming client connections</span></span><br><span class="line"><span class="keyword">if</span>(events_[i].data.fd == listen_fd_)</span><br><span class="line">&#123;</span><br><span class="line">HandleAccept();  <span class="comment">// 处理用户连接</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">HandleClient(events_[i]); <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//perform cleanup every second and remove timed-out sockets</span></span><br><span class="line">            <span class="comment">// 处理空闲客户连接 采用心跳判断死活</span></span><br><span class="line"><span class="keyword">if</span>((last_socket_check_ + <span class="number">1</span>) &lt; time(<span class="number">0</span>) &amp;&amp; clients_.size() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, ClientDescriptor *&gt;::iterator it = clients_.begin();</span><br><span class="line"><span class="keyword">while</span>(it != clients_.end()) </span><br><span class="line">&#123;</span><br><span class="line">ClientDescriptor *client = (*it).second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!client-&gt;HeartBeat())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if HeartBeat() returns false remove fd from map and close</span></span><br><span class="line">it = clients_.erase(it);</span><br><span class="line">client-&gt;ServerClose();</span><br><span class="line"><span class="keyword">delete</span> client;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">last_socket_check_ = time(<span class="number">0</span>); <span class="comment">// 更新 check 时间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面关注当有客户端尝试连接的时候调用的 HandleAccept() 函数。也就是说当 serverfd 上发生 EPOLLIN  event 后，会调用  HandleAccept。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HandleAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockaddr_in client_sin;</span><br><span class="line"><span class="keyword">socklen_t</span> sin_size = <span class="keyword">sizeof</span>(client_sin);</span><br><span class="line">ClientDescriptorType *client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> client_fd = accept(listen_fd_, <span class="keyword">reinterpret_cast</span>&lt;sockaddr *&gt;(&amp;client_sin), &amp;sin_size);</span><br><span class="line">        <span class="comment">// 获取 client_fd</span></span><br><span class="line"><span class="keyword">if</span>(client_fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"accept() failed, error code: %d\n"</span>, errno);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 设为非阻塞 </span></span><br><span class="line"><span class="keyword">if</span>(!SetNonblocking(client_fd))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"failed to put fd into non-blocking mode, error code: %d\n"</span>, errno);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate and initialize a new descriptor for the client</span></span><br><span class="line">client = <span class="keyword">new</span> ClientDescriptorType(client_fd, client_sin.sin_addr, </span><br><span class="line">  ntohs(client_sin.sin_port), </span><br><span class="line">  timeout_secs_);</span><br><span class="line"></span><br><span class="line">epoll_event ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLRDHUP | EPOLLET;<span class="comment">//client events will be handled in edge-triggered mode 边缘触发模式</span></span><br><span class="line">        <span class="comment">// EPOLLRDHUP 代表对端断开连接</span></span><br><span class="line">ev.data.ptr = client;<span class="comment">//we will pass client descriptor with every event</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加监听的时间</span></span><br><span class="line"><span class="keyword">if</span>(epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, client_fd, &amp;ev) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"epoll_ctl() failed, error code: %d\n"</span>, errno);</span><br><span class="line"><span class="keyword">delete</span> client;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store new client descriptor into the map of clients</span></span><br><span class="line">clients_[client_fd] = client;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] new client: %s:%d\n"</span>, inet_ntoa(client_sin.sin_addr), ntohs(client_sin.sin_port));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 client_fd 上发生 EPOLLIN 事件时，则需要调用 HandleClient() 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//called whenever and EPOLLIN event occurs on a client fd</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HandleClient</span><span class="params">(epoll_event ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//retrieve client descriptor address from the data parameter</span></span><br><span class="line">ClientDescriptor *client = <span class="keyword">reinterpret_cast</span>&lt;ClientDescriptor *&gt;(ev.data.ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别对三个不同事件进行处理</span></span><br><span class="line">        <span class="comment">// EPOLLIN  EPOLLRDHUP  EPOLLOUT</span></span><br><span class="line"><span class="comment">//we got some data from the client</span></span><br><span class="line"><span class="keyword">if</span>(ev.events &amp; EPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!client-&gt;ReadReady())</span><br><span class="line">&#123;</span><br><span class="line">RemoveClient(client);</span><br><span class="line">client-&gt;ServerClose();</span><br><span class="line"><span class="keyword">delete</span> client;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//the client closed the connection (should be after EPOLLIN as client can send data then close)</span></span><br><span class="line"><span class="keyword">if</span>(ev.events &amp; EPOLLRDHUP)</span><br><span class="line">&#123;</span><br><span class="line">RemoveClient(client);</span><br><span class="line">client-&gt;ClientClose();</span><br><span class="line"><span class="keyword">delete</span> client;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fd is ready to be written</span></span><br><span class="line"><span class="keyword">if</span>(ev.events &amp; EPOLLOUT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!client-&gt;WriteReady())</span><br><span class="line">&#123;</span><br><span class="line">RemoveClient(client);</span><br><span class="line">client-&gt;ServerClose();</span><br><span class="line"><span class="keyword">delete</span> client;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveClient</span><span class="params">(ClientDescriptor *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, ClientDescriptor *&gt;::iterator it = clients_.find(client-&gt;uid());</span><br><span class="line">clients_.erase(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClientDescriptor"><a href="#ClientDescriptor" class="headerlink" title="ClientDescriptor"></a>ClientDescriptor</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is a base client descriptor and virtual methods should be implemented by a derived class.</span></span><br><span class="line"><span class="comment">Returning false from any of the methods will result in Cleanup() being called and the client </span></span><br><span class="line"><span class="comment">descriptor being deconstructed immediately.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClientDescriptor(<span class="keyword">int</span> fd, in_addr client_addr, <span class="keyword">uint16_t</span> client_port, <span class="keyword">uint32_t</span> timeout) :</span><br><span class="line">fd_(fd),</span><br><span class="line">client_addr_(client_addr),</span><br><span class="line">client_port_(client_port),</span><br><span class="line">timeout_(timeout)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~ClientDescriptor()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//called when a client fd becomes available for writing</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ReadReady</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"ReadReady() not implemented"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//called when a client fd becomes available for reading</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">WriteReady</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"WriteReady() not implemented"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//called periodically to check if fd is still alive (used to implement timeout)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HeartBeat</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"HeartBeat() not implemented"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//called when the server is done with the client and the fd should be closed</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ServerClose</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"ServerClose() not implemented"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//called if the connection was forcibly closed by the client</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ClientClose</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"ClientClose() not implemented"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client's unique id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fd_;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> fd_;</span><br><span class="line">in_addr client_addr_;</span><br><span class="line"><span class="keyword">uint16_t</span> client_port_;</span><br><span class="line"><span class="keyword">uint32_t</span> timeout_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ExampleClient"><a href="#ExampleClient" class="headerlink" title="ExampleClient"></a>ExampleClient</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ClientDescriptor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClient</span> :</span> <span class="keyword">public</span> ClientDescriptor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ExampleClient(<span class="keyword">int</span> fd, in_addr client_addr, <span class="keyword">uint16_t</span> client_port, <span class="keyword">uint32_t</span> timeout) : </span><br><span class="line">ClientDescriptor(fd, client_addr, client_port, timeout),</span><br><span class="line">last_active_(time(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReadReady</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WriteReady</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HeartBeat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientClose</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">time_t</span> last_active_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ExampleClient::ReadReady()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> bytes_read;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data_buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//we must drain the entire read buffer as we won't get another event until client sends more data</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bytes_read = recv(fd_, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(bytes_read &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">data_buffer.append(buffer, bytes_read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client triggered EPOLLIN but sent no data (usually due to remote socket being closed)</span></span><br><span class="line"><span class="keyword">if</span>(data_buffer.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[i] client %s:%d said: %s\n"</span>, inet_ntoa(client_addr_), client_port_, data_buffer.c_str());</span><br><span class="line"></span><br><span class="line">write(fd_, data_buffer.c_str(), data_buffer.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//update last active time to prevent timeout</span></span><br><span class="line">last_active_ = time(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ExampleClient::WriteReady()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">during heavy network I/O fds can become unwritable and subsequent calls to write() / send() will fail,</span></span><br><span class="line"><span class="comment">in this case the data which failed to send should be stored in a buffer and the operation should be</span></span><br><span class="line"><span class="comment">retried when WriteReady() is called to signal the fd is writable again (this is up to you to implement).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ExampleClient::HeartBeat()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if no operations occurred during timeout period return false to signal server to close socket</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(last_active_ + timeout_) &lt; time(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[i] connection %s:%d has timed out\n"</span>, inet_ntoa(client_addr_), client_port_);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ExampleClient::ClientClose()</span><br><span class="line">&#123;</span><br><span class="line">close(fd_);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[-] connection %s:%d closed by client\n"</span>, inet_ntoa(client_addr_), client_port_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ExampleClient::ServerClose() </span><br><span class="line">&#123;</span><br><span class="line">close(fd_);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[-] connection %s:%d closed by server\n"</span>, inet_ntoa(client_addr_), client_port_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/MalwareTech/SimpleEpollServer" target="_blank" rel="noopener">SimpleEpollServer</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 网络编程 epoll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yfs-源码剖析（4）--Caching locks</title>
      <link href="/2020/10/29/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89-Caching-locks/"/>
      <url>/2020/10/29/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89-Caching-locks/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> yfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ yfs 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yfs-源码剖析（3）--基本文件服务2</title>
      <link href="/2020/10/29/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A12/"/>
      <url>/2020/10/29/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A12/</url>
      
        <content type="html"><![CDATA[<h2 id="mkdir-amp-unlink"><a href="#mkdir-amp-unlink" class="headerlink" title="mkdir&amp;unlink"></a>mkdir&amp;unlink</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::mkdir(inum parent, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">mode_t</span> mode, inum &amp;inum)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">LockGuard <span class="title">lg</span><span class="params">(m_lc, parent)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> dir_name;</span><br><span class="line">  <span class="keyword">if</span> (ec-&gt;get(parent, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dir_name = <span class="string">"/"</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(name) + <span class="string">"/"</span>;</span><br><span class="line">  <span class="comment">// 目录已经存在</span></span><br><span class="line">  <span class="keyword">if</span> (data.find(dir_name) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> EXIST;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inum = random_inum(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (ec-&gt;put(inum, <span class="built_in">std</span>::<span class="built_in">string</span>()) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data.append(dir_name + filename(inum) + <span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">if</span> (ec-&gt;put(parent, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> yfs_client::unlink(inum parent, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">LockGuard <span class="title">lg</span><span class="params">(m_lc, parent)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> file_name = <span class="string">"/"</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(name) + <span class="string">"/"</span>;</span><br><span class="line">  <span class="keyword">size_t</span> pos, end, len; </span><br><span class="line">  inum inum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;get(parent, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有这个文件</span></span><br><span class="line">  <span class="keyword">if</span>((pos = data.find(file_name)) == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> NOENT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  end = data.find_first_of(<span class="string">"/"</span>, pos+file_name.size());</span><br><span class="line">  <span class="keyword">if</span>(end == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> NOENT;</span><br><span class="line">  &#125;</span><br><span class="line">  len = end - file_name.size() - pos;</span><br><span class="line">  inum = n2i(data.substr(pos+file_name.size(), len));</span><br><span class="line">  <span class="keyword">if</span>(!isfile(inum))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从目录中移除文件</span></span><br><span class="line">  data.erase(pos, end-pos+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;put(parent, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除文件</span></span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;remove(inum) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 fuse 中对应如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_mkdir(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> parent, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">     <span class="keyword">mode_t</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fuse_entry_param</span> <span class="title">e</span>;</span></span><br><span class="line">  <span class="comment">// In yfs, timeouts are always set to 0.0, and generations are always set to 0</span></span><br><span class="line">  e.attr_timeout = <span class="number">0.0</span>;</span><br><span class="line">  e.entry_timeout = <span class="number">0.0</span>;</span><br><span class="line">  e.generation = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Suppress compiler warning of unused e.</span></span><br><span class="line">  (<span class="keyword">void</span>) e;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">  yfs_client::inum inum = <span class="number">0</span>;</span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  ret = yfs-&gt;mkdir(parent, name, mode, inum);</span><br><span class="line">  <span class="keyword">if</span>(ret == yfs_client::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    e.ino = inum;</span><br><span class="line">    getattr(inum, e.attr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ret == yfs_client::EXIST)</span><br><span class="line">  &#123;</span><br><span class="line">    fuse_reply_err(req, EEXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fuse_reply_entry(req, &amp;e);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  fuse_reply_err(req, ENOSYS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the file named @name from directory @parent.</span></span><br><span class="line"><span class="comment">// Free the file's extent.</span></span><br><span class="line"><span class="comment">// If the file doesn't exist, indicate error ENOENT.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do *not* allow unlinking of a directory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_unlink(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> parent, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You fill this in for Lab 3</span></span><br><span class="line">  <span class="comment">// Success:fuse_reply_err(req, 0);</span></span><br><span class="line">  <span class="comment">// Not found:fuse_reply_err(req, ENOENT);</span></span><br><span class="line">  yfs_client::status ret = yfs-&gt;unlink(parent, name);</span><br><span class="line">  <span class="keyword">if</span>(ret == yfs_client::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    fuse_reply_err(req, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fuse_reply_err(req, ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><ul><li><p>What to lock?</p><p>At one extreme you could have a single lock for the whole file system, so that operations never proceed in parallel. At the other extreme you could lock each entry in a directory, or each field in the attributes structure. Neither of these is a good idea! A single global lock prevents concurrency that would have been okay, for example CREATEs in different directories. Fine-grained locks have high overhead and make deadlock likely, since you often need to hold more than one fine-grained lock.</p><p>You should associate a lock with each inumber. Use the file or directory’s <code>inum</code> as the name of the lock (i.e. pass the <code>inum</code> to <code>acquire</code> and <code>release</code>). The convention should be that any <code>yfs_client</code> operation should acquire the lock on the file or directory it uses, perform the operation, finish updating the extent server (if the operation has side-effects), and then release the lock on the <code>inum</code>. Be careful to release locks even for error returns from <code>yfs_client</code> operations.</p><p>You’ll use your lock server from Lab 1. <code>yfs_client</code> should create and use a <code>lock_client</code> in the same way that it creates and uses its <code>extent_client</code>.</p></li><li><p>Things to watch out for:</p><p>This is the first lab that creates files using two different YFS-mounted directories. If you were not careful in earlier labs, you may find that the components that assign <code>inum</code> for newly-created files and directories choose the same identifiers. One possible way to fix this may be to seed the random number generator differently depending on the process’s <code>pid</code>. The provided code has already done such seeding for you in the <code>main</code> function of <code>fuse.cc</code>.</p><p>This is also the first lab that writes null (‘\0’) characters to files. The <code>std::string(char*)</code> constructor treats ‘\0’ as the end of the string, so if you use that constructor to hold file content or the written data, you will have trouble with this lab. Use the <code>std::string(buf, size)</code> constructor instead..</p></li></ul><p>需要对之前的 yfs_client 进行修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yfs_client</span> &#123;</span></span><br><span class="line">  extent_client *ec;</span><br><span class="line">  lock_client *m_lc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>并且添加 lockGuard 类，实现 RAII，并且在 yfs_client 中需要加锁的地方添加 lockGuard。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockGuard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  LockGuard(lock_client *lc, lock_protocol::<span class="keyword">lockid_t</span> lid) : m_lc(lc), m_lid(lid)</span><br><span class="line">  &#123;</span><br><span class="line">    m_lc-&gt;acquire(m_lid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~LockGuard()</span><br><span class="line">  &#123;</span><br><span class="line">    m_lc-&gt;release(m_lid);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  lock_client *m_lc;</span><br><span class="line">  lock_protocol::<span class="keyword">lockid_t</span> m_lid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://pdos.csail.mit.edu/archive/6.824-2012/labs/lab-3.html" target="_blank" rel="noopener">6.824 lab3</a></li><li><a href="https://liu-jianhao.github.io/2018/12/yfs%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">yfs实现第二步——实现基本文件服务</a></li><li><a href="https://github.com/liu-jianhao/yfsCpp11/tree/master/lab3" target="_blank" rel="noopener">yfsCpp11s</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> yfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ yfs 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yfs-源码剖析（2）--基本文件服务1</title>
      <link href="/2020/10/27/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/10/27/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>extent_server 用于存储文件系统所有的数据，有多个客户端与 extent_server 进行通信。</p><p>为了实现 extent_server 就需要实现 extent_protocol, extent_client 和 extent_server。 通信流程和之前的锁服务类似。</p><h2 id="extent-protocol"><a href="#extent-protocol" class="headerlink" title="extent_protocol"></a>extent_protocol</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extent wire protocol</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> extent_protocol_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> extent_protocol_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extent_protocol</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">extentid_t</span>;</span><br><span class="line">  <span class="keyword">enum</span> xxstatus &#123; OK, RPCERR, NOENT, IOERR &#125;;</span><br><span class="line">  <span class="keyword">enum</span> rpc_numbers &#123;</span><br><span class="line">    put = <span class="number">0x6001</span>,</span><br><span class="line">    get,</span><br><span class="line">    getattr,</span><br><span class="line">    remove</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> atime;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mtime;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ctime;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> unmarshall &amp;</span><br><span class="line"><span class="keyword">operator</span>&gt;&gt;(unmarshall &amp;u, extent_protocol::attr &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">  u &gt;&gt; a.atime;</span><br><span class="line">  u &gt;&gt; a.mtime;</span><br><span class="line">  u &gt;&gt; a.ctime;</span><br><span class="line">  u &gt;&gt; a.size;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> marshall &amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(marshall &amp;m, extent_protocol::attr a)</span><br><span class="line">&#123;</span><br><span class="line">  m &lt;&lt; a.atime;</span><br><span class="line">  m &lt;&lt; a.mtime;</span><br><span class="line">  m &lt;&lt; a.ctime;</span><br><span class="line">  m &lt;&lt; a.size;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="extent-client"><a href="#extent-client" class="headerlink" title="extent_client"></a>extent_client</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extent client interface.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> extent_client_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> extent_client_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extent_protocol.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extent_client</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  rpcc *cl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  extent_client(<span class="built_in">std</span>::<span class="built_in">string</span> dst);</span><br><span class="line"></span><br><span class="line">  extent_protocol::<span class="function">status <span class="title">get</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> eid, </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf)</span></span>;</span><br><span class="line">  extent_protocol::<span class="function">status <span class="title">getattr</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> eid, </span></span></span><br><span class="line"><span class="function"><span class="params">  extent_protocol::attr &amp;a)</span></span>;</span><br><span class="line">  extent_protocol::<span class="function">status <span class="title">put</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> eid, <span class="built_in">std</span>::<span class="built_in">string</span> buf)</span></span>;</span><br><span class="line">  extent_protocol::<span class="function">status <span class="title">remove</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> eid)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RPC stubs for clients to talk to extent_server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extent_client.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The calls assume that the caller holds a lock on the extent</span></span><br><span class="line"></span><br><span class="line">extent_client::extent_client(<span class="built_in">std</span>::<span class="built_in">string</span> dst)</span><br><span class="line">&#123;</span><br><span class="line">  sockaddr_in dstsock;</span><br><span class="line">  make_sockaddr(dst.c_str(), &amp;dstsock);</span><br><span class="line">  cl = <span class="keyword">new</span> rpcc(dstsock);</span><br><span class="line">  <span class="keyword">if</span> (cl-&gt;bind() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"extent_client: bind failed\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extent_protocol::status</span><br><span class="line">extent_client::get(extent_protocol::<span class="keyword">extentid_t</span> eid, <span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf)</span><br><span class="line">&#123;</span><br><span class="line">  extent_protocol::status ret = extent_protocol::OK;</span><br><span class="line">  ret = cl-&gt;call(extent_protocol::get, eid, buf);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extent_protocol::status</span><br><span class="line">extent_client::getattr(extent_protocol::<span class="keyword">extentid_t</span> eid, </span><br><span class="line">       extent_protocol::attr &amp;attr)</span><br><span class="line">&#123;</span><br><span class="line">  extent_protocol::status ret = extent_protocol::OK;</span><br><span class="line">  ret = cl-&gt;call(extent_protocol::getattr, eid, attr);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extent_protocol::status</span><br><span class="line">extent_client::put(extent_protocol::<span class="keyword">extentid_t</span> eid, <span class="built_in">std</span>::<span class="built_in">string</span> buf)</span><br><span class="line">&#123;</span><br><span class="line">  extent_protocol::status ret = extent_protocol::OK;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  ret = cl-&gt;call(extent_protocol::put, eid, buf, r);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extent_protocol::status</span><br><span class="line">extent_client::remove(extent_protocol::<span class="keyword">extentid_t</span> eid)</span><br><span class="line">&#123;</span><br><span class="line">  extent_protocol::status ret = extent_protocol::OK;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  ret = cl-&gt;call(extent_protocol::remove, eid, r);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都是套路代码 为了 rpc。。。</span></span><br></pre></td></tr></table></figure><p>重点在于下面的 extent_server</p><h2 id="extent-server"><a href="#extent-server" class="headerlink" title="extent_server"></a>extent_server</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> extent_server_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> extent_server_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extent_protocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">extent</span> &#123;</span></span><br><span class="line">  <span class="comment">// 数据</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">  <span class="comment">// 数据属性</span></span><br><span class="line">  extent_protocol::attr attr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extent_server</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  extent_server();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">put</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> id, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getattr</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> id, extent_protocol::attr &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(extent_protocol::<span class="keyword">extentid_t</span> id, <span class="keyword">int</span> &amp;)</span></span>;  <span class="comment">// 对应 client 的 stub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;extent_protocol::<span class="keyword">extentid_t</span>, extent&gt; m_dataMap;  <span class="comment">// 暂时类似 kv-store</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the extent server implementation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extent_server.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">extent_server::extent_server()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  put(<span class="number">1</span>, <span class="string">""</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> extent_server::put(extent_protocol::<span class="keyword">extentid_t</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> buf, <span class="keyword">int</span> &amp;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// You fill this in for Lab 2.</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m_mutex);</span><br><span class="line"></span><br><span class="line">  extent_protocol::attr attr;</span><br><span class="line">  attr.atime = attr.mtime = attr.ctime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(m_dataMap.find(id) != m_dataMap.end())</span><br><span class="line">  &#123;</span><br><span class="line">    attr.atime = m_dataMap[id].attr.atime;</span><br><span class="line">  &#125;</span><br><span class="line">  attr.size = buf.size();</span><br><span class="line">  m_dataMap[id].data = buf;</span><br><span class="line">  m_dataMap[id].attr = attr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> extent_protocol::OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> extent_server::get(extent_protocol::<span class="keyword">extentid_t</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// You fill this in for Lab 2.</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(m_dataMap.find(id) != m_dataMap.end())</span><br><span class="line">  &#123;</span><br><span class="line">    m_dataMap[id].attr.atime = time(<span class="literal">NULL</span>);</span><br><span class="line">    buf = m_dataMap[id].data;</span><br><span class="line">    <span class="keyword">return</span> extent_protocol::OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> extent_protocol::NOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> extent_server::getattr(extent_protocol::<span class="keyword">extentid_t</span> id, extent_protocol::attr &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// You fill this in for Lab 2.</span></span><br><span class="line">  <span class="comment">// You replace this with a real implementation. We send a phony response</span></span><br><span class="line">  <span class="comment">// for now because it's difficult to get FUSE to do anything (including</span></span><br><span class="line">  <span class="comment">// unmount) if getattr fails.</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(m_dataMap.find(id) != m_dataMap.end())</span><br><span class="line">  &#123;</span><br><span class="line">    a = m_dataMap[id].attr;</span><br><span class="line">    <span class="keyword">return</span> extent_protocol::OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> extent_protocol::NOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> extent_server::remove(extent_protocol::<span class="keyword">extentid_t</span> id, <span class="keyword">int</span> &amp;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// You fill this in for Lab 2.</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = m_dataMap.find(id); </span><br><span class="line">  <span class="keyword">if</span>(it != m_dataMap.end())</span><br><span class="line">  &#123;</span><br><span class="line">    m_dataMap.erase(it);</span><br><span class="line">    <span class="keyword">return</span> extent_protocol::OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> extent_protocol::NOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些需要线程安全的 map 操作， 用 lock_guard 锁住全局</span></span><br></pre></td></tr></table></figure><h2 id="yfs-client"><a href="#yfs-client" class="headerlink" title="yfs_client"></a>yfs_client</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> yfs_client_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yfs_client_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//#include "yfs_protocol.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extent_client.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个文件和目录都有一个唯一的 inum</span></span><br><span class="line"><span class="comment">// FUSE 假定根目录的 inum 是 0x00000001。因此，需要确保在 yfs_client 启动时，它已准备好导出存储在该inum 下的空目录。</span></span><br><span class="line"><span class="comment">// 在创建一个新的文件或者目录的时候，必须要给它配置一个唯一的 inum， 这个 inum 可以随机生成（但是如果文件量变大，会产生 collision</span></span><br><span class="line"><span class="comment">// YFS needs to be able to tell whether a particular inum refers to a file or a directory. Do this by allocating IDs with the 31st bit of one for new files, and IDs with the 31st bit of zero for new directories. The method yfs_client::isfile assumes this property holds for inum.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yfs_client</span> &#123;</span></span><br><span class="line">  extent_client *ec;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inum;</span><br><span class="line">  <span class="keyword">enum</span> xxstatus &#123; OK, RPCERR, NOENT, IOERR, EXIST &#125;;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fileinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> atime;  <span class="comment">// 访问时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mtime;  <span class="comment">// 修改时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctime;  <span class="comment">// 变化时间</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> atime;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mtime;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctime;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    yfs_client::inum inum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">filename</span><span class="params">(inum)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> inum <span class="title">n2i</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>)</span></span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  yfs_client(<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isfile</span><span class="params">(inum)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isdir</span><span class="params">(inum)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getfile</span><span class="params">(inum, fileinfo &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getdir</span><span class="params">(inum, dirinfo &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">  yfs_client::<span class="function">inum <span class="title">random_inum</span><span class="params">(<span class="keyword">bool</span> isfile)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(inum, <span class="keyword">const</span> <span class="keyword">char</span>*, inum&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(inum, <span class="keyword">const</span> <span class="keyword">char</span>*, inum&amp;, <span class="keyword">bool</span>*)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">readdir</span><span class="params">(inum, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;dirent&gt;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">setattr</span><span class="params">(inum, struct stat*)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(inum, <span class="keyword">off_t</span>, <span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(inum, <span class="keyword">off_t</span>, <span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">yfs_client::yfs_client(<span class="built_in">std</span>::<span class="built_in">string</span> extent_dst, <span class="built_in">std</span>::<span class="built_in">string</span> lock_dst)</span><br><span class="line">&#123;</span><br><span class="line">  ec = <span class="keyword">new</span> extent_client(extent_dst);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//  string 转成 64-bit 的 inum </span></span><br><span class="line">yfs_client::inum</span><br><span class="line">yfs_client::n2i(<span class="built_in">std</span>::<span class="built_in">string</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">ist</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> finum;</span><br><span class="line">  ist &gt;&gt; finum;</span><br><span class="line">  <span class="keyword">return</span> finum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 64-bit inum 转成 string 类型的文件名</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span></span><br><span class="line">yfs_client::filename(inum inum)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ost;</span><br><span class="line">  ost &lt;&lt; inum;</span><br><span class="line">  <span class="keyword">return</span> ost.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// YFS needs to be able to tell whether a particular inum refers to a file or a directory. Do this by allocating IDs with the 31st bit of one for new files, and IDs with the 31st bit of zero for new directories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 31st bits 来判断是否为文件</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">yfs_client::isfile(inum inum)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(inum &amp; <span class="number">0x80000000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">yfs_client::isdir(inum inum)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ! isfile(inum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::getfile(inum inum, fileinfo &amp;fin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r = OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"getfile %016llx\n"</span>, inum);</span><br><span class="line">  extent_protocol::attr a;</span><br><span class="line">  <span class="keyword">if</span> (ec-&gt;getattr(inum, a) != extent_protocol::OK) &#123;</span><br><span class="line">    r = IOERR;</span><br><span class="line">    <span class="keyword">goto</span> release;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fin.atime = a.atime;</span><br><span class="line">  fin.mtime = a.mtime;</span><br><span class="line">  fin.ctime = a.ctime;</span><br><span class="line">  fin.size = a.size;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"getfile %016llx -&gt; sz %llu\n"</span>, inum, fin.size);</span><br><span class="line"></span><br><span class="line">  release:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::getdir(inum inum, dirinfo &amp;din)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r = OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"getdir %016llx\n"</span>, inum);</span><br><span class="line">  extent_protocol::attr a;</span><br><span class="line">  <span class="keyword">if</span> (ec-&gt;getattr(inum, a) != extent_protocol::OK) &#123;</span><br><span class="line">    r = IOERR;</span><br><span class="line">    <span class="keyword">goto</span> release;</span><br><span class="line">  &#125;</span><br><span class="line">  din.atime = a.atime;</span><br><span class="line">  din.mtime = a.mtime;</span><br><span class="line">  din.ctime = a.ctime;</span><br><span class="line"></span><br><span class="line"> release:</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成 inum</span></span><br><span class="line">yfs_client::inum</span><br><span class="line">yfs_client::random_inum(<span class="keyword">bool</span> isfile)</span><br><span class="line">&#123;</span><br><span class="line">  inum ret = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)((rand() &amp; <span class="number">0x7fffffff</span>) | (isfile &lt;&lt; <span class="number">31</span>));</span><br><span class="line">  ret = <span class="number">0xffffffff</span> &amp; ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::create(inum parent, <span class="keyword">const</span> <span class="keyword">char</span>* name, inum&amp; inum)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> file_name;</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;get(parent, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file_name = <span class="string">"/"</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(name) + <span class="string">"/"</span>;</span><br><span class="line">  <span class="comment">// 文件已经存在</span></span><br><span class="line">  <span class="keyword">if</span> (data.find(file_name) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> EXIST;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inum = random_inum(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;put(inum, <span class="built_in">std</span>::<span class="built_in">string</span>()) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data.append(file_name + filename(inum) + <span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;put(parent, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::lookup(inum parent, <span class="keyword">const</span> <span class="keyword">char</span>* name, inum&amp; inum, <span class="keyword">bool</span>* found)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> pos, end;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data, file_name, ino;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;get(parent, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file_name = <span class="string">"/"</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(name) + <span class="string">"/"</span>;</span><br><span class="line">  pos = data.find(file_name);</span><br><span class="line">  <span class="keyword">if</span>(pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    *found = <span class="literal">true</span>;</span><br><span class="line">    pos += file_name.size();</span><br><span class="line">    end = data.find_first_of(<span class="string">"/"</span>, pos);</span><br><span class="line">    <span class="keyword">if</span>(end != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">      ino = data.substr(pos, end - pos);</span><br><span class="line">      inum = n2i(ino.c_str()); <span class="comment">// 获得 inum</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> IOERR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::readdir(inum inum, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;dirent&gt; &amp; dirents)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data, inum_str;</span><br><span class="line">  <span class="keyword">size_t</span> pos, name_end, name_len, inum_end, inum_len;</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;get(inum, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pos != data.size())</span><br><span class="line">  &#123;</span><br><span class="line">    dirent d;</span><br><span class="line">    pos = data.find(<span class="string">"/"</span>, pos);</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name_end = data.find_first_of(<span class="string">"/"</span>, pos+<span class="number">1</span>);</span><br><span class="line">    name_len = name_end - pos - <span class="number">1</span>;</span><br><span class="line">    d.name = data.substr(pos+<span class="number">1</span>, name_len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    inum_end = data.find_first_of(<span class="string">"/"</span>, name_end + <span class="number">1</span>);</span><br><span class="line">    inum_len = inum_end - inum_end - <span class="number">1</span>;</span><br><span class="line">    inum_str = data.substr(name_end+<span class="number">1</span>, inum_len);</span><br><span class="line"></span><br><span class="line">    d.inum = n2i(inum_str.c_str());</span><br><span class="line">    dirents.push_back(d);</span><br><span class="line">    pos = inum_end + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::setattr(inum inum, struct stat* attr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size = attr-&gt;st_size;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;get(inum, buf) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.resize(size, <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;put(inum, buf) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::read(inum inum, <span class="keyword">off_t</span> off, <span class="keyword">size_t</span> size, <span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">  <span class="keyword">size_t</span> read_size;</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;get(inum, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt;= data.size())  <span class="comment">// 起始 offset 超过范围 直接返回空</span></span><br><span class="line">  &#123;</span><br><span class="line">    buf = <span class="built_in">std</span>::<span class="built_in">string</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  read_size = size;</span><br><span class="line">  <span class="keyword">if</span>(off + size &gt; data.size())</span><br><span class="line">  &#123;</span><br><span class="line">    read_size = data.size() - off;</span><br><span class="line">  &#125;  <span class="comment">// 超过范围 截断</span></span><br><span class="line">  buf = data.substr(off, read_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yfs_client::write(inum inum, <span class="keyword">off_t</span> off, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;get(inum, data) != extent_protocol::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size + off &gt; data.size())  <span class="comment">// 扩容</span></span><br><span class="line">  &#123;</span><br><span class="line">    data.resize(size + off, <span class="string">'\0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    data[off+i] = buf[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ec-&gt;put(inum, data) != extent_protocol::OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fuse"><a href="#fuse" class="headerlink" title="fuse"></a>fuse</h2><p>fuse.cc</p><p>receive request from fuse and call methods of yfs_client。</p><p>When a program (such as <code>ls</code> or a test script) manipulates a file or directory (such as <code>yfs1</code>) served by your <code>yfs_client</code>, the FUSE code in the kernel sends corresponding operations to <code>yfs_client</code> via FUSE. The code we provide you in <code>fuse.cc</code>responds to each such operation by calling one of a number of procedures, for create, read, write, etc. operations. You should modify the relevant routines in <code>fuse.cc</code> to call methods in <code>yfs_client.cc</code>. <code>fuse.cc</code> should just contain glue code, and the core of your file system logic should be in <code>yfs_client.cc</code>. For example, to handle file creation, you should modify <code>fuseserver_createhelper</code> to call <code>yfs-&gt;create(...)</code>, and you should add a new <code>create(...)</code> method to <code>yfs_client.cc</code>. Look at <code>getattr()</code> in <code>fuse.cc</code> for an example of how a fuse operation handler works, how it calls methods in <code>yfs_client</code>, and how it sends results and errors back to the kernel. YFS uses FUSE’s “lowlevel” API.</p><p>我把 fuse.cc 当作 yfs_client 的 wrapper。</p><h4 id="Attr"><a href="#Attr" class="headerlink" title="Attr"></a>Attr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">yfs_client::status</span><br><span class="line">getattr(yfs_client::inum inum, struct stat &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">  yfs_client::status ret;</span><br><span class="line"></span><br><span class="line">  bzero(&amp;st, <span class="keyword">sizeof</span>(st));</span><br><span class="line"></span><br><span class="line">  st.st_ino = inum;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"getattr %016llx %d\n"</span>, inum, yfs-&gt;isfile(inum));</span><br><span class="line">  <span class="keyword">if</span>(yfs-&gt;isfile(inum))&#123;  <span class="comment">// file </span></span><br><span class="line">     yfs_client::fileinfo info;</span><br><span class="line">     ret = yfs-&gt;getfile(inum, info);</span><br><span class="line">     <span class="keyword">if</span>(ret != yfs_client::OK)</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">     st.st_mode = S_IFREG | <span class="number">0666</span>;  <span class="comment">// regular 普通文件 可读可写不可执行</span></span><br><span class="line">     st.st_nlink = <span class="number">1</span>;  <span class="comment">// 链接计数</span></span><br><span class="line">     st.st_atime = info.atime;</span><br><span class="line">     st.st_mtime = info.mtime;</span><br><span class="line">     st.st_ctime = info.ctime;</span><br><span class="line">     st.st_size = info.size;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"   getattr -&gt; %llu\n"</span>, info.size);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// dir</span></span><br><span class="line">     yfs_client::dirinfo info;</span><br><span class="line">     ret = yfs-&gt;getdir(inum, info);</span><br><span class="line">     <span class="keyword">if</span>(ret != yfs_client::OK)</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">     st.st_mode = S_IFDIR | <span class="number">0777</span>;</span><br><span class="line">     st.st_nlink = <span class="number">2</span>;</span><br><span class="line">     st.st_atime = info.atime;</span><br><span class="line">     st.st_mtime = info.mtime;</span><br><span class="line">     st.st_ctime = info.ctime;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"   getattr -&gt; %lu %lu %lu\n"</span>, info.atime, info.mtime, info.ctime);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> yfs_client::OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>struct stat</code></li><li><code>{</code></li><li><code>mode_t st_mode;/* file type &amp; mode (permissions) */</code></li><li><code>ino_t    st_ino;/* i-node number (serial number) */</code></li><li><code>dev_t    st_dev;/* device number (file system) */</code></li><li><code>dev_t    st_rdev;/* device number for special files */</code></li><li><code>nlink_t    st_nlink;/* number of links */</code></li><li><code>uid_t    st_uid;/* user ID of owner */</code></li><li><code>gid_t    st_gid;/* group ID of owner */</code></li><li><code>off_t    st_size;/* size in bytes, for regular files */</code></li><li><code>struct timespec    st_atim;/* time of last access */</code></li><li><code>struct timespec    st_mtim;/* time of last modification */</code></li><li><code>struct timespec    st_ctim;/* time of last file status change */</code></li><li><code>blksize_t    st_blksize;/* best I/O block size */</code></li><li><code>blkcnt_t    st_blocks;/* number of disk blocks allocated */</code></li><li><code>};</code></li></ol></blockquote><p>一个操作对应着一个 handler，下面是 getattr 的 handler。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The @ino argument indicates the file or directory FUSE wants</span></span><br><span class="line"><span class="comment">// you to operate on. It's a 32-bit FUSE identifier; just assign</span></span><br><span class="line"><span class="comment">// it to a yfs_client::inum to get a 64-bit YFS inum.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_getattr(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> ino,</span><br><span class="line">          struct fuse_file_info *fi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    yfs_client::inum inum = ino; <span class="comment">// req-&gt;in.h.nodeid;</span></span><br><span class="line">    yfs_client::status ret;</span><br><span class="line"></span><br><span class="line">    ret = getattr(inum, st);</span><br><span class="line">    <span class="keyword">if</span>(ret != yfs_client::OK)&#123;</span><br><span class="line">      fuse_reply_err(req, ENOENT);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fuse_reply_attr(req, &amp;st, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果发生错误，需调用 fuse_reply_err(req, errno). 成功的话就调用 fuse_reply_xx(req, …)</p><p>相应地，可以 setAttr，具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_setattr(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> ino, struct stat *attr, <span class="keyword">int</span> to_set, struct fuse_file_info *fi)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"fuseserver_setattr 0x%x\n"</span>, to_set);</span><br><span class="line">  <span class="keyword">if</span> (FUSE_SET_ATTR_SIZE &amp; to_set) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   fuseserver_setattr set size to %zu\n"</span>, attr-&gt;st_size);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// fill st using getattr before fuse_reply_attr</span></span><br><span class="line">    yfs_client::inum inum = ino;</span><br><span class="line">    yfs_client::status ret;</span><br><span class="line"></span><br><span class="line">    ret = yfs-&gt;setattr(inum, attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != yfs_client::OK)</span><br><span class="line">    &#123;</span><br><span class="line">      fuse_reply_err(req, ENOENT);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = getattr(inum, st);</span><br><span class="line">    <span class="keyword">if</span>(ret != yfs_client::OK)&#123;</span><br><span class="line">      fuse_reply_err(req, ENOENT);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fuse_reply_attr(req, &amp;st, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    fuse_reply_err(req, ENOSYS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fuse_reply_err(req, ENOSYS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_read(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> ino, <span class="keyword">size_t</span> size,</span><br><span class="line">      <span class="keyword">off_t</span> off, struct fuse_file_info *fi)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">  yfs_client::inum inum = ino;</span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  ret = yfs-&gt;read(inum, off, size, buf);</span><br><span class="line">  <span class="keyword">if</span>(ret != yfs_client::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    fuse_reply_err(req, ENOENT);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fuse_reply_buf(req, buf.data(), buf.size());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  fuse_reply_err(req, ENOSYS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_write(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> ino,</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">off_t</span> off,</span><br><span class="line">  struct fuse_file_info *fi)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">  yfs_client::inum inum = ino;</span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  ret = yfs-&gt;write(inum, off, size, buf);</span><br><span class="line">  <span class="keyword">if</span>(ret != yfs_client::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    fuse_reply_err(req, ENOENT);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fuse_reply_write(req, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  fuse_reply_err(req, ENOSYS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create-file-dir"><a href="#create-file-dir" class="headerlink" title="create file / dir"></a>create file / dir</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 parent 目录下创建名为 name 的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// - @mode specifies the create mode of the file. Ignore it - you do not</span></span><br><span class="line"><span class="comment">//   have to implement file mode.</span></span><br><span class="line"><span class="comment">// - If a file named @name already exists in @parent, return EXIST.</span></span><br><span class="line"><span class="comment">// - Pick an ino (with type of yfs_client::inum) for file @name. </span></span><br><span class="line"><span class="comment">//   Make sure ino indicates a file, not a directory!</span></span><br><span class="line"><span class="comment">// - Create an empty extent for ino.</span></span><br><span class="line"><span class="comment">// - Add a &lt;name, ino&gt; entry into @parent.</span></span><br><span class="line"><span class="comment">// - On success, store the inum of newly created file into @e-&gt;ino, </span></span><br><span class="line"><span class="comment">//   and the new file's attribute into @e-&gt;attr. Get the file's</span></span><br><span class="line"><span class="comment">//   attributes with getattr().</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// @return yfs_client::OK on success, and EXIST if @name already exists.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">yfs_client::status</span><br><span class="line">fuseserver_createhelper(<span class="keyword">fuse_ino_t</span> parent, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">     <span class="keyword">mode_t</span> mode, struct fuse_entry_param *e)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// In yfs, timeouts are always set to 0.0, and generations are always set to 0</span></span><br><span class="line">  e-&gt;attr_timeout = <span class="number">0.0</span>;</span><br><span class="line">  e-&gt;entry_timeout = <span class="number">0.0</span>;</span><br><span class="line">  e-&gt;generation = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  yfs_client::inum inum = <span class="number">0</span>;</span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  ret = yfs-&gt;create(parent, name, inum);</span><br><span class="line">  <span class="keyword">if</span>(ret == yfs_client::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    e-&gt;ino = inum;</span><br><span class="line">    getattr(inum, e-&gt;attr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// wrap 了一下上面的 helper</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_create(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> parent, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">   <span class="keyword">mode_t</span> mode, struct fuse_file_info *fi)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fuse_entry_param</span> <span class="title">e</span>;</span></span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  <span class="keyword">if</span>( (ret = fuseserver_createhelper( parent, name, mode, &amp;e )) == yfs_client::OK ) &#123;</span><br><span class="line">    fuse_reply_create(req, &amp;e, fi);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == yfs_client::EXIST) &#123;</span><br><span class="line">fuse_reply_err(req, EEXIST);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fuse_reply_err(req, ENOENT);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mknod 创建块设备或者字符设备文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuseserver_mknod</span><span class="params">( <span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> parent, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">mode_t</span> mode, <span class="keyword">dev_t</span> rdev )</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fuse_entry_param</span> <span class="title">e</span>;</span></span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  <span class="keyword">if</span>( (ret = fuseserver_createhelper( parent, name, mode, &amp;e )) == yfs_client::OK ) &#123;</span><br><span class="line">    fuse_reply_entry(req, &amp;e);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == yfs_client::EXIST) &#123;</span><br><span class="line">fuse_reply_err(req, EEXIST);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fuse_reply_err(req, ENOENT);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h4><p>在 parent 文件夹下寻找文件或者文件夹，如果能够找到名为 name 的文件或文件夹，更改 e.attr 和 e.ino.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_lookup(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> parent, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fuse_entry_param</span> <span class="title">e</span>;</span></span><br><span class="line">  <span class="comment">// In yfs, timeouts are always set to 0.0, and generations are always set to 0</span></span><br><span class="line">  e.attr_timeout = <span class="number">0.0</span>;</span><br><span class="line">  e.entry_timeout = <span class="number">0.0</span>;</span><br><span class="line">  e.generation = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  yfs_client::inum inum;</span><br><span class="line">  ret = yfs-&gt;lookup(parent, name, inum, &amp;found);</span><br><span class="line">  <span class="keyword">if</span>(ret == yfs_client::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    e.ino = inum;</span><br><span class="line">    getattr(e.ino, e.attr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (found)</span><br><span class="line">    fuse_reply_entry(req, &amp;e);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fuse_reply_err(req, ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h4><p>获取一个目录下所有的目录项</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send the reply using reply_buf_limited.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Call dirbuf_add(&amp;b, name, inum) for each entry in the directory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fuseserver_readdir(<span class="keyword">fuse_req_t</span> req, <span class="keyword">fuse_ino_t</span> ino, <span class="keyword">size_t</span> size,</span><br><span class="line">          <span class="keyword">off_t</span> off, struct fuse_file_info *fi)</span><br><span class="line">&#123;</span><br><span class="line">  yfs_client::inum inum = ino; <span class="comment">// req-&gt;in.h.nodeid;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirbuf</span> <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"fuseserver_readdir\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!yfs-&gt;isdir(inum))&#123;</span><br><span class="line">    fuse_reply_err(req, ENOTDIR);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You fill this in for Lab 2</span></span><br><span class="line">  yfs_client::status ret;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;yfs_client::dirent&gt; dirents;</span><br><span class="line">  ret = yfs-&gt;readdir(inum, dirents);</span><br><span class="line">  <span class="keyword">if</span>(ret != yfs_client::OK)</span><br><span class="line">  &#123;</span><br><span class="line">    fuse_reply_err(req, ENOENT);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = dirents.begin(); it != dirents.end(); ++it)</span><br><span class="line">  &#123;</span><br><span class="line">    dirbuf_add(&amp;b, it-&gt;name.c_str(), it-&gt;inum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  reply_buf_limited(req, b.p, b.size, off, size);</span><br><span class="line">  <span class="built_in">free</span>(b.p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 dirbuf 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dirbuf_add</span><span class="params">(struct dirbuf *b, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">fuse_ino_t</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stbuf</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize = b-&gt;size;</span><br><span class="line">    b-&gt;size += fuse_dirent_size(<span class="built_in">strlen</span>(name));</span><br><span class="line">    b-&gt;p = (<span class="keyword">char</span> *) <span class="built_in">realloc</span>(b-&gt;p, b-&gt;size);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(stbuf));</span><br><span class="line">    stbuf.st_ino = ino;</span><br><span class="line">    fuse_add_dirent(b-&gt;p + oldsize, name, &amp;stbuf, b-&gt;size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 reply_buf_limited 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reply_buf_limited</span><span class="params">(<span class="keyword">fuse_req_t</span> req, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsize,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">off_t</span> off, <span class="keyword">size_t</span> maxsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">size_t</span>)off &lt; bufsize)</span><br><span class="line">    <span class="keyword">return</span> fuse_reply_buf(req, buf + off, min(bufsize - off, maxsize));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> fuse_reply_buf(req, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/liu-jianhao/yfsCpp11" target="_blank" rel="noopener">yfsCpp11</a></li><li><a href="https://liu-jianhao.github.io/2018/12/yfs%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">yfs实现第二步实现基本文件服务</a></li><li><a href="https://www.cnblogs.com/fireway/p/5990572.html" target="_blank" rel="noopener">硬链接和软链接</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> yfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 分布式 yfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yfs-源码剖析（1）--锁服务</title>
      <link href="/2020/10/27/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89-%E9%94%81%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/10/27/yfs-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89-%E9%94%81%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>yfs 需要一个锁服务来协调文件系统结构的更新。</p><p>其中包括两个模块，分别是锁客户端和锁服务器。</p><p>他们之间的 RPC 交互流程如下：</p><ol><li>客户端发送请求从锁服务器请求锁。</li><li>锁服务器在一个时间点只能向一个客户端发送锁。</li><li>客户端不需要锁的时候，会向服务器发送释放请求。</li><li>释放锁后，服务端会把锁给其他正在请求的客户端。</li></ol><h2 id="lock-protocol-h"><a href="#lock-protocol-h" class="headerlink" title="lock_protocol.h"></a>lock_protocol.h</h2><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> lock_status &#123;FREE, LOCKED&#125;;</span><br><span class="line">  <span class="comment">// 用这个来标识每个锁</span></span><br><span class="line">  lock_protocol::<span class="keyword">lockid_t</span> m_lid;</span><br><span class="line">  <span class="comment">// FREE or LOCKED</span></span><br><span class="line">  <span class="keyword">int</span> m_state;</span><br><span class="line">  <span class="comment">// 条件变量</span></span><br><span class="line">  <span class="built_in">std</span>::condition_variable m_cv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  lock(lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> state);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock::lock(lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> state) : m_lid(lid), m_state(state)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lock-protocol"><a href="#lock-protocol" class="headerlink" title="lock_protocol"></a>lock_protocol</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_protocol</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> xxstatus &#123; OK, RETRY, RPCERR, NOENT, IOERR &#125;;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">lockid_t</span>;</span><br><span class="line">  <span class="keyword">enum</span> rpc_numbers &#123;</span><br><span class="line">    acquire = <span class="number">0x7001</span>,</span><br><span class="line">    release,</span><br><span class="line">    stat</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lock-client"><a href="#lock-client" class="headerlink" title="lock_client"></a>lock_client</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_client</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  rpcc *cl;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  lock_client(<span class="built_in">std</span>::<span class="built_in">string</span> d);</span><br><span class="line">  <span class="keyword">virtual</span> ~lock_client() &#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> lock_protocol::<span class="function">status <span class="title">acquire</span><span class="params">(lock_protocol::<span class="keyword">lockid_t</span>)</span></span>;  <span class="comment">// 获得锁的接口</span></span><br><span class="line">  <span class="keyword">virtual</span> lock_protocol::<span class="function">status <span class="title">release</span><span class="params">(lock_protocol::<span class="keyword">lockid_t</span>)</span></span>;  <span class="comment">// 释放锁的接口</span></span><br><span class="line">  <span class="keyword">virtual</span> lock_protocol::<span class="function">status <span class="title">stat</span><span class="params">(lock_protocol::<span class="keyword">lockid_t</span>)</span></span>;     <span class="comment">// 获得 status 的接口</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 lock_client 类发送 RPC 至 lock_server, 以获取来自 lock_server 的响应。</p><p>lock_client 的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">lock_client::lock_client(<span class="built_in">std</span>::<span class="built_in">string</span> dst)  <span class="comment">// rpc 绑定至 dst </span></span><br><span class="line">&#123;</span><br><span class="line">  sockaddr_in dstsock;</span><br><span class="line">  make_sockaddr(dst.c_str(), &amp;dstsock); <span class="comment">// rpc.h 里的辅助函数</span></span><br><span class="line">  cl = <span class="keyword">new</span> rpcc(dstsock);</span><br><span class="line">  <span class="keyword">if</span> (cl-&gt;bind() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"lock_client: call bind\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">lock_client::stat(lock_protocol::<span class="keyword">lockid_t</span> lid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ret = cl-&gt;call(lock_protocol::stat, cl-&gt;id(), lid, r);</span><br><span class="line">  VERIFY (ret == lock_protocol::OK);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_client::acquire(lock_protocol::<span class="keyword">lockid_t</span> lid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ret = cl-&gt;call(lock_protocol::acquire, cl-&gt;id(), lid, r);</span><br><span class="line">  VERIFY (ret == lock_protocol::OK);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_client::release(lock_protocol::<span class="keyword">lockid_t</span> lid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ret = cl-&gt;call(lock_protocol::release, cl-&gt;id(), lid, r);</span><br><span class="line">  VERIFY (ret == lock_protocol::OK);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client 端都是些套路代码，主要实现都来自于 server 端的函数。</p><h2 id="lock-server"><a href="#lock-server" class="headerlink" title="lock_server"></a>lock_server</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> lock_server_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lock_server_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lock_protocol.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lock_client.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_server</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> nacquire;</span><br><span class="line">  <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;lock_protocol::<span class="keyword">lockid_t</span>, lock*&gt; m_lockMap; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  lock_server();</span><br><span class="line">  ~lock_server() &#123;&#125;;</span><br><span class="line">  lock_protocol::<span class="function">status <span class="title">stat</span><span class="params">(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">  lock_protocol::<span class="function">status <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">  lock_protocol::<span class="function">status <span class="title">release</span><span class="params">(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lock_server.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面 lock 的构造函数</span></span><br><span class="line">lock::lock(lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> state) : m_lid(lid), m_state(state)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock_server 的构造函数</span></span><br><span class="line">lock_server::lock_server():</span><br><span class="line">  nacquire (<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_server::stat(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">  lock_protocol::status ret = lock_protocol::OK;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"stat request from clt %d\n"</span>, clt);</span><br><span class="line">  r = nacquire;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_server::acquire(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">  lock_protocol::status ret = lock_protocol::OK;  <span class="comment">// 初始化返回值</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m_mutex);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter = m_lockMap.find(lid);</span><br><span class="line">  <span class="keyword">if</span> (iter != m_lockMap.end())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(iter-&gt;second-&gt;m_state != lock::FREE)</span><br><span class="line">    &#123;</span><br><span class="line">      iter-&gt;second-&gt;m_cv.wait(lck); <span class="comment">// 在条件变量上 wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    iter-&gt;second-&gt;m_state = lock::LOCKED; <span class="comment">// 获得 lock</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 没找到就新建一个锁</span></span><br><span class="line">    <span class="keyword">auto</span> p_mutex = <span class="keyword">new</span> lock(lid, lock::LOCKED);</span><br><span class="line">    m_lockMap.insert(<span class="built_in">std</span>::pair&lt;lock_protocol::<span class="keyword">lockid_t</span>, lock*&gt;(lid, p_mutex));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_server::release(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">  lock_protocol::status ret = lock_protocol::OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter = m_lockMap.find(lid);</span><br><span class="line">  <span class="keyword">if</span> (iter != m_lockMap.end())</span><br><span class="line">  &#123;</span><br><span class="line">    iter-&gt;second-&gt;m_state = lock::FREE;</span><br><span class="line">    iter-&gt;second-&gt;m_cv.notify_all();  <span class="comment">// 条件变量 notify_all  这样 wai t的会被唤醒</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ret = lock_protocol::IOERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m_mutex.unlock();</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://liu-jianhao.github.io/2018/11/yfs%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%94%81%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">yfs实现第一步——锁服务</a></li><li><a href="https://github.com/liu-jianhao/yfsCpp11/" target="_blank" rel="noopener">yfsCpp11</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> yfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 分布式 yfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo GzipFile</title>
      <link href="/2020/10/27/muduo-GzipFile/"/>
      <url>/2020/10/27/muduo-GzipFile/</url>
      
        <content type="html"><![CDATA[<p>对 zlib 进行了简单封装，主要欣赏代码风格和规范。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/StringPiece.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/noncopyable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GzipFile</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  GzipFile(GzipFile&amp;&amp; rhs) <span class="keyword">noexcept</span>  <span class="comment">// move</span></span><br><span class="line">    : file_(rhs.file_)</span><br><span class="line">  &#123;</span><br><span class="line">    rhs.file_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~GzipFile()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_)</span><br><span class="line">    &#123;</span><br><span class="line">      ::gzclose(file_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  GzipFile&amp; <span class="keyword">operator</span>=(GzipFile&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> file_ != <span class="literal">NULL</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(GzipFile&amp; rhs)</span> </span>&#123; <span class="built_in">std</span>::swap(file_, rhs.file_); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZLIB_VERNUM &gt;= 0x1240</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">setBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; <span class="keyword">return</span> ::gzbuffer(file_, size) == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the number of uncompressed bytes actually read, 0 for eof, -1 for error</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>* buf, <span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">return</span> ::gzread(file_, buf, len); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the number of uncompressed bytes actually written</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(StringPiece buf)</span> </span>&#123; <span class="keyword">return</span> ::gzwrite(file_, buf.data(), buf.size()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// number of uncompressed bytes</span></span><br><span class="line">  <span class="keyword">off_t</span> tell() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ::gztell(file_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZLIB_VERNUM &gt;= 0x1240</span></span><br><span class="line">  <span class="comment">// number of compressed bytes</span></span><br><span class="line">  <span class="keyword">off_t</span> offset() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ::gzoffset(file_); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int flush(int f) &#123; return ::gzflush(file_, f); &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForRead</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">"rbe"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForAppend</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">"abe"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForWriteExclusive</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">"wbxe"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForWriteTruncate</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">"wbe"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">GzipFile</span><span class="params">(gzFile file)</span></span></span><br><span class="line">    : file_(file)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gzFile file_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/GzipFile.h" target="_blank" rel="noopener">GzipFile</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo ProcessInfo</title>
      <link href="/2020/10/27/muduo-ProcessInfo/"/>
      <url>/2020/10/27/muduo-ProcessInfo/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_PROCESSINFO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_PROCESSINFO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/StringPiece.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Timestamp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ProcessInfo</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid();  <span class="comment">// 进程 pid</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">pidString</span><span class="params">()</span></span>; <span class="comment">// pid字符串</span></span><br><span class="line">  <span class="keyword">uid_t</span> uid(); <span class="comment">// userid</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">username</span><span class="params">()</span></span>; <span class="comment">// uid字符串</span></span><br><span class="line">  <span class="keyword">uid_t</span> euid(); <span class="comment">// 有效用户id</span></span><br><span class="line">  <span class="function">Timestamp <span class="title">startTime</span><span class="params">()</span></span>; <span class="comment">// 进程开始时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">clockTicksPerSecond</span><span class="params">()</span></span>; <span class="comment">// 时钟频率</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>; <span class="comment">// 内存页大小</span></span><br><span class="line">  <span class="comment">// 是否以调试模式构建</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isDebugBuild</span><span class="params">()</span></span>;  <span class="comment">// constexpr</span></span><br><span class="line">  <span class="comment">// 主机名</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">hostname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 进程名</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">procname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">StringPiece <span class="title">procname</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; stat)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// read /proc/self/status</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">procStatus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// read /proc/self/stat</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">procStat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// read /proc/self/task/tid/stat</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">threadStat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// readlink /proc/self/exe</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">exePath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">openedFiles</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxOpenFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CpuTime</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">double</span> userSeconds;</span><br><span class="line">    <span class="keyword">double</span> systemSeconds;</span><br><span class="line"></span><br><span class="line">    CpuTime() : userSeconds(<span class="number">0.0</span>), systemSeconds(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">total</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> userSeconds + systemSeconds; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">CpuTime <span class="title">cpuTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numThreads</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">pid_t</span>&gt; threads();</span><br><span class="line">&#125;  <span class="comment">// namespace ProcessInfo</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license</span></span><br><span class="line"><span class="comment">// that can be found in the License file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Author: Shuo Chen (chenshuo at chenshuo dot com)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/ProcessInfo.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/CurrentThread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/FileUtil.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // snprintf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> detail</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// threadlocal</span></span><br><span class="line">__thread <span class="keyword">int</span> t_numOpenedFiles = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdDirFilter</span><span class="params">(<span class="keyword">const</span> struct dirent* d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">isdigit</span>(d-&gt;d_name[<span class="number">0</span>]))</span><br><span class="line">  &#123;</span><br><span class="line">    ++t_numOpenedFiles;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__thread <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">pid_t</span>&gt;* t_pids = <span class="literal">NULL</span>;  <span class="comment">// 线程id列表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">taskDirFilter</span><span class="params">(<span class="keyword">const</span> struct dirent* d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">isdigit</span>(d-&gt;d_name[<span class="number">0</span>]))</span><br><span class="line">  &#123;</span><br><span class="line">    t_pids-&gt;push_back(atoi(d-&gt;d_name));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanDir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dirpath, <span class="keyword">int</span> (*filter)(<span class="keyword">const</span> struct dirent *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>** <span class="title">namelist</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">int</span> result = ::scandir(dirpath, &amp;namelist, filter, alphasort);   <span class="comment">// alphasort 用来排序</span></span><br><span class="line">  assert(namelist == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timestamp g_startTime = Timestamp::now();</span><br><span class="line"><span class="comment">// assume those won't change during the life time of a process.</span></span><br><span class="line"><span class="keyword">int</span> g_clockTicks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(::sysconf(_SC_CLK_TCK));</span><br><span class="line"><span class="keyword">int</span> g_pageSize = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(::sysconf(_SC_PAGE_SIZE));</span><br><span class="line">&#125;  <span class="comment">// namespace detail</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::detail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> ProcessInfo::pid()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ::getpid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::pidString()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"%d"</span>, pid());</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uid_t</span> ProcessInfo::uid()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ::getuid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::username()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> <span class="title">pwd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span>* <span class="title">result</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8192</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"unknownuser"</span>;</span><br><span class="line"></span><br><span class="line">  getpwuid_r(uid(), &amp;pwd, buf, <span class="keyword">sizeof</span> buf, &amp;result);  <span class="comment">// 从密码文件中获取记录</span></span><br><span class="line">  <span class="keyword">if</span> (result)</span><br><span class="line">  &#123;</span><br><span class="line">    name = pwd.pw_name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uid_t</span> ProcessInfo::euid()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ::geteuid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timestamp ProcessInfo::startTime()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> g_startTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ProcessInfo::clockTicksPerSecond()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> g_clockTicks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ProcessInfo::pageSize()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> g_pageSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ProcessInfo::isDebugBuild()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::hostname()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// HOST_NAME_MAX 64</span></span><br><span class="line">  <span class="comment">// _POSIX_HOST_NAME_MAX 255</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">  <span class="keyword">if</span> (::gethostname(buf, <span class="keyword">sizeof</span> buf) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    buf[<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"unknownhost"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::procname()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> procname(procStat()).as_string();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringPiece ProcessInfo::procname(<span class="keyword">const</span> <span class="built_in">string</span>&amp; stat)</span><br><span class="line">&#123;</span><br><span class="line">  StringPiece name;</span><br><span class="line">  <span class="keyword">size_t</span> lp = stat.find(<span class="string">'('</span>);</span><br><span class="line">  <span class="keyword">size_t</span> rp = stat.rfind(<span class="string">')'</span>);</span><br><span class="line">  <span class="keyword">if</span> (lp != <span class="built_in">string</span>::npos &amp;&amp; rp != <span class="built_in">string</span>::npos &amp;&amp; lp &lt; rp)</span><br><span class="line">  &#123;</span><br><span class="line">    name.<span class="built_in">set</span>(stat.data()+lp+<span class="number">1</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rp-lp<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::procStatus()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">string</span> result;</span><br><span class="line">  FileUtil::readFile(<span class="string">"/proc/self/status"</span>, <span class="number">65536</span>, &amp;result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::procStat()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">string</span> result;</span><br><span class="line">  FileUtil::readFile(<span class="string">"/proc/self/stat"</span>, <span class="number">65536</span>, &amp;result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::threadStat()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"/proc/self/task/%d/stat"</span>, CurrentThread::tid());</span><br><span class="line">  <span class="built_in">string</span> result;</span><br><span class="line">  FileUtil::readFile(buf, <span class="number">65536</span>, &amp;result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ProcessInfo::exePath()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">string</span> result;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">ssize_t</span> n = ::readlink(<span class="string">"/proc/self/exe"</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    result.assign(buf, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ProcessInfo::openedFiles()</span><br><span class="line">&#123;</span><br><span class="line">  t_numOpenedFiles = <span class="number">0</span>;</span><br><span class="line">  scanDir(<span class="string">"/proc/self/fd"</span>, fdDirFilter);</span><br><span class="line">  <span class="keyword">return</span> t_numOpenedFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> struct rlimit &#123;</span></span><br><span class="line"><span class="comment">　　rlim_t rlim_cur;  // 软上限</span></span><br><span class="line"><span class="comment">　　rlim_t rlim_max;  // 硬上限</span></span><br><span class="line"><span class="comment">&#125;;     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ProcessInfo::maxOpenFiles()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (::getrlimit(RLIMIT_NOFILE, &amp;rl))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> openedFiles();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rl.rlim_cur);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessInfo::CpuTime ProcessInfo::cpuTime()</span><br><span class="line">&#123;</span><br><span class="line">  ProcessInfo::CpuTime t;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">tms</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (::times(&amp;tms) &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> hz = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(clockTicksPerSecond());</span><br><span class="line">    t.userSeconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(tms.tms_utime) / hz;</span><br><span class="line">    t.systemSeconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(tms.tms_stime) / hz;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ProcessInfo::numThreads()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">string</span> status = procStatus();</span><br><span class="line">  <span class="keyword">size_t</span> pos = status.find(<span class="string">"Threads:"</span>);</span><br><span class="line">  <span class="keyword">if</span> (pos != <span class="built_in">string</span>::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    result = ::atoi(status.c_str() + pos + <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">pid_t</span>&gt; ProcessInfo::threads()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">pid_t</span>&gt; result;</span><br><span class="line">  t_pids = &amp;result;</span><br><span class="line">  scanDir(<span class="string">"/proc/self/task"</span>, taskDirFilter);</span><br><span class="line">  t_pids = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">std</span>::sort(result.begin(), result.end());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/ProcessInfo.h" target="_blank" rel="noopener">ProcessInfo</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo atomic</title>
      <link href="/2020/10/27/muduo-atomic/"/>
      <url>/2020/10/27/muduo-atomic/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_ATOMIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_ATOMIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> detail</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerT</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  AtomicIntegerT()</span><br><span class="line">    : value_(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uncomment if you need copying and assignment</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// AtomicIntegerT(const AtomicIntegerT&amp; that)</span></span><br><span class="line">  <span class="comment">//   : value_(that.get())</span></span><br><span class="line">  <span class="comment">// &#123;&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// AtomicIntegerT&amp; operator=(const AtomicIntegerT&amp; that)</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   getAndSet(that.get());</span></span><br><span class="line">  <span class="comment">//   return *this;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// in gcc &gt;= 4.7: __atomic_load_n(&amp;value_, __ATOMIC_SEQ_CST)</span></span><br><span class="line">    <span class="comment">// 实现原子操作</span></span><br><span class="line">    <span class="keyword">return</span> __sync_val_compare_and_swap(&amp;value_, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getAndAdd</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// in gcc &gt;= 4.7: __atomic_fetch_add(&amp;value_, x, __ATOMIC_SEQ_CST)</span></span><br><span class="line">    <span class="keyword">return</span> __sync_fetch_and_add(&amp;value_, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">addAndGet</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(x) + x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">incrementAndGet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAndGet(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">decrementAndGet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAndGet(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    getAndAdd(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getAndSet</span><span class="params">(T newValue)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// in gcc &gt;= 4.7: __atomic_exchange_n(&amp;value_, newValue, __ATOMIC_SEQ_CST)</span></span><br><span class="line">    <span class="comment">// 实现原子操作</span></span><br><span class="line">    <span class="keyword">return</span> __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> T value_;  <span class="comment">// 直接在内存占用进行存取</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> detail::AtomicIntegerT&lt;<span class="keyword">int32_t</span>&gt; AtomicInt32;</span><br><span class="line"><span class="keyword">typedef</span> detail::AtomicIntegerT&lt;<span class="keyword">int64_t</span>&gt; AtomicInt64;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_ATOMIC_H</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/Atomic.h" target="_blank" rel="noopener">Atomic</a></li><li><a href="https://www.cnblogs.com/woodineast/p/13545740.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/woodineast/p/13545740.html" target="_blank" rel="noopener">muduo源码解析2-AtomicIntegerT类</a></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 多线程 muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo date</title>
      <link href="/2020/10/27/muduo-date/"/>
      <url>/2020/10/27/muduo-date/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_DATE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_DATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/copyable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Types.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Date in Gregorian calendar.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This class is immutable.</span></span><br><span class="line"><span class="comment">/// It's recommended to pass it by value, since it's passed in register on x64.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> :</span> <span class="keyword">public</span> muduo::copyable</span><br><span class="line">          <span class="comment">// public boost::less_than_comparable&lt;Date&gt;,</span></span><br><span class="line">          <span class="comment">// public boost::equality_comparable&lt;Date&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">YearMonthDay</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> year; <span class="comment">// [1900..2500]</span></span><br><span class="line">    <span class="keyword">int</span> month;  <span class="comment">// [1..12]</span></span><br><span class="line">    <span class="keyword">int</span> day;  <span class="comment">// [1..31]</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kDaysPerWeek = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kJulianDayOf1970_01_01;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Constucts an invalid Date.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Date()</span><br><span class="line">    : julianDayNumber_(<span class="number">0</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Constucts a yyyy-mm-dd Date.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 1 &lt;= month &lt;= 12</span></span><br><span class="line">  Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day);</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Constucts a Date from Julian Day Number.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> julianDayNum)</span></span></span><br><span class="line">    : julianDayNumber_(julianDayNum)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Constucts a Date from struct tm</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="keyword">const</span> struct tm&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default copy/assignment/dtor are Okay</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Date&amp; that)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(julianDayNumber_, that.julianDayNumber_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> julianDayNumber_ &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Converts to yyyy-mm-dd format.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">toIsoString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">struct YearMonthDay <span class="title">yearMonthDay</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">year</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yearMonthDay().year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">month</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yearMonthDay().month;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yearMonthDay().day;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [0, 1, ..., 6] =&gt; [Sunday, Monday, ..., Saturday ]</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">weekDay</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (julianDayNumber_+<span class="number">1</span>) % kDaysPerWeek;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">julianDayNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> julianDayNumber_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> julianDayNumber_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Date x, Date y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x.julianDayNumber() &lt; y.julianDayNumber();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Date x, Date y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x.julianDayNumber() == y.julianDayNumber();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_DATE_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> require_32_bit_integer_at_least[<span class="keyword">sizeof</span>(<span class="keyword">int</span>) &gt;= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>) ? <span class="number">1</span> : <span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// algorithm and explanation see:</span></span><br><span class="line"><span class="comment">// http://www.faqs.org/faqs/calendars/faq/part2/</span></span><br><span class="line"><span class="comment">// http://blog.csdn.net/Solstice</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getJulianDayNumber</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>) require_32_bit_integer_at_least; <span class="comment">// no warning please</span></span><br><span class="line">  <span class="keyword">int</span> a = (<span class="number">14</span> - month) / <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">int</span> y = year + <span class="number">4800</span> - a;</span><br><span class="line">  <span class="keyword">int</span> m = month + <span class="number">12</span> * a - <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> day + (<span class="number">153</span>*m + <span class="number">2</span>) / <span class="number">5</span> + y*<span class="number">365</span> + y/<span class="number">4</span> - y/<span class="number">100</span> + y/<span class="number">400</span> - <span class="number">32045</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>:</span>:<span class="function">YearMonthDay <span class="title">getYearMonthDay</span><span class="params">(<span class="keyword">int</span> julianDayNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = julianDayNumber + <span class="number">32044</span>;</span><br><span class="line">  <span class="keyword">int</span> b = (<span class="number">4</span> * a + <span class="number">3</span>) / <span class="number">146097</span>;</span><br><span class="line">  <span class="keyword">int</span> c = a - ((b * <span class="number">146097</span>) / <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">int</span> d = (<span class="number">4</span> * c + <span class="number">3</span>) / <span class="number">1461</span>;</span><br><span class="line">  <span class="keyword">int</span> e = c - ((<span class="number">1461</span> * d) / <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">int</span> m = (<span class="number">5</span> * e + <span class="number">2</span>) / <span class="number">153</span>;</span><br><span class="line">  Date::YearMonthDay ymd;</span><br><span class="line">  ymd.day = e - ((<span class="number">153</span> * m + <span class="number">2</span>) / <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">  ymd.month = m + <span class="number">3</span> - <span class="number">12</span> * (m / <span class="number">10</span>);</span><br><span class="line">  ymd.year = b * <span class="number">100</span> + d - <span class="number">4800</span> + (m / <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> ymd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace detail</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Date::kJulianDayOf1970_01_01 = detail::getJulianDayNumber(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::detail;</span><br><span class="line"></span><br><span class="line">Date::Date(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span><br><span class="line">  : julianDayNumber_(getJulianDayNumber(y, m, d))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date::Date(<span class="keyword">const</span> struct tm&amp; t)</span><br><span class="line">  : julianDayNumber_(getJulianDayNumber(</span><br><span class="line">        t.tm_year+<span class="number">1900</span>,</span><br><span class="line">        t.tm_mon+<span class="number">1</span>,</span><br><span class="line">        t.tm_mday))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> Date::toIsoString() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">  <span class="function">YearMonthDay <span class="title">ymd</span><span class="params">(yearMonthDay())</span></span>;</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"%4d-%02d-%02d"</span>, ymd.year, ymd.month, ymd.day);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date::YearMonthDay Date::yearMonthDay() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> getYearMonthDay(julianDayNumber_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/Date.h" target="_blank" rel="noopener">date</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo FileUtil</title>
      <link href="/2020/10/27/muduo-FileUtil/"/>
      <url>/2020/10/27/muduo-FileUtil/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_FILEUTIL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_FILEUTIL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/noncopyable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/StringPiece.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  // for off_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> FileUtil</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read small file &lt; 64KB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadSmallFile</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ReadSmallFile(StringArg filename);</span><br><span class="line">  ~ReadSmallFile();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return errno</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> String&gt;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">readToString</span><span class="params">(<span class="keyword">int</span> maxSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                   String* content,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int64_t</span>* fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int64_t</span>* modifyTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int64_t</span>* createTime)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Read at maxium kBufferSize into buf_</span></span><br><span class="line">  <span class="comment">// return errno</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">readToBuffer</span><span class="params">(<span class="keyword">int</span>* size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">buffer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buf_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBufferSize = <span class="number">64</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> fd_;</span><br><span class="line">  <span class="keyword">int</span> err_;</span><br><span class="line">  <span class="keyword">char</span> buf_[kBufferSize];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the file content, returns errno if error happens.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> String&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readFile</span><span class="params">(StringArg filename,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> maxSize,</span></span></span><br><span class="line"><span class="function"><span class="params">             String* content,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int64_t</span>* fileSize = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int64_t</span>* modifyTime = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int64_t</span>* createTime = <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ReadSmallFile <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> file.readToString(maxSize, content, fileSize, modifyTime, createTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not thread safe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendFile</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AppendFile</span><span class="params">(StringArg filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  ~AppendFile();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">off_t</span> writtenBytes() <span class="keyword">const</span> &#123; <span class="keyword">return</span> writtenBytes_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> write(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">size_t</span> len);</span><br><span class="line"></span><br><span class="line">  FILE* fp_;</span><br><span class="line">  <span class="keyword">char</span> buffer_[<span class="number">64</span>*<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">off_t</span> writtenBytes_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace FileUtil</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_FILEUTIL_H</span></span></span><br></pre></td></tr></table></figure><h2 id="AppendFile"><a href="#AppendFile" class="headerlink" title="AppendFile"></a>AppendFile</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">FileUtil::AppendFile::AppendFile(StringArg filename)</span><br><span class="line">  : fp_(::fopen(filename.c_str(), <span class="string">"ae"</span>)),  <span class="comment">// 'e' for O_CLOEXEC  'a' 表示追加</span></span><br><span class="line">    writtenBytes_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  assert(fp_);</span><br><span class="line">  ::setbuffer(fp_, buffer_, <span class="keyword">sizeof</span> buffer_);</span><br><span class="line">  <span class="comment">// posix_fadvise POSIX_FADV_DONTNEED ?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileUtil::AppendFile::~AppendFile()</span><br><span class="line">&#123;</span><br><span class="line">  ::fclose(fp_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FileUtil::AppendFile::append(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">const</span> <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 写入文件</span></span><br><span class="line">  <span class="keyword">size_t</span> n = write(logline, len);</span><br><span class="line">  <span class="keyword">size_t</span> remain = len - n;</span><br><span class="line">  <span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> x = write(logline + n, remain);</span><br><span class="line">    <span class="comment">// 写入失败</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> err = ferror(fp_);</span><br><span class="line">      <span class="keyword">if</span> (err)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"AppendFile::append() failed %s\n"</span>, strerror_tl(err));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续写入</span></span><br><span class="line">    n += x;</span><br><span class="line">    remain = len - n; <span class="comment">// remain -= x</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新已经写入的总字节数 </span></span><br><span class="line">  writtenBytes_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新文件流</span></span><br><span class="line"><span class="keyword">void</span> FileUtil::AppendFile::flush()</span><br><span class="line">&#123;</span><br><span class="line">  ::fflush(fp_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> FileUtil::AppendFile::write(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// #undef fwrite_unlocked</span></span><br><span class="line">  <span class="comment">// 写文件的不加锁版本，线程不安全</span></span><br><span class="line">  <span class="keyword">return</span> ::fwrite_unlocked(logline, <span class="number">1</span>, len, fp_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReadSmallFile"><a href="#ReadSmallFile" class="headerlink" title="ReadSmallFile"></a>ReadSmallFile</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">FileUtil::ReadSmallFile::ReadSmallFile(StringArg filename)</span><br><span class="line">  : fd_(::open(filename.c_str(), O_RDONLY | O_CLOEXEC)),  <span class="comment">// 只读 打开文件并记录文件描述符</span></span><br><span class="line">    err_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 清空缓冲区</span></span><br><span class="line">  buf_[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">if</span> (fd_ &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    err_ = errno;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileUtil::ReadSmallFile::~ReadSmallFile()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fd_ &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ::close(fd_); <span class="comment">// <span class="doctag">FIXME:</span> check EINTR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return errno</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> String&gt;</span><br><span class="line"><span class="keyword">int</span> FileUtil::ReadSmallFile::readToString(<span class="keyword">int</span> maxSize,</span><br><span class="line">                                          String* content,</span><br><span class="line">                                          <span class="keyword">int64_t</span>* fileSize,</span><br><span class="line">                                          <span class="keyword">int64_t</span>* modifyTime,</span><br><span class="line">                                          <span class="keyword">int64_t</span>* createTime)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 判断是否占 8 位  </span></span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">off_t</span>) == <span class="number">8</span>, <span class="string">"_FILE_OFFSET_BITS = 64"</span>);</span><br><span class="line">  assert(content != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">int</span> err = err_;</span><br><span class="line">  <span class="keyword">if</span> (fd_ &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    content-&gt;clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileSize)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获取文件信息</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">      <span class="keyword">if</span> (::fstat(fd_, &amp;statbuf) == <span class="number">0</span>)</span><br><span class="line">      &#123; <span class="comment">// 是否是常规文件</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(statbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 获得文件大小</span></span><br><span class="line">          *fileSize = statbuf.st_size;</span><br><span class="line">          <span class="comment">// 申请空间</span></span><br><span class="line">          content-&gt;reserve(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::min(implicit_cast&lt;<span class="keyword">int64_t</span>&gt;(maxSize), *fileSize)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(statbuf.st_mode))  <span class="comment">// 是目录</span></span><br><span class="line">        &#123;</span><br><span class="line">          err = EISDIR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modifyTime) <span class="comment">// 更新时间</span></span><br><span class="line">        &#123;</span><br><span class="line">          *modifyTime = statbuf.st_mtime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (createTime) <span class="comment">// 创建时间</span></span><br><span class="line">        &#123;</span><br><span class="line">          *createTime = statbuf.st_ctime;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        err = errno;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (content-&gt;size() &lt; implicit_cast&lt;<span class="keyword">size_t</span>&gt;(maxSize))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//   要读的字节数</span></span><br><span class="line">      <span class="keyword">size_t</span> toRead = <span class="built_in">std</span>::min(implicit_cast&lt;<span class="keyword">size_t</span>&gt;(maxSize) - content-&gt;size(), <span class="keyword">sizeof</span>(buf_));</span><br><span class="line">      <span class="keyword">ssize_t</span> n = ::read(fd_, buf_, toRead);</span><br><span class="line">      <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        content-&gt;append(buf_, n);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          err = errno;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件内容读入缓冲区, 将文件大小赋值给 size</span></span><br><span class="line"><span class="keyword">int</span> FileUtil::ReadSmallFile::readToBuffer(<span class="keyword">int</span>* size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> err = err_;</span><br><span class="line">  <span class="keyword">if</span> (fd_ &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//pread()  reads  up to count bytes from file descriptor fd at offset offset (from the start of the</span></span><br><span class="line">    <span class="comment">//file) into the buffer starting at buf.  The file offset is not changed.</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n = ::pread(fd_, buf_, <span class="keyword">sizeof</span>(buf_)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (size)</span><br><span class="line">      &#123;</span><br><span class="line">        *size = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">      &#125;</span><br><span class="line">      buf_[n] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      err = errno;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">int</span> FileUtil::readFile(StringArg filename,</span><br><span class="line">                                <span class="keyword">int</span> maxSize,</span><br><span class="line">                                <span class="built_in">string</span>* content,</span><br><span class="line">                                <span class="keyword">int64_t</span>*, <span class="keyword">int64_t</span>*, <span class="keyword">int64_t</span>*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">int</span> FileUtil::ReadSmallFile::readToString(</span><br><span class="line">    <span class="keyword">int</span> maxSize,</span><br><span class="line">    <span class="built_in">string</span>* content,</span><br><span class="line">    <span class="keyword">int64_t</span>*, <span class="keyword">int64_t</span>*, <span class="keyword">int64_t</span>*);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/FileUtil.h" target="_blank" rel="noopener">FileUtil</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo CurrentThread</title>
      <link href="/2020/10/27/muduo-CurrentThread/"/>
      <url>/2020/10/27/muduo-CurrentThread/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_CURRENTTHREAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_CURRENTTHREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Types.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// internal</span></span><br><span class="line">  <span class="comment">// 使用 __thread 修饰变量 使得每一个线程都有一份独立实体，各个线程的值互不干扰</span></span><br><span class="line">  <span class="keyword">extern</span> __thread <span class="keyword">int</span> t_cachedTid;  <span class="comment">// 当前线程id</span></span><br><span class="line">  <span class="keyword">extern</span> __thread <span class="keyword">char</span> t_tidString[<span class="number">32</span>]; <span class="comment">// 当前线程id</span></span><br><span class="line">  <span class="keyword">extern</span> __thread <span class="keyword">int</span> t_tidStringLength; <span class="comment">// char 的大小</span></span><br><span class="line">  <span class="keyword">extern</span> __thread <span class="keyword">const</span> <span class="keyword">char</span>* t_threadName; <span class="comment">// 线程名字</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(t_cachedTid == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      cacheTid();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t_cachedTid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">tidString</span><span class="params">()</span> <span class="comment">// for logging</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_tidString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tidStringLength</span><span class="params">()</span> <span class="comment">// for logging</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_tidStringLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_threadName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isMainThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleepUsec</span><span class="params">(<span class="keyword">int64_t</span> usec)</span></span>;  <span class="comment">// for testing</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">stackTrace</span><span class="params">(<span class="keyword">bool</span> demangle)</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace CurrentThread</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_CURRENTTHREAD_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">__thread <span class="keyword">int</span> t_cachedTid = <span class="number">0</span>;</span><br><span class="line">__thread <span class="keyword">char</span> t_tidString[<span class="number">32</span>];</span><br><span class="line">__thread <span class="keyword">int</span> t_tidStringLength = <span class="number">6</span>;</span><br><span class="line">__thread <span class="keyword">const</span> <span class="keyword">char</span>* t_threadName = <span class="string">"unknown"</span>;</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">pid_t</span>&gt;::value, <span class="string">"pid_t should be int"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">stackTrace</span><span class="params">(<span class="keyword">bool</span> demangle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="built_in">stack</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> max_frames = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">void</span>* frame[max_frames];</span><br><span class="line">  <span class="keyword">int</span> nptrs = ::backtrace(frame, max_frames);</span><br><span class="line">  <span class="keyword">char</span>** strings = ::backtrace_symbols(frame, nptrs);</span><br><span class="line">  <span class="keyword">if</span> (strings)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">char</span>* demangled = demangle ? <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(::<span class="built_in">malloc</span>(len)) : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nptrs; ++i)  <span class="comment">// skipping the 0-th, which is this function</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (demangle)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// https://panthema.net/2008/0901-stacktrace-demangled/</span></span><br><span class="line">        <span class="comment">// bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909]</span></span><br><span class="line">        <span class="keyword">char</span>* left_par = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">char</span>* plus = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>* p = strings[i]; *p; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (*p == <span class="string">'('</span>)</span><br><span class="line">            left_par = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'+'</span>)</span><br><span class="line">            plus = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left_par &amp;&amp; plus)</span><br><span class="line">        &#123;</span><br><span class="line">          *plus = <span class="string">'\0'</span>;</span><br><span class="line">          <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">char</span>* ret = abi::__cxa_demangle(left_par+<span class="number">1</span>, demangled, &amp;len, &amp;status);</span><br><span class="line">          *plus = <span class="string">'+'</span>;</span><br><span class="line">          <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            demangled = ret;  <span class="comment">// ret could be realloc()</span></span><br><span class="line">            <span class="built_in">stack</span>.append(strings[i], left_par+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">stack</span>.append(demangled);</span><br><span class="line">            <span class="built_in">stack</span>.append(plus);</span><br><span class="line">            <span class="built_in">stack</span>.push_back(<span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Fallback to mangled names</span></span><br><span class="line">      <span class="built_in">stack</span>.append(strings[i]);</span><br><span class="line">      <span class="built_in">stack</span>.push_back(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(demangled);</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace CurrentThread</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/CurrentThread.h" target="_blank" rel="noopener">currentThread</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo exception</title>
      <link href="/2020/10/27/muduo-exception/"/>
      <url>/2020/10/27/muduo-exception/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_EXCEPTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_EXCEPTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Exception(<span class="built_in">string</span> what);</span><br><span class="line">  ~Exception() <span class="keyword">noexcept</span> override = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default copy-ctor and operator= are okay.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> override</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">stackTrace</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> message_;</span><br><span class="line">  <span class="built_in">string</span> stack_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_EXCEPTION_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Exception.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/CurrentThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Exception::Exception(<span class="built_in">string</span> msg)</span><br><span class="line">  : message_(<span class="built_in">std</span>::move(msg)),</span><br><span class="line">    stack_(CurrentThread::stackTrace(<span class="comment">/*demangle=*/</span><span class="literal">false</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/Exception.h" target="_blank" rel="noopener">exception</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo Timestamp </title>
      <link href="/2020/10/27/muduo-Timestamp/"/>
      <url>/2020/10/27/muduo-Timestamp/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timestamp</span> :</span> <span class="keyword">public</span> muduo::copyable,</span><br><span class="line">                  <span class="keyword">public</span> boost::equality_comparable&lt;Timestamp&gt;,</span><br><span class="line">                  <span class="keyword">public</span> boost::less_than_comparable&lt;Timestamp&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Constucts an invalid Timestamp.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Timestamp()</span><br><span class="line">    : microSecondsSinceEpoch_(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Constucts a Timestamp at specific time</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// @param microSecondsSinceEpoch</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Timestamp</span><span class="params">(<span class="keyword">int64_t</span> microSecondsSinceEpochArg)</span></span></span><br><span class="line">    : microSecondsSinceEpoch_(microSecondsSinceEpochArg)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Timestamp&amp; that)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default copy/assignment/dtor are Okay</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">toFormattedString</span><span class="params">(<span class="keyword">bool</span> showMicroseconds = <span class="literal">true</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> microSecondsSinceEpoch_ &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for internal usage.</span></span><br><span class="line">  <span class="keyword">int64_t</span> microSecondsSinceEpoch() <span class="keyword">const</span> &#123; <span class="keyword">return</span> microSecondsSinceEpoch_; &#125;</span><br><span class="line">  <span class="keyword">time_t</span> secondsSinceEpoch() <span class="keyword">const</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Get time of now.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Timestamp <span class="title">now</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Timestamp <span class="title">invalid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Timestamp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Timestamp <span class="title">fromUnixTime</span><span class="params">(<span class="keyword">time_t</span> t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fromUnixTime(t, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Timestamp <span class="title">fromUnixTime</span><span class="params">(<span class="keyword">time_t</span> t, <span class="keyword">int</span> microseconds)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Timestamp(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(t) * kMicroSecondsPerSecond + microseconds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMicroSecondsPerSecond = <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int64_t</span> microSecondsSinceEpoch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Gets time difference of two timestamps, result in seconds.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param high, low</span></span><br><span class="line"><span class="comment">/// @return (high-low) in seconds</span></span><br><span class="line"><span class="comment">/// @c double has 52-bit precision, enough for one-microsecond</span></span><br><span class="line"><span class="comment">/// resolution for next 100 years.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">timeDifference</span><span class="params">(Timestamp high, Timestamp low)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(diff) / Timestamp::kMicroSecondsPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Add @c seconds to given timestamp.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return timestamp+seconds as Timestamp</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Timestamp <span class="title">addTime</span><span class="params">(Timestamp timestamp, <span class="keyword">double</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> delta = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(seconds * Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  <span class="keyword">return</span> Timestamp(timestamp.microSecondsSinceEpoch() + delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> Timestamp::toString() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int64_t</span> seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;</span><br><span class="line">  <span class="keyword">int64_t</span> microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%"</span> PRId64 <span class="string">".%06"</span> PRId64 <span class="string">""</span>, seconds, microseconds);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> Timestamp::toFormattedString(<span class="keyword">bool</span> showMicroseconds) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">time_t</span> seconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm_time</span>;</span></span><br><span class="line">  gmtime_r(&amp;seconds, &amp;tm_time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (showMicroseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> microseconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%4d%02d%02d %02d:%02d:%02d.%06d"</span>,</span><br><span class="line">             tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">             microseconds);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%4d%02d%02d %02d:%02d:%02d"</span>,</span><br><span class="line">             tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timestamp Timestamp::now()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">int64_t</span> seconds = tv.tv_sec;</span><br><span class="line">  <span class="keyword">return</span> Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/Timestamp.h" target="_blank" rel="noopener">timestamp</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode148排序链表</title>
      <link href="/2020/10/23/leetcode148%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/10/23/leetcode148%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>不能用递归法来解，所以按照链表长度从 1 到 len，倍增进行合并。需要依次合并长度为 1，2，4…..len的链表。</p><p>主要需要将链表分割成一个个长度为 size 的小段，并且将长度为 size 的小段进行合并。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// cut n个节点，然后返回剩下的链表的头节点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(--n &amp;&amp; node) node = node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* next = node-&gt;next;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* node = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt; val) &#123;</span><br><span class="line">                node-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) node-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> node-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; len; sz*=<span class="number">2</span>) &#123;</span><br><span class="line">            ListNode* cur = dummy-&gt;next;  <span class="comment">// 待分割链表的第一个节点  tail为已经合并好的链表的最后一个节点</span></span><br><span class="line">            ListNode* tail = dummy;</span><br><span class="line">            <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">                ListNode* left = cur;</span><br><span class="line">                ListNode* right = cut(left, sz);</span><br><span class="line">                cur = cut(right, sz);</span><br><span class="line">                tail-&gt;next = merge(left, right);</span><br><span class="line">                <span class="keyword">while</span>(tail-&gt;next) tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode 链表 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo Thread</title>
      <link href="/2020/10/23/muduo-Thread/"/>
      <url>/2020/10/23/muduo-Thread/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo BoundedBlockingQueue</title>
      <link href="/2020/10/22/muduo-BoundedBlockingQueue/"/>
      <url>/2020/10/22/muduo-BoundedBlockingQueue/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license</span></span><br><span class="line"><span class="comment">// that can be found in the License file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Author: Shuo Chen (chenshuo at chenshuo dot com)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Condition.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Mutex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/circular_buffer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span></span><br><span class="line">    : mutex_(),</span><br><span class="line">      notEmpty_(mutex_),</span><br><span class="line">      notFull_(mutex_),</span><br><span class="line">      queue_(maxSize)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (queue_.full())</span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.full());</span><br><span class="line">    queue_.push_back(x);</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(T&amp;&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (queue_.full())</span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.full());</span><br><span class="line">    queue_.push_back(<span class="built_in">std</span>::move(x));</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (queue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      notEmpty_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.empty());</span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">(<span class="built_in">std</span>::move(queue_.front()))</span></span>;</span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    notFull_.notify();</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> queue_.empty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> queue_.full();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> queue_.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> capacity() <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> queue_.capacity();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> MutexLock          mutex_;</span><br><span class="line">  <span class="function">Condition                  notEmpty_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="function">Condition                  notFull_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  boost::circular_buffer&lt;T&gt;  <span class="function">queue_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/BoundedBlockingQueue.h" target="_blank" rel="noopener">BoundedBlockingQueue</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo封装MutexLock MutexLockGuard Condition</title>
      <link href="/2020/10/21/muduo%E5%B0%81%E8%A3%85MutexLock-MutexLockGuard-Condition/"/>
      <url>/2020/10/21/muduo%E5%B0%81%E8%A3%85MutexLock-MutexLockGuard-Condition/</url>
      
        <content type="html"><![CDATA[<h2 id="MutexLock"><a href="#MutexLock" class="headerlink" title="MutexLock"></a>MutexLock</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class CAPABILITY("mutex") MutexLock : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  MutexLock()</span><br><span class="line">    : holder_(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_mutex_init(&amp;mutex_, <span class="literal">NULL</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~MutexLock()</span><br><span class="line">  &#123;</span><br><span class="line">    assert(holder_ == <span class="number">0</span>);</span><br><span class="line">    MCHECK(pthread_mutex_destroy(&amp;mutex_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// must be called when locked, i.e. for assertion</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isLockedByThisThread</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> holder_ == CurrentThread::tid();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assertLocked</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">ASSERT_CAPABILITY</span><span class="params">(<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    assert(isLockedByThisThread());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// internal usage</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="title">ACQUIRE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MCHECK(pthread_mutex_lock(&amp;mutex_));</span><br><span class="line">    assignHolder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="title">RELEASE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    unassignHolder();</span><br><span class="line">    MCHECK(pthread_mutex_unlock(&amp;mutex_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span>* getPthreadMutex() <span class="comment">/* non-const */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;mutex_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Condition</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UnassignGuard</span> :</span> noncopyable</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UnassignGuard</span><span class="params">(MutexLock&amp; owner)</span></span></span><br><span class="line">      : owner_(owner)</span><br><span class="line">    &#123;</span><br><span class="line">      owner_.unassignHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~UnassignGuard()</span><br><span class="line">    &#123;</span><br><span class="line">      owner_.assignHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    MutexLock&amp; owner_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unassignHolder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    holder_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assignHolder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    holder_ = CurrentThread::tid();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> mutex_;</span><br><span class="line">  <span class="keyword">pid_t</span> holder_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="MutexLockGuard"><a href="#MutexLockGuard" class="headerlink" title="MutexLockGuard"></a>MutexLockGuard</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SCOPED_CAPABILITY</span> <span class="title">MutexLockGuard</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutexLockGuard</span><span class="params">(MutexLock&amp; mutex)</span> <span class="title">ACQUIRE</span><span class="params">(mutex)</span></span></span><br><span class="line">    : mutex_(mutex)</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~MutexLockGuard() RELEASE()</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  MutexLock&amp; mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent misuse like:</span></span><br><span class="line"><span class="comment">// MutexLockGuard(mutex_);</span></span><br><span class="line"><span class="comment">// A tempory object doesn't hold the lock for long!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MutexLockGuard(x) <span class="meta-keyword">error</span> <span class="meta-string">"Missing guard object name"</span></span></span><br></pre></td></tr></table></figure><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license</span></span><br><span class="line"><span class="comment">// that can be found in the License file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Author: Shuo Chen (chenshuo at chenshuo dot com)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_CONDITION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_CONDITION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Mutex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Condition</span><span class="params">(MutexLock&amp; mutex)</span></span></span><br><span class="line">    : mutex_(mutex)</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_init(&amp;pcond_, <span class="literal">NULL</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Condition()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_destroy(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MutexLock::<span class="function">UnassignGuard <span class="title">ug</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    MCHECK(pthread_cond_wait(&amp;pcond_, mutex_.getPthreadMutex()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// returns true if time out, false otherwise.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">waitForSeconds</span><span class="params">(<span class="keyword">double</span> seconds)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MCHECK(pthread_cond_signal(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MCHECK(pthread_cond_broadcast(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MutexLock&amp; mutex_;</span><br><span class="line">  <span class="keyword">pthread_cond_t</span> pcond_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_CONDITION_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> muduo::Condition::waitForSeconds(<span class="keyword">double</span> seconds)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">abstime</span>;</span></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> use CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW to prevent time rewind.</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;abstime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> kNanoSecondsPerSecond = <span class="number">1000000000</span>;</span><br><span class="line">  <span class="keyword">int64_t</span> nanoseconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(seconds * kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  abstime.tv_sec += <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;((abstime.tv_nsec + nanoseconds) / kNanoSecondsPerSecond);</span><br><span class="line">  abstime.tv_nsec = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;((abstime.tv_nsec + nanoseconds) % kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  MutexLock::<span class="function">UnassignGuard <span class="title">ug</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ETIMEDOUT == pthread_cond_timedwait(&amp;pcond_, mutex_.getPthreadMutex(), &amp;abstime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/" target="_blank" rel="noopener">muduo base</a></li><li>Linux 多线程服务端编程–使用 muduo C++ 网络库</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> muduo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ muduo 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo CountdownLatch</title>
      <link href="/2020/10/21/muduo-CountdownLatch/"/>
      <url>/2020/10/21/muduo-CountdownLatch/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用途如下：</p><ol><li>主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。</li><li>主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出起跑命令。</li></ol><h2 id="代码大赏"><a href="#代码大赏" class="headerlink" title="代码大赏"></a>代码大赏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license</span></span><br><span class="line"><span class="comment">// that can be found in the License file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Author: Shuo Chen (chenshuo at chenshuo dot com)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_COUNTDOWNLATCH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_COUNTDOWNLATCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Condition.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Mutex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> MutexLock mutex_;</span><br><span class="line">  <span class="function">Condition condition_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> count_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_COUNTDOWNLATCH_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license</span></span><br><span class="line"><span class="comment">// that can be found in the License file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Author: Shuo Chen (chenshuo at chenshuo dot com)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/CountDownLatch.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line">CountDownLatch::CountDownLatch(<span class="keyword">int</span> count)</span><br><span class="line">  : mutex_(),</span><br><span class="line">    condition_(mutex_),</span><br><span class="line">    count_(count)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CountDownLatch::wait()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (count_ &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    condition_.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CountDownLatch::countDown()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  --count_;</span><br><span class="line">  <span class="keyword">if</span> (count_ == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    condition_.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CountDownLatch::getCount() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> count_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/CountDownLatch.h" target="_blank" rel="noopener">CountDownLacth</a></li><li>Linux 多线程服务端编程–使用 muduo C++ 网络库</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo Blocking queue</title>
      <link href="/2020/10/21/muduo-Blocking-queue/"/>
      <url>/2020/10/21/muduo-Blocking-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="条件变量的使用"><a href="#条件变量的使用" class="headerlink" title="条件变量的使用"></a>条件变量的使用</h2><h4 id="对于-wait-端"><a href="#对于-wait-端" class="headerlink" title="对于 wait 端"></a>对于 wait 端</h4><ol><li>必须与 mutex 一起使用，该布尔表达式的读写需受此 mutex 保护。</li><li>在 mutex 已上锁的时候才能调用 wait。</li><li>把判断布尔条件和 wait() 放在 while 循环中。 （不用 if 的原因 spurious wakeup）</li></ol><h4 id="对于-signal-broadcast-端"><a href="#对于-signal-broadcast-端" class="headerlink" title="对于 signal/broadcast 端"></a>对于 signal/broadcast 端</h4><ol><li>不一定要在 mutex 已上锁的情况下调用 signal</li><li>在 signal 之前一般要修改布尔表达式</li><li>修改布尔表达式通常要用 mutex 保护</li><li>注意区分 signal 和 broadcast： broadcast 一般用于表明状态变化，signal 通常用于表明资源可用</li></ol><h2 id="代码大赏"><a href="#代码大赏" class="headerlink" title="代码大赏"></a>代码大赏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license</span></span><br><span class="line"><span class="comment">// that can be found in the License file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Author: Shuo Chen (chenshuo at chenshuo dot com)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_BLOCKINGQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_BLOCKINGQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Condition.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"muduo/base/Mutex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BlockingQueue()</span><br><span class="line">    : mutex_(),</span><br><span class="line">      notEmpty_(mutex_),</span><br><span class="line">      queue_()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    queue_.push_back(x);</span><br><span class="line">    notEmpty_.notify(); <span class="comment">// wait morphing saves us</span></span><br><span class="line">    <span class="comment">// http://www.domaigne.com/blog/computing/condvars-signal-with-mutex-locked-or-not/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(T&amp;&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    queue_.push_back(<span class="built_in">std</span>::move(x));</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// always use a while-loop, due to spurious wakeup</span></span><br><span class="line">    <span class="keyword">while</span> (queue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      notEmpty_.wait(); <span class="comment">// 这一步会原子地 unlock mutex 并进入等待，不会与 put 思索， 执行完毕时会自动重新加锁。</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.empty());</span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">(<span class="built_in">std</span>::move(queue_.front()))</span></span>;</span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> queue_.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> MutexLock mutex_;</span><br><span class="line">  <span class="function">Condition         notEmpty_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;     <span class="function">queue_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_BASE_BLOCKINGQUEUE_H</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo/blob/master/muduo/base/BlockingQueue.h" target="_blank" rel="noopener">BlockingQueue</a></li><li>linux 多线程服务端编程–使用 muduo c++ 网络库</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std:function&amp;std:bind&amp;</title>
      <link href="/2020/10/20/std-bind-std-function/"/>
      <url>/2020/10/20/std-bind-std-function/</url>
      
        <content type="html"><![CDATA[<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码出自链接：http://www.jellythink.com/archives/771</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt; <span class="keyword">int</span>(<span class="keyword">int</span>)&gt; Functional;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [](<span class="keyword">int</span> a)-&gt;<span class="keyword">int</span>&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数(functor)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.类成员函数</span></span><br><span class="line"><span class="comment">// 2.类静态函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ClassMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StaticMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    Functional = TestFunc;</span><br><span class="line">    <span class="keyword">int</span> result = Functional(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"普通函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    Functional = lambda;</span><br><span class="line">    result = Functional(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambda表达式："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    Functor testFunctor;</span><br><span class="line">    Functional = testFunctor;</span><br><span class="line">    result = Functional(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"仿函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类成员函数</span></span><br><span class="line">    TestClass testObj;</span><br><span class="line">    Functional = <span class="built_in">std</span>::bind(&amp;TestClass::ClassMember, testObj, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">    result = Functional(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"类成员函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类静态函数</span></span><br><span class="line">    Functional = TestClass::StaticMember;</span><br><span class="line">    result = Functional(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"类静态函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   // std::bind</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPair</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a*b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">// adds visibility of _1, _2, _3,...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding functions:</span></span><br><span class="line">    <span class="keyword">auto</span> fn_five = <span class="built_in">std</span>::bind(my_divide, <span class="number">10</span>, <span class="number">2</span>);              <span class="comment">// returns 10/2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">'\n'</span>;                          <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind(my_divide, _1, <span class="number">2</span>);              <span class="comment">// returns x/2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;                        <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn_invert = <span class="built_in">std</span>::bind(my_divide, _2, _1);            <span class="comment">// returns y/x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;                    <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn_rounding = <span class="built_in">std</span>::bind&lt;<span class="keyword">int</span>&gt;(my_divide, _1, _2);   <span class="comment">// returns int(x/y)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;                  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    MyPair ten_two&#123; <span class="number">10</span>,<span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding members:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns x.multiply()</span></span><br><span class="line">    <span class="keyword">auto</span> bound_member_fn = <span class="built_in">std</span>::bind(&amp;MyPair::multiply, _1);               </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_fn(ten_two) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns ten_two.a</span></span><br><span class="line">    <span class="keyword">auto</span> bound_member_data = <span class="built_in">std</span>::bind(&amp;MyPair::a, ten_two); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_data() &lt;&lt; <span class="string">'\n'</span>;                <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function-和-bind-结合"><a href="#function-和-bind-结合" class="headerlink" title="function 和 bind 结合"></a>function 和 bind 结合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i_ = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func1 = <span class="built_in">std</span>::bind(&amp;A::output, &amp;a, <span class="built_in">std</span>::placeholders::_1,</span><br><span class="line">        <span class="built_in">std</span>::placeholders::_2);</span><br><span class="line">    func1(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>&amp;(<span class="keyword">void</span>)&gt; func2 = <span class="built_in">std</span>::bind(&amp;A::i_, &amp;a);</span><br><span class="line">    func2() = <span class="number">888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.i_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/wangshubo1989/article/details/50465693" target="_blank" rel="noopener">C++11新特性应用–实现延时求值</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现blockingqueue</title>
      <link href="/2020/10/19/%E5%AE%9E%E7%8E%B0blockingqueue/"/>
      <url>/2020/10/19/%E5%AE%9E%E7%8E%B0blockingqueue/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SyncQueue.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.size() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SyncQueue(<span class="keyword">int</span> maxSize) : m_maxSize(maxSize)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; locker(m_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (IsFull())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the blocking queue is full,waiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            m_notFull.wait(m_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        m_queue.push_back(x);</span><br><span class="line">        m_notEmpty.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Take</span><span class="params">(T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; locker(m_mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (IsEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the blocking queue is empty,wating..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            m_notEmpty.wait(m_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        x = m_queue.front();</span><br><span class="line">        m_queue.pop_front();</span><br><span class="line">        m_notFull.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; m_queue;                  <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="built_in">std</span>::mutex m_mutex;                    <span class="comment">//互斥量和条件变量结合起来使用</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable_any m_notEmpty;<span class="comment">//不为空的条件变量</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable_any m_notFull; <span class="comment">//没有满的条件变量</span></span><br><span class="line">    <span class="keyword">int</span> m_maxSize;                         <span class="comment">//同步队列最大的size</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SyncQueue.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">SyncQueue&lt;<span class="keyword">int</span>&gt; syncQueue(<span class="number">5</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Produce</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">        syncQueue.Put(<span class="number">888</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"put(888)"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Consume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">        syncQueue.Take(x);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"take(888)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer</span><span class="params">(Produce)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer1</span><span class="params">(Consume)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer2</span><span class="params">(Consume)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer3</span><span class="params">(Consume)</span></span>;</span><br><span class="line">    producer.join();</span><br><span class="line">    consumer1.join();</span><br><span class="line">    consumer2.join();</span><br><span class="line">    consumer3.join();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现数据库连接池</title>
      <link href="/2020/10/19/%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2020/10/19/%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>数据库连接池采用单例模式创建，使用 RAII 机制释放数据库连接。</p><h2 id="单例模式创建连接池"><a href="#单例模式创建连接池" class="headerlink" title="单例模式创建连接池"></a>单例模式创建连接池</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connection_pool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">//局部静态变量单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    connection_pool();</span><br><span class="line">    ~connection_pool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection_pool *connection_pool::GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> connection_pool connPool;</span><br><span class="line">    <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">connection_pool::connection_pool()</span><br><span class="line">&#123;</span><br><span class="line">m_CurConn = <span class="number">0</span>;</span><br><span class="line">m_FreeConn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造初始化</span></span><br><span class="line"><span class="keyword">void</span> connection_pool::init(<span class="built_in">string</span> url, <span class="built_in">string</span> User, <span class="built_in">string</span> PassWord, <span class="built_in">string</span> DBName, <span class="keyword">int</span> Port, <span class="keyword">int</span> MaxConn, <span class="keyword">int</span> close_log)</span><br><span class="line">&#123;</span><br><span class="line">m_url = url;</span><br><span class="line">m_Port = Port;</span><br><span class="line">m_User = User;</span><br><span class="line">m_PassWord = PassWord;</span><br><span class="line">m_DatabaseName = DBName;</span><br><span class="line">m_close_log = close_log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)</span><br><span class="line">&#123;</span><br><span class="line">MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">con = mysql_init(con);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">LOG_ERROR(<span class="string">"MySQL Error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">con = mysql_real_connect(con, url.c_str(), User.c_str(), PassWord.c_str(), DBName.c_str(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">LOG_ERROR(<span class="string">"MySQL Error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">connList.push_back(con);</span><br><span class="line">++m_FreeConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reserve = sem(m_FreeConn);</span><br><span class="line"></span><br><span class="line">m_MaxConn = m_FreeConn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-amp-释放连接"><a href="#获取-amp-释放连接" class="headerlink" title="获取&amp;释放连接"></a>获取&amp;释放连接</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line">MYSQL *connection_pool::GetConnection()</span><br><span class="line">&#123;</span><br><span class="line">MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == connList.size())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">reserve.wait();  <span class="comment">// 取出连接，信号量原子 -1， 为0则等待</span></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">con = connList.front();</span><br><span class="line">connList.pop_front();</span><br><span class="line"></span><br><span class="line">--m_FreeConn;</span><br><span class="line">++m_CurConn;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放当前使用的连接</span></span><br><span class="line"><span class="keyword">bool</span> connection_pool::ReleaseConnection(MYSQL *con)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">connList.push_back(con);</span><br><span class="line">++m_FreeConn;</span><br><span class="line">--m_CurConn;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">reserve.post();  <span class="comment">// 释放连接 原子+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销毁连接池"><a href="#销毁连接池" class="headerlink" title="销毁连接池"></a>销毁连接池</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁数据库连接池</span></span><br><span class="line"><span class="keyword">void</span> connection_pool::DestroyPool()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span> (connList.size() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;MYSQL *&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = connList.begin(); it != connList.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">MYSQL *con = *it;</span><br><span class="line">mysql_close(con);</span><br><span class="line">&#125;</span><br><span class="line">m_CurConn = <span class="number">0</span>;</span><br><span class="line">m_FreeConn = <span class="number">0</span>;</span><br><span class="line">connList.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RAII-释放数据库连接"><a href="#RAII-释放数据库连接" class="headerlink" title="RAII 释放数据库连接"></a>RAII 释放数据库连接</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connectionRAII</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//双指针对MYSQL *con修改</span></span><br><span class="line">    connectionRAII(MYSQL **con, connection_pool *connPool);</span><br><span class="line">    ~connectionRAII();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *conRAII;</span><br><span class="line">    connection_pool *poolRAII;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不直接调用获取和释放连接的接口，将其封装起来，通过RAII机制进行获取和释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">connectionRAII::connectionRAII(MYSQL **SQL, connection_pool *connPool)&#123;</span><br><span class="line">*SQL = connPool-&gt;GetConnection();</span><br><span class="line"></span><br><span class="line">conRAII = *SQL;</span><br><span class="line">poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~connectionRAII()&#123;</span><br><span class="line">poolRAII-&gt;ReleaseConnection(conRAII);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/qinguoyi/TinyWebServer/blob/master/CGImysql/sql_connection_pool.h" target="_blank" rel="noopener">sql_connection_pool</a></li><li><a href="https://mp.weixin.qq.com/s/7ayetU5tYn3k6K59G5adSA" target="_blank" rel="noopener">11 数据库连接池</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 数据库连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现时间轮</title>
      <link href="/2020/10/19/%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
      <url>/2020/10/19/%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E8%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li>[游双-linux高性能服务器编程]</li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11 计时器</title>
      <link href="/2020/10/19/c-11%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
      <url>/2020/10/19/c-11%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h2><p>这里主要介绍时间点和时钟两个点：</p><p>​        一般计时器就是从某个时间点开始，然后到某个时间点之间的计数，就是我们一般称之为耗时；</p><p><strong>时间点：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Clock</span>, <span class="title">class</span> <span class="title">Duration</span> = <span class="title">typename</span> <span class="title">Clock</span>:</span>:duration&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">time_point</span>;</span></span><br></pre></td></tr></table></figure><p>std::chrono::time_point 表示一个具体时间</p><p>第一个模板参数Clock用来指定所要使用的时钟,在标准库中有三种时钟，分别为：</p><ul><li>system_clock：当前系统范围(即对各进程都一致)的一个实时的日历时钟(wallclock)</li><li>steady_clock：当前系统实现的一个维定时钟，该时钟的每个时间嘀嗒单位是均匀的(即长度相等)。</li><li>high_resolution_clock：当前系统实现的一个高分辨率时钟。</li></ul><p>第二个模板函数参数用来表示时间的计量单位(特化的std::chrono::duration&lt;&gt; )</p><p>时间点都有一个时间戳，即时间原点。chrono库中采用的是Unix的时间戳1970年1月1日 00:00。所以time_point也就是距离时间戳(epoch)的时间长度（duration)</p><h2 id="实现高精度计时器"><a href="#实现高精度计时器" class="headerlink" title="实现高精度计时器"></a>实现高精度计时器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TimerClock_hpp_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TimerClock_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerClock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> TimerClock()</span><br><span class="line"> &#123;</span><br><span class="line">  update();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~TimerClock()</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  _start = high_resolution_clock::now();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取秒</span></span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getTimerSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getTimerMicroSec() * <span class="number">0.000001</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取毫秒</span></span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getTimerMilliSec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getTimerMicroSec()*<span class="number">0.001</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取微妙</span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getTimerMicroSec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//当前时钟减去开始时钟的count</span></span><br><span class="line">  <span class="keyword">return</span> duration_cast&lt;microseconds&gt;(high_resolution_clock::now() - _start).count();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> time_point&lt;high_resolution_clock&gt;_start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TimerClock.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> TimerClock TC;</span><br><span class="line"> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> TC.update();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &gt; <span class="number">100000</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  sum++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"cost time:"</span> &lt;&lt; TC.getTimerMilliSec() &lt;&lt;<span class="string">"ms"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"cost time:"</span> &lt;&lt; TC.getTimerMicroSec() &lt;&lt; <span class="string">"us"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/137626056" target="_blank" rel="noopener">飞翔的猪</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现简单的固定线程数的线程池</title>
      <link href="/2020/10/19/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BA%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/10/19/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BA%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">作者：Graphene</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/27908489/answer/355105668</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fixed_thread_pool</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">fixed_thread_pool</span><span class="params">(<span class="keyword">size_t</span> thread_count)</span></span></span><br><span class="line">      : data_(std::make_shared&lt;data&gt;()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; thread_count; ++i) &#123;</span><br><span class="line">      <span class="built_in">std</span>::thread([data = data_] &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(data-&gt;mtx_);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!data-&gt;tasks_.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> current = <span class="built_in">std</span>::move(data-&gt;tasks_.front());</span><br><span class="line">            data-&gt;tasks_.pop();</span><br><span class="line">            lk.unlock();</span><br><span class="line">            current();</span><br><span class="line">            lk.lock();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data-&gt;is_shutdown_) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data-&gt;cond_.wait(lk);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).detach();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fixed_thread_pool() = <span class="keyword">default</span>;</span><br><span class="line">  fixed_thread_pool(fixed_thread_pool&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~fixed_thread_pool() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">bool</span>) data_) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(data_-&gt;mtx_);</span><br><span class="line">        data_-&gt;is_shutdown_ = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      data_-&gt;cond_.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">execute</span>(<span class="title">F</span>&amp;&amp; <span class="title">task</span>) &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(data_-&gt;mtx_);</span><br><span class="line">      data_-&gt;tasks_.emplace(<span class="built_in">std</span>::forward&lt;F&gt;(task));</span><br><span class="line">    &#125;</span><br><span class="line">    data_-&gt;cond_.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::mutex mtx_;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable cond_;</span><br><span class="line">    <span class="keyword">bool</span> is_shutdown_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks_;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt; data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非常僵硬的看不懂了，之后再来回味。。。。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.zhihu.com/question/27908489/answer/355105668" target="_blank" rel="noopener">Graphene</a></li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实现简单的线程安全Queue</title>
      <link href="/2020/10/19/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8Queue/"/>
      <url>/2020/10/19/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8Queue/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread safe implementation of a Queue using an std::queue</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; m_queue;</span><br><span class="line">  <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  SafeQueue() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SafeQueue(SafeQueue&amp; other) &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~SafeQueue() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);</span><br><span class="line">    <span class="keyword">return</span> m_queue.empty();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);</span><br><span class="line">    <span class="keyword">return</span> m_queue.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);</span><br><span class="line">    m_queue.push(t);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_queue.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="built_in">std</span>::move(m_queue.front());</span><br><span class="line">    </span><br><span class="line">    m_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/mtrebi/thread-pool/blob/master/include/SafeQueue.h" target="_blank" rel="noopener">SafeQueue</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现string类</title>
      <link href="/2020/10/19/%E5%AE%9E%E7%8E%B0string%E7%B1%BB/"/>
      <url>/2020/10/19/%E5%AE%9E%E7%8E%B0string%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String()</span><br><span class="line">        :data_(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        *data_ = <span class="string">'\0'</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>&amp; str) </span><br><span class="line">        :data_(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, str);</span><br><span class="line">    &#125;</span><br><span class="line">    String(<span class="keyword">const</span> String&amp; rhs) </span><br><span class="line">        :data_(<span class="keyword">new</span> <span class="keyword">char</span>[rhs.size() + <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, rhs.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* traditional</span></span><br><span class="line"><span class="comment">    String&amp; operator=(const String&amp; rhs) </span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        String tmp(rhs);</span></span><br><span class="line"><span class="comment">        swap(tmp);</span></span><br><span class="line"><span class="comment">        return *this</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// C++ 11</span></span><br><span class="line">    String(String&amp;&amp; rhs)</span><br><span class="line">      : data_(rhs.data_)</span><br><span class="line">    &#123;</span><br><span class="line">    rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String&amp;&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(data_);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(String&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(data_, rhs.data_);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span>* data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String&amp; <span class="keyword">operator</span>=(String rhs) <span class="comment">// yes, pass-by-value</span></span><br><span class="line">&#123;</span><br><span class="line">swap(rhs);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用swap的原因是，这个String类涉及到内存分配操作，这个操作可能会抛出异常；<br>上面的实现分3步：</p><ol><li>把“源对象”拷贝到参数rhs里</li><li>rhs对象和this对象做一下交换（仅仅交换指针）</li><li>返回this对象</li></ol><p>第一步有可能发生异常（new操作失败），然后在这一步退出；这是下两歩操作还没有进行，所以不会污染this对象。保证了：</p><ol><li>赋值操作失败，但是this对象没有被污染，或者</li><li>赋值操作成功</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/recipes/blob/master/string/StringTrivial.h" target="_blank" rel="noopener">chenshuo</a></li><li><a href="https://coolshell.cn/articles/10478.html" target="_blank" rel="noopener">coolshell</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Noncopyable</title>
      <link href="/2020/10/19/Noncopyable/"/>
      <url>/2020/10/19/Noncopyable/</url>
      
        <content type="html"><![CDATA[<p>在 Muduo 中，有一个 noncopyable 类，继承了该类的派生类不能被拷贝，只能被移动。涉及拷贝的函数有两个：拷贝构造函数和拷贝复制操作符。将这两个方法声明为不可访问或者删除，就可以达到不可拷贝的效果。</p><h2 id="将函数声明为-private"><a href="#将函数声明为-private" class="headerlink" title="将函数声明为 private"></a>将函数声明为 private</h2><p>将拷贝构造函数和拷贝复制操作符声明为 private，能阻止编译器创建这两个函数，同时阻止用户调用他们，从而达到阻止拷贝的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  noncopyable() &#123;&#125;</span><br><span class="line">  ~noncopyable() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// emphasize the following members are private</span></span><br><span class="line">  noncopyable( <span class="keyword">const</span> noncopyable&amp; );</span><br><span class="line">  noncopyable&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> noncopyable&amp; );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>:</span> <span class="keyword">private</span> noncopyable&#123;&#125;;</span><br></pre></td></tr></table></figure><p>一定要使用 private 来继承，防止 member 函数和 friend 函数访问。</p><h2 id="c-11-使用-delete关键字"><a href="#c-11-使用-delete关键字" class="headerlink" title="c++11 使用 delete关键字"></a>c++11 使用 delete关键字</h2><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">~noncopyable() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">noncopyable(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">const</span> noncopyable&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> noncopyable&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把构造函数和析构函数设置为 protected 权限，这样子类可以调用，外面的其他类不能调用。</p><p>使用 delete 关键字禁止编译器自动产生 copy 构造函数，和copy assignment ctor。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">muduo</a></li><li><a href="https://segmentfault.com/a/1190000020400025" target="_blank" rel="noopener">segmentfault</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象池</title>
      <link href="/2020/10/18/%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2020/10/18/%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>对象池对于创建开销比较大的对象来说很有意义，为了避免重复创建开销比较大的对象，我们可以通过对象池来优化。对象池的思路比较简单，事先创建好一批对象，放到一个集合中，以后每当程序需要新的对象时候，都从对象池里获取，每当程序用完该对象后，都把该对象归还给对象池。这样会避免重复的对象创建，提高程序性能。</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Object&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    ObjectPool(<span class="keyword">size_t</span> unSize) :</span><br><span class="line">        m_unSize(unSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> unIdx = <span class="number">0</span>; unIdx &lt; m_unSize; ++ unIdx) &#123;</span><br><span class="line">            m_oPool.push_back(<span class="keyword">new</span> Object());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~ObjectPool()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Object *&gt;::iterator oIt = m_oPool.begin();</span><br><span class="line">        <span class="keyword">while</span> (oIt != m_oPool.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> (*oIt);</span><br><span class="line">            ++ oIt;</span><br><span class="line">        &#125;</span><br><span class="line">        m_unSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Object * <span class="title">GetObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object * pObj = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_unSize)</span><br><span class="line">        &#123;</span><br><span class="line">            pObj = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pObj = m_oPool.front();</span><br><span class="line">            m_oPool.pop_front();</span><br><span class="line">            -- m_unSize;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> pObj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReturnObject</span><span class="params">(Object * pObj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_oPool.push_back(pObj);</span><br><span class="line">        ++ m_unSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> m_unSize;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;object *&gt; m_oPool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不足点如下：</p><ol><li>对象池ObjectPool<t>只能容纳特定类型的对象，不能容纳所有类型的对象，可以支持重载的和参数不同的构造函数；</t></li><li>对象用完之后需要手动回收，用起来不够方便，更大的问题是存在忘记回收的风险；</li></ol><p>希望能有一个更强大的对象池，这个对象池能容纳所有的对象，还能自动回收用完了对象，不需要手动回收，用起来更方便。要实现这样的对象池需要解决前面提到的两个问题，通过c++11就可以解决这两个问题。</p><p>　　对于问题1：容纳所有的对象。本质上需要将对象池中的对象类型擦除，这里用Any类型就可以解决。</p><p>　　对于问题2：自动回收用完的对象。这里用智能指针就可以解决，在创建智能指针时可以指定删除器，在删除器中不删除对象，而是回收到对象池中，而这个过程对外界来说是看不见的，由智能指针自己完成。</p><p>​        暂时不考虑解决问题一。</p><h3 id="一个支持自动回收的对象池实现"><a href="#一个支持自动回收的对象池实现" class="headerlink" title="一个支持自动回收的对象池实现"></a>一个支持自动回收的对象池实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IG_SHARED_OBJECT_POOL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IG_SHARED_OBJECT_POOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ig &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kObjectPoolDefaultSize = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kObjectPoolDefaultExtendSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ObjectType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectPoolDefaultInitializer</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ObjectType *object)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ObjectType, <span class="keyword">size_t</span> N = kObjectPoolDefaultSize,</span><br><span class="line">    <span class="keyword">typename</span> Initializer = ObjectPoolDefaultInitializer&lt;ObjectType&gt; &gt;</span><br><span class="line">class SharedObjectPool &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> SharedObjectPool&amp; Instance() &#123;</span><br><span class="line">    <span class="keyword">static</span> SharedObjectPool pool(N);</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ObjectType&gt; Get() &#123;</span><br><span class="line">    ObjectType *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (queue_.empty()) &#123;</span><br><span class="line">      Extend(kObjectPoolDefaultExtendSize);</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = queue_.front();</span><br><span class="line">    queue_.pop();</span><br><span class="line">    kInitializer(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ObjectType&gt;(ptr, [&amp;](ObjectType *p) &#123;</span><br><span class="line">      queue_.push(p);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> capacity_;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_capacity</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity_ &lt; capacity) &#123;</span><br><span class="line">      Extend(capacity - capacity_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  explicit SharedObjectPool(const size_t pool_size) :</span><br><span class="line">      kDefaultCacheSize(pool_size) &#123;</span><br><span class="line">    cache_ = <span class="keyword">new</span> ObjectType[kDefaultCacheSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kDefaultCacheSize; ++i) &#123;</span><br><span class="line">      queue_.push(&amp;cache_[i]);</span><br><span class="line">      kInitializer(&amp;cache_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    capacity_ = kDefaultCacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ~SharedObjectPool() &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache_) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] cache_;</span><br><span class="line">      cache_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ptr : extended_cache_) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    extended_cache_.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Extend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      ObjectType *ptr = <span class="keyword">new</span> ObjectType;</span><br><span class="line">      extended_cache_.push_back(ptr);</span><br><span class="line">      queue_.push(ptr);</span><br><span class="line">      kInitializer(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    capacity_ = kDefaultCacheSize + extended_cache_.size();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> capacity_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;ObjectType*&gt; queue_;</span><br><span class="line"></span><br><span class="line">  ObjectType *cache_ = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;ObjectType*&gt; extended_cache_;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultCacheSize;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> Initializer kInitializer;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ObjectType, <span class="keyword">size_t</span> N, <span class="keyword">typename</span> Initializer&gt;</span><br><span class="line"><span class="keyword">const</span> Initializer</span><br><span class="line">    SharedObjectPool&lt;ObjectType, N, Initializer&gt;::kInitializer;</span><br><span class="line">&#125;  <span class="comment">// namespace ig</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// IG_SHARED_OBJECT_POOL_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/73066435" target="_blank" rel="noopener">对象池</a></li><li><a href="https://www.cnblogs.com/qicosmos/p/3673723.html" target="_blank" rel="noopener">一个超级对象池的实现</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pImpl</title>
      <link href="/2020/10/18/pImpl/"/>
      <url>/2020/10/18/pImpl/</url>
      
        <content type="html"><![CDATA[<p>pImpl（Private Implementation 或 Pointer to Implementation）是通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏。</p><p>优点：</p><ol><li>降低模块的耦合。因为隐藏了类的实现，被隐藏的类相当于原类不可见，对隐藏的类进行修改，不需要重新编译原类。</li><li>降低编译依赖，提高编译速度。</li><li>接口与实现分离，提高接口的稳定性。</li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LINE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LINE_H__</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//设计模式: PIMPL</span></span><br><span class="line"><span class="comment">//1. 实现信息隐藏</span></span><br><span class="line"><span class="comment">//2. 减小编译依赖, 可以用最小的代价平滑的升级库文件，</span></span><br><span class="line"><span class="comment">//3. 接口与实现进行解耦</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">    ~Line();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LineImpl</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LineImpl * _pimpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>:</span>:LineImpl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Point(<span class="keyword">int</span> ix = <span class="number">0</span>, <span class="keyword">int</span> iy = <span class="number">0</span>)</span><br><span class="line">        : _ix(ix)</span><br><span class="line">        , _iy(iy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Point(int=0, int=0)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; _ix</span><br><span class="line">                 &lt;&lt; <span class="string">","</span> &lt;&lt; _iy</span><br><span class="line">                 &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _ix;</span><br><span class="line">        <span class="keyword">int</span> _iy;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LineImpl(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span><br><span class="line">    : _p1(x1, y1)</span><br><span class="line">    , _p2(x2, y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"LineImpl(int,int,int,int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~LineImpl() &#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"~LineImpl()"</span> &lt;&lt; <span class="built_in">endl</span>;  &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point _p1;</span><br><span class="line">    Point _p2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Line::LineImpl::printLine() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    _p1.print();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" --&gt; "</span>;</span><br><span class="line">    _p2.print();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::Line(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span><br><span class="line">: _pimpl(<span class="keyword">new</span> LineImpl(x1, y1, x2, y2))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line(int,int,int,int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~Line()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> _pimpl;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Line()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Line::printLine() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    _pimpl-&gt;printLine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/cthon/p/9196258.html" target="_blank" rel="noopener">cnblogs</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAII</title>
      <link href="/2020/10/18/RAII/"/>
      <url>/2020/10/18/RAII/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是RAII"><a href="#什么是RAII" class="headerlink" title="什么是RAII"></a>什么是RAII</h2><p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由 c++ 之父 Bjarne Stroustrup 提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><h2 id="RAII的原理"><a href="#RAII的原理" class="headerlink" title="RAII的原理"></a>RAII的原理</h2><p>资源的使用一般经历三个步骤</p><ol><li>获取资源 </li><li>使用资源 </li><li><p>销毁资源。</p><p>但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++ 之父给出了解决问题的方案：RAII，它充分的利用了 C++ 语言局部对象自动销毁的特性来控制资源的生命周期。给一个简单的例子来看下局部对象的自动销毁的特性：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>) : </span><br><span class="line">      name_(name), age_(age) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Init a person!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ~person() &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destory a person!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getname</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name_;</span><br><span class="line">      &#125;    </span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age_;</span><br><span class="line">      &#125;      </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">      <span class="keyword">int</span> age_;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    person p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译并运行：</span></span><br><span class="line"><span class="comment">g++ person.cpp -o person</span></span><br><span class="line"><span class="comment">./person </span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">Init a person!</span></span><br><span class="line"><span class="comment">Destory a person!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从 person class 可以看出，当我们在 main 函数中声明一个局部对象的时候，会自动调用构造函数进行对象的初始化，当整个 main 函数执行完成后，自动调用析构函数来销毁对象，整个过程无需人工介入，由操作系统自动完成；于是，很自然联想到，当我们在使用资源的时候，在构造函数中进行初始化，在析构函数中进行销毁。整个RAII 过程我总结四个步骤：</p><ol><li>设计一个类封装资源</li><li>在构造函数中初始化</li><li>在析构函数中执行销毁操作</li><li>使用时声明一个该对象的类</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>linux 下经常会使用多线程技术，说到多线程，就得提到互斥锁，互斥锁主要用于互斥，互斥是一种<strong>竞争关系</strong>，用来保护临界资源一次只被一个线程访问，按照我们前面的分析，封装一下 POSIX 标准的互斥锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Mutex();</span><br><span class="line">  ~Mutex();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unlock</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> mu_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying</span></span><br><span class="line">  Mutex(<span class="keyword">const</span> Mutex&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Mutex&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mutex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PthreadCall</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* label, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread %s: %s\n"</span>, label, strerror(result));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mutex::Mutex() &#123; PthreadCall(<span class="string">"init mutex"</span>, pthread_mutex_init(&amp;mu_, <span class="literal">NULL</span>)); &#125;</span><br><span class="line"></span><br><span class="line">Mutex::~Mutex() &#123; PthreadCall(<span class="string">"destroy mutex"</span>, pthread_mutex_destroy(&amp;mu_)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mutex::Lock() &#123; PthreadCall(<span class="string">"lock"</span>, pthread_mutex_lock(&amp;mu_)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mutex::Unlock() &#123; PthreadCall(<span class="string">"unlock"</span>, pthread_mutex_unlock(&amp;mu_)); &#125;</span><br></pre></td></tr></table></figure><p>写到这里其实就可以使用 Mutex 来锁定临界区，但我们发现 Mutex 只是用来对锁的初始化和销毁，我们还得在代码中调用 Lock 和 Unlock 函数，这又是一个对立操作，所以我们可以继续使用 RAII 进行封装，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mutex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MutexLock</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutexLock</span><span class="params">(Mutex *mu)</span></span></span><br><span class="line">      : mu_(mu)  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mu_-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line">  ~MutexLock() &#123; <span class="keyword">this</span>-&gt;mu_-&gt;Unlock(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Mutex *<span class="keyword">const</span> mu_;</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  MutexLock(<span class="keyword">const</span> MutexLock&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> MutexLock&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mutexlock.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    NUM_THREADS     10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">Mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">count</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread[NUM_THREADS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) &#123;   </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;thread[t], <span class="literal">NULL</span>, count, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret) &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( t = <span class="number">0</span>; t &lt; NUM_THREADS; t++)</span><br><span class="line">        pthread_join(thread[t], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译并运行：g++ test_mutexlock.cpp mutexlock.hpp mutex.cpp mutex.h -o test_mutexlock -lpthread</span></span><br><span class="line"><span class="comment">./test_mutexlock </span></span><br><span class="line"><span class="comment">运行结果：10000  符合预期（可以去掉MutexLock lock(&amp;mutex);试试看看结果如何？）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/34660259" target="_blank" rel="noopener">知乎</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2020/10/18/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2020/10/18/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SharedPointer():m_refCount(<span class="literal">nullptr</span>), m_pointer(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    SharedPointer(T* adoptTarget):m_refCount(<span class="literal">nullptr</span>), m_pointer(adoptTarget) &#123;</span><br><span class="line">        addReference();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SharedPointer(<span class="keyword">const</span> SharedPointer&lt;T&gt;&amp; copy):m_refCount(copy.m_refCount), m_pointer(copy.m_pointer) &#123;</span><br><span class="line">        addReference();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~SharedPointer() &#123;</span><br><span class="line">        removeReference();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值操作</span></span><br><span class="line">    <span class="comment">//当左值被赋值时，表明它不再指向所指的资源，故引用计数减一</span></span><br><span class="line">    <span class="comment">//之后，它指向了新的资源，所以对应这个资源的引用计数加一</span></span><br><span class="line">    SharedPointer&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPointer&lt;T&gt;&amp; that) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;that) &#123;</span><br><span class="line">            removeReference();</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_pointer = that.m_pointer;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_refCount = that.m_refCount;</span><br><span class="line">            addReference();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否指向同一个资源</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> SharedPointer&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer == other.m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> SharedPointer&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">operator</span>==(other);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针解引用</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用所知对象的公共成员</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取引用计数个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetReferenceCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_refCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> *m_refCount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当为nullpter时，创建引用计数资源，并初始化为1</span></span><br><span class="line">    <span class="comment">//否则，引用计数加1。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_refCount) &#123;</span><br><span class="line">            (*m_refCount)++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_refCount = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">            *m_refCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_refCount) &#123;</span><br><span class="line">            (*m_refCount)--;</span><br><span class="line">            <span class="keyword">if</span>(*m_refCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_refCount;</span><br><span class="line">                <span class="keyword">delete</span> m_pointer;</span><br><span class="line">                m_refCount = <span class="number">0</span>;</span><br><span class="line">                m_pointer = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *m_refCount;</span><br><span class="line">    T *m_pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Singleton--C++</title>
      <link href="/2020/10/18/Singleton-c/"/>
      <url>/2020/10/18/Singleton-c/</url>
      
        <content type="html"><![CDATA[<h3 id="懒汉版"><a href="#懒汉版" class="headerlink" title="懒汉版"></a>懒汉版</h3><h4 id="最简版"><a href="#最简版" class="headerlink" title="最简版"></a>最简版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    ~Singleton() &#123;&#125;;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>存在内存泄漏的问题，解决方案：</p><ol><li>使用智能指针</li><li>使用静态的嵌套类对象</li></ol><h4 id="使用静态的嵌套类对象"><a href="#使用静态的嵌套类对象" class="headerlink" title="使用静态的嵌套类对象"></a>使用静态的嵌套类对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    ~Singleton() &#123;&#125;;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Deletor</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Deletor() &#123;</span><br><span class="line">            <span class="keyword">if</span>(Singleton::instance != <span class="literal">NULL</span>) <span class="keyword">delete</span> Singleton::instance;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> Deletor deletor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>在程序运行结束时，系统会调用静态成员 deletor 的析构函数，该析构函数会删除单例的唯一实例。</p><p>使用这种方法释放单例对象有以下特征：</p><ul><li>在单例类内部定义专有的嵌套类。</li><li>在单例类内定义私有的专门用于释放的静态成员。</li><li>利用程序在结束时析构全局变量的特性，选择最终的释放时机。</li></ul><p>上述代码不仅麻烦，并且在多线程环境下会出现竞争，考虑使用双检测锁模式（Double-Checked locking Pattern)</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mt.lock();  <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">if</span>(_instance == <span class="number">0</span>)</span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        mt.unlock();  <span class="comment">// 解锁</span></span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* _instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::_instance = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上锁后是解决了线程安全问题，但是有些资源浪费。稍微分析一下：每次instance函数调用时候都需要请求加锁，其实并不需要，instance函数只需第一次调用的时候上锁就行了。这时可以用DCLP解决。</p><h4 id="双检查锁，由于内存读写导致不安全"><a href="#双检查锁，由于内存读写导致不安全" class="headerlink" title="双检查锁，由于内存读写导致不安全"></a>双检查锁，由于内存读写导致不安全</h4><p><strong>Double-Checked Locking Pattern</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_instance == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mt.lock();</span><br><span class="line">            <span class="keyword">if</span>(_instance == <span class="number">0</span>)</span><br><span class="line">                _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            mt.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* _instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> atestvalue;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::_instance = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这个版本很不错，又叫“双重检查”Double-Check。下面是说明：</p><ol><li>第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。</li><li>不然，我们就开始同步线程。</li><li>第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。</li></ol><p><strong>分析</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_instance = new Singleton();</span><br></pre></td></tr></table></figure><p>为了执行这句代码，机器需要做三样事儿：</p><ol><li>singleton对象分配空间。</li><li>在分配的空间中构造对象</li><li>使_instance指向分配的空间</li></ol><p>遗憾的是编译器并不是严格按照上面的顺序来执行的。可以交换2和3.</p><p>将上面三个步骤标记到代码中就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Singleton* Singleton::instance() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="number">0</span>) &#123;</span><br><span class="line">        mt.lock();</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="number">0</span>) &#123;</span><br><span class="line">            _instance = <span class="comment">// Step 3</span></span><br><span class="line">            <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Singleton)); <span class="comment">// Step 1</span></span><br><span class="line">            <span class="keyword">new</span> (_instance) Singleton; <span class="comment">// Step 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        mt.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程A进入了instance函数，并且执行了step1和step3，然后挂起。这时的状态是：_instance不 NULL，而_instance指向的内存区没有对象！</li><li>线程B进入了instance函数，发现_instance不为null，就直接return _instance了。</li></ul><h4 id="local-static"><a href="#local-static" class="headerlink" title="local static"></a>local static</h4><p>C++ 11 规定了 local static 在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton() &#123; &#125;;</span><br><span class="line">~Singleton() &#123; &#125;;</span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> <span class="comment">// 返回引用</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"><span class="keyword">static</span> Singleton instance; <span class="comment">// 静态局部变量</span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>gcc 4.0之后的编译器支持这种写法。</li><li>C++11及以后的版本（如C++14）的多线程下，正确。</li><li>C++11之前<strong>不能</strong>这么写。</li></ol><h4 id="C-11-call-once"><a href="#C-11-call-once" class="headerlink" title="C++11 call_once"></a>C++11 call_once</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::call_once(flag, []() &#123;instance_.reset(<span class="keyword">new</span> Singleton()); &#125;);</span><br><span class="line"><span class="keyword">return</span> *instance_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Singleton&gt; instance_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton() = <span class="keyword">default</span>;</span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Singleton&gt; Singleton::instance_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_onceflag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton&amp; s = Singleton::getInstance();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(do_onceflag)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(do_onceflag)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉版"><a href="#饿汉版" class="headerlink" title="饿汉版"></a>饿汉版</h3><p>单例实例在程序运行时被立即执行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton();</span><br><span class="line">~Singleton();</span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::instance;</span><br></pre></td></tr></table></figure><p>由于在 main 函数之前初始化，所以没有线程安全的问题。但是潜在问题在于 no-local static 对象（函数外的 static对象）在不同编译单元中的初始化顺序是未定义的。也即，static Singleton instance;和 static Singleton&amp; getInstance() 二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写一个 Move aware class</title>
      <link href="/2020/10/16/%E5%86%99%E4%B8%80%E4%B8%AA-move-aware-class/"/>
      <url>/2020/10/16/%E5%86%99%E4%B8%80%E4%B8%AA-move-aware-class/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> DCtor;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> Ctor;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CAsgn;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MCtor;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> Dtor;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _data;</span><br><span class="line">    <span class="keyword">size_t</span> _len;</span><br><span class="line">    <span class="keyword">void</span> _init_data(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(_data, s, _len);</span><br><span class="line">        _data[_len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default ctor</span></span><br><span class="line">    MyString(): _data(<span class="literal">NULL</span>), _len(<span class="number">0</span>) &#123;</span><br><span class="line">        ++DCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ctor</span></span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* p): _len(<span class="built_in">strlen</span>(p)) &#123;</span><br><span class="line">        ++Ctor;</span><br><span class="line">        _init_data(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// copy ctor</span></span><br><span class="line">    MyString(<span class="keyword">const</span> Mystring&amp; str):_len(str._len) &#123;</span><br><span class="line">        ++CCtor;</span><br><span class="line">        _init_data(str._data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// move ctor</span></span><br><span class="line">    MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">        :_data(str._data), _len(str._len) &#123;</span><br><span class="line">        ++MCtor;</span><br><span class="line">        str._len = <span class="number">0</span>;</span><br><span class="line">        str._data = <span class="literal">NULL</span>;<span class="comment">// IMPORTANT</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// copy assignment</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">        ++CAsgn;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;  <span class="comment">// 自我赋值检查</span></span><br><span class="line">            <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">            _len = str._len;</span><br><span class="line">            _init_data(str._data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// move assignment</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">        ++MAsgn;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;  <span class="comment">// 自我赋值检查</span></span><br><span class="line">            <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">            _len = str._len;</span><br><span class="line">            _data = str._data;</span><br><span class="line">            str._len = <span class="number">0</span>;</span><br><span class="line">            str._data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dtor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MyString() &#123;  </span><br><span class="line">        ++Dtor;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// operator&lt;</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>-&gt;data) &lt; <span class="built_in">string</span>(rhs._data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// operator==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>-&gt;data) == <span class="built_in">string</span>(rhs._data); </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _data; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> MyString::DCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::Ctor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::Dtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;MyString&gt; &#123;</span> <span class="comment">// for unordered containers</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>() (<span class="keyword">const</span> MyString&amp; s) <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(<span class="built_in">string</span>(s.get()));</span><br><span class="line">        <span class="comment">// 借用现成的 hash&lt;string&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rvalue references</title>
      <link href="/2020/10/16/Rvalue-references/"/>
      <url>/2020/10/16/Rvalue-references/</url>
      
        <content type="html"><![CDATA[<h3 id="Rvalue-references"><a href="#Rvalue-references" class="headerlink" title="Rvalue-references"></a>Rvalue-references</h3><p>Rvalue references are a new reference type introduced in C++0x that help solve the problem of unnecessary coping and enable perfect forwarding. When the right-hand side of  an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a seperate allocation, thus enabling move semantics.</p><p>Lvalue: 可以出现于 operator = 左侧者</p><p>Rvalue: 只能出现于 operator  = 右侧者</p><p><img src="\images/image-20201016163813510.png" alt=""></p><p>只要在内存中有确定存储空间的都是左值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = foo(); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;foo(); <span class="comment">// error 对着右值 5 取其 reference 是不可以的。没有所谓的 Rvalue reference（before C++0x)</span></span><br><span class="line">foo() = <span class="number">7</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>当 Rvalue 出现于 operator=(copy assignment)的右侧，我们认为对其资源进行偷取/搬移（move) 而非拷贝（copy）是可以的。</p><p>那么：</p><ol><li>必须有语法让我们在调用端告诉编译器，这是个“Rvalue”</li><li>必须有语法让我们在被调用端写出一个专门处理 Rvalue 的所谓 move assignment 函数。</li></ol><p><img src="\images/image-20201016164558875.png" alt=""></p><h4 id="Perfect-Forwarding"><a href="#Perfect-Forwarding" class="headerlink" title="Perfect Forwarding"></a>Perfect Forwarding</h4><p><img src="\images/image-20201016170713823.png" alt=""></p><p>Perfect forwarding allows you to write a single function template that takes n arbitrary arguments and forwards them transparently to another arbitrary function. The nature of the argument(modifiable, const, lvalue, rvalue) is preserved in the forwarding process.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">(T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class="line">    functionB(<span class="built_in">std</span>::forward&lt;T1&gt;(t1), <span class="built_in">std</span>::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda</title>
      <link href="/2020/10/16/lambda/"/>
      <url>/2020/10/16/lambda/</url>
      
        <content type="html"><![CDATA[<p>C++11 introduced  lambdas, allowing the definition of inline functionality, which can be used as a parameter or  a local object. Lambdas change the way the C++ statndard library is used.</p><p>A lambda is a definition of functionality that can be defined inside statements and expressions. Thus, you can use a lambda as an inline function. The minimal lambda function has no parameters and simply does something.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"hello lambda"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> l = [] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"hello lambda"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l();</span><br></pre></td></tr></table></figure><p><img src="\images/image-20201016155359481.png" alt=""></p><p><img src="\images/image-20201016155639272.png" alt=""></p><p><img src="\images/image-20201016160037765.png" alt=""></p><p> <img src="\images/image-20201016160305216.png" alt=""></p><p><img src="\images/image-20201016161039247.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>decltype</title>
      <link href="/2020/10/16/decltype/"/>
      <url>/2020/10/16/decltype/</url>
      
        <content type="html"><![CDATA[<p>Defines  a type equivalent to the type of an expression.</p><p>By using the decltype keyword, you can let the compiler find out the type of an expression, this is the realization of the often requested typepf feature.</p><p>One application of decltype is to declare return types; Another is to use it in metaprogramming or to pass the type of a lambda.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. declare return types</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x + y) add(T1 x, T2 y); <span class="comment">// 不行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(T1 x, T2 y) -&gt; decltype(x + y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. meta programming</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_decltype</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt;::value_type elem1;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt; coll;</span><br><span class="line">    <span class="keyword">decltype</span>(coll)::value_type elem2;</span><br><span class="line">    </span><br><span class="line">    typedef typename decltype(obj)::iterator iType; // =&gt; typedef typename T::iterator iType</span><br><span class="line">    <span class="comment">// test_decltype(complex&lt;int&gt;()) 编译失败</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">decltype</span>(obj) anotherObj(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. pass the type of lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person&amp; p2) &#123;</span><br><span class="line">    <span class="keyword">return</span> p1.lastname() &lt; p2.lastname() || (p1.lastname() == p2.lastname() &amp;&amp; p1.firstname() &lt; p2.firstname()); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Person, <span class="keyword">decltype</span>(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>noexcept</title>
      <link href="/2020/10/16/noexcept/"/>
      <url>/2020/10/16/noexcept/</url>
      
        <content type="html"><![CDATA[<p><img src="\images/image-20201016113005483.png" alt=""></p><p><img src="\images/image-20201016113301024.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Type Alias &amp; using</title>
      <link href="/2020/10/16/Type-Alias/"/>
      <url>/2020/10/16/Type-Alias/</url>
      
        <content type="html"><![CDATA[<h3 id="Type-alias"><a href="#Type-alias" class="headerlink" title="Type alias"></a>Type alias</h3><p>Similar to typedef</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type alias, identical to</span></span><br><span class="line"><span class="comment">// typedef void (*func)(int, int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">func fn = example;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CharT</span>&gt; <span class="title">using</span> <span class="title">mystring</span> = <span class="title">std</span>:</span>:basic_string&lt;CharT, <span class="built_in">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="keyword">char</span>&gt; str;</span><br></pre></td></tr></table></figure><p><string> 和 &lt;string_fwd.h&gt; 都有以下 typedef:</string></p><p>typedef basic_string<char> string;</char></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type alias can introduce a member typedef name</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;   <span class="comment">// typedef T value_type;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cntr&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn2</span><span class="params">(<span class="keyword">const</span> Cntr&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Cntr::value_type n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><ol><li><p>using-directives for namespaces and using-declarations for namespace members;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::count;</span><br></pre></td></tr></table></figure></li><li><p>using-declarations for class members</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">using</span> _Base::_M_allocate;</span><br><span class="line">  <span class="keyword">using</span> _Base::_M_deallocate;</span><br><span class="line">  <span class="keyword">using</span> _Base::_S_nword;</span><br><span class="line">  <span class="keyword">using</span> _Base::_M_get_Bit_allocator;</span><br></pre></td></tr></table></figure></li><li><p>type alias and alias template declaration</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Range-based for statement</title>
      <link href="/2020/10/16/range-based-for-statement/"/>
      <url>/2020/10/16/range-based-for-statement/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for( decl : coll) &#123;</span></span><br><span class="line"><span class="comment">    statement</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i: &#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">76</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">8</span>&#125;) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem: vec) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; elem &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem: vec) &#123;</span><br><span class="line">    elem *= <span class="number">3</span>;</span><br><span class="line">&#125;<span class="comment">// 关联式容器不能修改值</span></span><br></pre></td></tr></table></figure><p><img src="\images/image-20201016102022386.png" alt=""></p><p>No explicit type conversions are possible when elements are initialized as decl inside the for loop. Thus, the following does not compile:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> C&amp; elem: vs) &#123; <span class="comment">// error no conversion from string to C defined</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;elem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>explicit关键字</title>
      <link href="/2020/10/16/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/10/16/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="用在一个实参上的-explicit。"><a href="#用在一个实参上的-explicit。" class="headerlink" title="用在一个实参上的 explicit。"></a>用在一个实参上的 explicit。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> real, imag;</span><br><span class="line">    Complex(<span class="keyword">int</span> re, <span class="keyword">int</span> im = <span class="number">0</span>): real(re), imag(im)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex((real + x,real), (imag + x.imag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>;  <span class="comment">// 会调用构造函数 将 5 隐式转换为 Complex</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> real, imag;</span><br><span class="line">    explicit Complex(int re, int im = 0): real(re), imag(im)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex((real + x,real), (imag + x.imag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>; <span class="comment">// [Error] no match for 'operator+'(operand types are 'Complex' ands 'int')</span></span><br></pre></td></tr></table></figure><h3 id="用在多个实参上的-explicit"><a href="#用在多个实参上的-explicit" class="headerlink" title="用在多个实参上的 explicit"></a>用在多个实参上的 explicit</h3><p><img src="\images/image-20201016101414330.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Variadic Templates</title>
      <link href="/2020/10/15/Variadic-Templates/"/>
      <url>/2020/10/15/Variadic-Templates/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理无参数的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意参数类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"left:"</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="string">"params"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="comment">// args 会被分为2部分 一部分是第一个参数 第二部分是args...</span></span><br><span class="line">    printX(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 是所谓的 pack</span></span><br><span class="line"><span class="comment">// 用于 template parameters 就是 template parameters pack</span></span><br><span class="line"><span class="comment">// 用于 function parameter types 就是 function parameter types pack</span></span><br><span class="line"><span class="comment">// 用于 function parameters 就是 function parameters pack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'%'</span>&amp;&amp;*(++s)!=<span class="string">'%'</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"invalid format string"</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, T value, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'%'</span>&amp;&amp;*(++s)!=<span class="string">'%'</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">            <span class="built_in">printf</span>(++s, args...);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"invalid format string"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(n, maximum(args...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printX(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">"asa"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; maximum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="\images/image-20201015164406400.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniform initialization</title>
      <link href="/2020/10/15/uniform-initialization/"/>
      <url>/2020/10/15/uniform-initialization/</url>
      
        <content type="html"><![CDATA[ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> values[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cities &#123;</span><br><span class="line">    <span class="string">"beijing"</span>, <span class="string">"shanghai"</span>,<span class="string">"nanjing"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123;<span class="number">4.0</span>, <span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>利用一个事实，编译器看到{t1,t2,…,tn} 便会做出一个 initializer_list<t>,  它关联至一个 array&lt;T, n&gt;。 调用函数(例如  ctor)时改 array 内的元素可被编译器分解逐一传给函数。但若函数参数是个 initializer_list<t>, 调用者却不能基于数个 T 参数然后以为他们会被自动转为一个 initializer_list<t> 传入。 </t></t></t></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = vals.begin(); p != vals.end(); ++p) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; *p &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="\images/image-20201016094500084.png" alt=""></p><p> The initializer_list object refers to the elements of this array without containing them: copy initializer_list object produces another object referring to the same underlying elements, not to new copies of them.</p><p> <img src="\images/image-20201016095543858.png" alt=""></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">69</span>,<span class="number">83</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">69</span>,<span class="number">83</span>,<span class="number">50</span>&#125;); <span class="comment">// 调用接收 initializer_list 的构造函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3 = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">69</span>,<span class="number">83</span>,<span class="number">50</span>&#125;;  <span class="comment">//operator= </span></span><br><span class="line">v3.insert(v3.begin() + <span class="number">2</span>, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; max(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; min(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _<span class="function">Tp <span class="title">min</span><span class="params">(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">std</span>::min_element(__l.beigin(), __l.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _<span class="function">Tp <span class="title">max</span><span class="params">(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">std</span>::max_element(__l.beigin(), __l.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步 IO 和异步 IO</title>
      <link href="/2020/10/12/%E5%90%8C%E6%AD%A5-IO-%E5%92%8C%E5%BC%82%E6%AD%A5-IO/"/>
      <url>/2020/10/12/%E5%90%8C%E6%AD%A5-IO-%E5%92%8C%E5%BC%82%E6%AD%A5-IO/</url>
      
        <content type="html"><![CDATA[<p>Linux 系统中，所有的设备读写都可以看做文件的读写来操作，对文件的读写一般要经过内核态和用户态的切换，</p><p><strong>正因为有切换才导致了 IO 有同步和异步的说法</strong>。</p><p>通常来讲 IO 可以分成两种：</p><ul><li>来自网络的 IO</li><li>来自文件或者设备的 IO</li></ul><p>并且完成 IO 操作可以简单的表述为两个步骤：</p><ul><li>发起 IO 请求</li><li>执行 IO 操作</li></ul><h2 id="如何区分是同步-IO-还是异步-IO-呢？"><a href="#如何区分是同步-IO-还是异步-IO-呢？" class="headerlink" title="如何区分是同步 IO 还是异步 IO 呢？"></a>如何区分是同步 IO 还是异步 IO 呢？</h2><ul><li>“执行 IO 操作”是否阻塞</li></ul><blockquote><p>当请求被阻塞，就是同步 IO，否则就是异步 IO</p></blockquote><p><strong>同步 IO 的特点：</strong></p><blockquote><p>同步 IO 指的是用户进程触发 I/O 操作并等待或者轮询的去查看 I/O 操作是否就绪。<br>同步 IO 的执行者是 IO 操作的发起者。<br>同步 IO 需要发起者进行内核态到用户态的数据拷贝过程，所以这里必须由个阻塞</p></blockquote><p><strong>异步 IO 的特点：</strong></p><blockquote><p>异步 IO 是指用户进程触发 I/O 操作以后就立即返回，继续开始做自己的事情，而当 I/O 操作已经完成的时候会得到 I/O 完成的通知。<br>异步 IO 的执行者是内核线程，内核线程将数据从内核态拷贝到用户态，所以这里没哟阻塞</p></blockquote><h2 id="如何区分是阻塞-IO-还是非阻塞-IO-呢？"><a href="#如何区分是阻塞-IO-还是非阻塞-IO-呢？" class="headerlink" title="如何区分是阻塞 IO 还是非阻塞 IO 呢？"></a>如何区分是阻塞 IO 还是非阻塞 IO 呢？</h2><ul><li>发起 IO 操作是否阻塞</li></ul><blockquote><p>如果阻塞直到完成，就是阻塞 IO，否则就是非阻塞 IO</p></blockquote><h2 id="讨论几个IO模型"><a href="#讨论几个IO模型" class="headerlink" title="讨论几个IO模型"></a>讨论几个IO模型</h2><ul><li>阻塞 IO 模型(同步IO)</li></ul><blockquote><p>阻塞 IO 模型从发起 IO 操作到数据拷贝到用户空间，进程一直是阻塞的。</p></blockquote><ul><li>非阻塞 IO 模型(同步IO)</li></ul><blockquote><p>非阻塞 IO 模型从发起 IO 操作后就直接返回，定时轮询数据有没有准备好，后面还是需要拷贝数据到用户空间</p></blockquote><ul><li>IO 复用模型(同步 IO)</li></ul><blockquote><p>IO 复用模型是发起 IO 操作前先调用 Select 或者 Poll。这两个函数都会在内核态准备好数据后告诉用户进程，相对于非阻塞 IO 模型来说，不需要轮询，用户进程可以做其他事情。但是本质上还是同步 IO<br>但是它的优点在于可以同时触发多个 IO任务并在每个 IO 完成后依次处理。</p></blockquote><ul><li>信号驱动 IO 模型</li></ul><blockquote><p>通过 sigaction 注册信号，等内核准备好数据后内核态执行信号函数，本质还是同步 IO</p></blockquote><ul><li>异步 IO 模型采用 aio_read 让内核准备好数据并复制到用户进程空间，最后通知用户进程，这才是正真的异步 IO</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/36344554" target="_blank" rel="noopener">知乎</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> io </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reactor &amp; proactor</title>
      <link href="/2020/10/12/reactor-proactor/"/>
      <url>/2020/10/12/reactor-proactor/</url>
      
        <content type="html"><![CDATA[<h3 id="标准定义"><a href="#标准定义" class="headerlink" title="标准定义"></a>标准定义</h3><p>两种I/O多路复用模式：Reactor 和 Proactor</p><p>一般地,I/O多路复用机制都依赖于一个事件<strong>多路分离器(Event Demultiplexer)</strong>。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的 <strong>read/write 事件处理器(Event Handler)</strong>。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。</p><p><strong>两个与事件分离器有关的模式是Reactor和Proactor。Reactor 模式采用同步 IO，而 Proactor 采用异步 IO。</strong></p><p><strong>在 Reactor 中，</strong>事件分离器负责等待文件描述符或 socket 为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。</p><p><strong>而在 Proactor 模式中，</strong>处理器–或者兼任处理器的事件分离器，只负责发起异步读写操作。IO 操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从 socket 读到的数据。事件分离器捕获 IO 操作完成事件，然后将事件传递给对应处理器。比如，在 windows 上，处理器发起一个异步 IO 操作，再由事件分离器等待 IOCompletion 事件。典型的异步模式实现，都建立在操作系统支持异步 API 的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。</p><p>举个例子，将有助于理解 Reactor 与 Proactor 二者的差异，以读操作为例（类操作类似）。</p><h4 id="在-Reactor-中实现读："><a href="#在-Reactor-中实现读：" class="headerlink" title="在 Reactor 中实现读："></a>在 Reactor 中实现读：</h4><ol><li>注册读就绪事件和相应的事件处理器</li><li>事件分离器等待事件</li><li>事件到来，激活分离器，分离器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ol><h4 id="在-Proactor-中实现读："><a href="#在-Proactor-中实现读：" class="headerlink" title="在 Proactor 中实现读："></a>在 Proactor 中实现读：</h4><ol><li>处理器发起异步读操作（注意：操作系统必须支持异步 IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分离器等待操作完成事件</li><li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li><li>事件分离器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li></ol><p>可以看出，两个模式的相同点，都是对某个 IO 事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调 handler 时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。</p><h3 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h3><p>使用Proactor框架和Reactor框架都可以极大的简化网络应用的开发，但它们的重点却不同。</p><p>Reactor 框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要向一个 SOCKET 写数据，那么当该S OCKET 可以接收数据的时候，你的操作就会被调用；<strong>而 Proactor 框架中用户定义的操作是在实际操作之后调用的。比如你定义了一个操作要显示从 SOCKET 中读入的数据，那么当读操作完成以后，你的操作才会被调用。</strong></p><p><strong>Proactor 和 Reactor 都是并发编程中的设计模式。</strong>在我看来，他们都是用于派发/分离 IO 操作事件的。这里所谓的 IO 事件也就是诸如 read/write 的 IO 操作。”派发/分离”就是将单独的 IO 事件通知到上层模块。两个模式不同的地方在于，<strong>Proactor 用于异步 IO，而 Reactor 用于同步 IO。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.zhihu.com/question/26943938/answer/68773398" target="_blank" rel="noopener">知乎</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> io </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cppcon2020 Back to basics: The structure of a Program</title>
      <link href="/2020/10/09/cppcon2020-Back-to-basics-The-structure-of-a-Program/"/>
      <url>/2020/10/09/cppcon2020-Back-to-basics-The-structure-of-a-Program/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cppcon2020 Back to basics: The Abstract Machine</title>
      <link href="/2020/10/09/cppcon2020-Back-to-basics-The-Abstract-Machine/"/>
      <url>/2020/10/09/cppcon2020-Back-to-basics-The-Abstract-Machine/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-C-Abstract-Machine"><a href="#什么是-C-Abstract-Machine" class="headerlink" title="什么是 C++ Abstract Machine"></a>什么是 C++ Abstract Machine</h3><p>“The C++ Abstract machine is a portable abstraction of your operating system, kernel and hardware. The abstract machine is the intermediary between your c++ program and the system that it is run on.”</p><p>C++ defines how programs work in terms of an abstract machine deliberately defined to be “close to the hardware”.</p><p>When we write c++ code, we are writing to the c++ abstract machine.</p><p><img src="\images\image-20201009111642176.png" alt=""></p><h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p>Memory</p><p>Objects</p><p>Threads</p><p><img src="\images/image-20201009113635803.png" alt=""></p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul><li><p>A single flat space. </p></li><li><p>No memory hierarchy</p><ul><li>No concept of statck, registers or cache</li><li>No concept of heterogeneous memory</li></ul></li><li>All parts of memory are equally reachable by the am</li><li>Access to memory hash uniform latency</li></ul><p><img src="\images/image-20201009114127850.png" alt=""></p><h4 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h4><p><img src="\images/image-20201009114314098.png" alt=""></p><p><img src="\images/image-20201009114359211.png" alt=""></p><p><img src="\images/image-20201009114442364.png" alt=""></p><p><img src="\images/image-20201009114542360.png" alt=""></p><p><img src="\images/image-20201009114659700.png" alt=""></p><p><img src="\images/image-20201009115101605.png" alt=""></p><p><img src="\images/image-20201009115240794.png" alt=""></p><p><img src="\images/image-20201009115530530.png" alt=""></p><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p><img src="\images/image-20201009115713108.png" alt=""></p><p><img src="\images/image-20201009145927525.png" alt=""></p><p><img src="\images/image-20201009150034948.png" alt=""></p><p><img src="\images/image-20201009150334369.png" alt=""></p><p><img src="\images/image-20201009150559904.png" alt=""></p><p><img src="\images/image-20201009150818521.png" alt=""></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="\images/image-20201009151024517.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1YA411J7Pe?from=search&amp;seid=13344390530045708226" target="_blank" rel="noopener">cpp conference 2020 bilibili</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在知乎上删掉的保研经历</title>
      <link href="/2020/09/15/%E5%9C%A8%E7%9F%A5%E4%B9%8E%E4%B8%8A%E5%88%A0%E9%99%A4%E6%8E%89%E7%9A%84%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/"/>
      <url>/2020/09/15/%E5%9C%A8%E7%9F%A5%E4%B9%8E%E4%B8%8A%E5%88%A0%E9%99%A4%E6%8E%89%E7%9A%84%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>本科是帝都211，数字媒体技术专业（偏通信专业）。<br>从大一下开始对编程产生了浓郁的兴趣，最开始的时候是自学c语言，当时快速学完了语法，以致于学校的c语言课都没怎么听过，考试轻松过。<br>大一暑假接触前端，当时对于编程了解尚浅，所以更喜欢可视化的东西。跟着慕课网的课程看，也算是对前端有了初步的了解。<br>大二课业繁重，加上大一成绩也不算特别好，就开始专心学习专业课（包括数电模电信号等课），最终得到了一个还不错的绩点，但是这段时间内对于编程的学习也就断断续续了。寒假期间陪女朋友学车的时候在驾校的咖啡厅看完了整套的邓俊辉数据结构，算是入了门，但是具体的代码也没有实践过。大二下学期由于要和做大创，又对unity浅尝辄止，算是了解了点面向对象的思想。<br>之后参加了学校ACM集训，暑假在学校呆了一个月，每天刷题（虽然都是些简单题），倒也算是把基本的数据结构熟悉了，也锻炼了编程思维。同时又学了一些机器学习，看了《机器学习基石》系列教程，还有CS231n（当然仍然浅尝辄止）。大二下本想转专业去计科，后权衡再三，没有转。<br>大三上。<br>身边的大佬师哥拿到了很好的offer，交谈中其实很是振奋，觉得一直自学下去其实也是可行的，故决心放弃绩点专心刷计算机基础课，期间简略看完CSAPP,看了大半部SICP，刷了算法橙书，计算机网络（自顶向下），并且坚持ACM训练，6级考了577。有幸参加了两次ACM区域赛，均打铁（不过还是不甘）。<br>寒假决定找工作，匆忙间看了李航的《统计学习方法》，一刷了《王道数据结构》和《剑指offer》。又知道自己基础薄弱，开始看操作系统，这门课起初学起来十分吃力，前后换了很多教程和课本，最终靠孙志岗老师的教程初步了解了操作系统。期间还看了点java和javaweb，跟着教程完成了小的项目。可以说那段时间是慌乱和迷茫的，知道自己很差却只能拼了命地弥补。</p><p>大三下继续ACM训练和计算机专业课的学习，先是看了东南徐立臻老师的《数据库》教程。又在一阵慌乱中继续着算法的训练。参加过春招（内推），打击过大，遂放弃（电话面试一问三不知，一点b-树都没有），还得感谢师哥模拟面试，虽然我最后砸的不行。决意考研，和女票一起考南大软件。在正式复习考研前，参加acm邀请赛，意外拿了银牌，算是一个很大的惊喜，可能是“杨超越附体”了。<br>考研专业课有四门（数据结构，操作系统，计算机网络和软件工程）。从5月底到9月中旬，就是充实的考研复习阶段了。期间专业课至少过了2遍，数据结构的算法题应该都刷了不止一遍，基本的题目应该是很熟悉了。南软的软件工程专业课让我收获颇丰，一是面向对象的思想，二是一个中型系统项目对自己的启发。软件工程这门课包括了uml和一些设计模式和面向对象的知识，课程设置独树一帜。</p><p>￼</p><p>考研复习期间还做过php和java的项目。php项目算是学了设计模式之后的一次练兵，算是自己第一次不跟着教程写项目，对于代码不断进行重构，成就感max。</p><p>然后转机来了，机缘巧合，本不该进入保研圈的我因为之前得到的奖和相对较高的绩点幸运保研，真实的幸运，感激地一塌糊涂！！</p><p>保研名单下来的迟，准备的少，还得感谢 @邱锐 大佬给的申请经验，成功推免至北邮网研院。</p><p>#update</p><p>更新下保研的过程吧。中秋去女票家的时候收到学校推免成功的消息后才开始投简历。之前一直准备考研，心里觉得只有拿到学校推免才能完全放下考研的复习全身心准备面试。</p><p>陆续投了一堆江浙沪和南方的学校（家在南京），包括华师，同济，复旦，华东理工，南大，中科大，中南大学之类的。当时想着就是海投了。北京投了北邮之后也就没管了。从女票家回来之后第一天就去北邮面试，上午面试计算机学院，下午网研院，网研院当场收到offer（面试官：这题你是不是都做过了？我：嗯，复习考研这些题刷过了）而且他们超棒啊，直接劝我别直博，因为我数学差的要死。王道数据结构课后题我从寒假开始刷，直到面试的时候已经刷了3遍了QAQ。</p><p>后来陆续收到科大，华师，中南的面试通知（貌似都稳了），再三考虑后全鸽了，对不起对不起对不起。</p><p>可能是大学前三年压抑太久了（翘过无数必修课选修课，就为了学会自己怎么都学不会的算法）最后想让我顺一回吧。</p><p>大学三年经历过各种迷茫困顿，总觉得无法消弭和科班大佬之间的差距，一直都在追赶，也一直在本专业的课程和计算机课程之间游离。所幸两者得兼，所幸不负韶华。</p><p>￼￼</p><p>一定得感谢体贴的女票一直的照顾和陪伴，你最终还是支持了我的决定。虽然你我将有短暂的分别，但是相信读完研后，我们都会是更好的自己了。</p><p>具体的学习历程还有恋爱历程之后可以更。</p><p>保研到北京还是心疼女票啊啊啊啊啊啊啊啊啊啊啊。</p><p>update </p><p>女票成功上岸南大软件。%%%%tql</p><p>转眼就到毕业。</p><p>最近才稍有些毕业的感觉。</p><p>四年是日渐拥挤的书架，日均12000步的行走，零星几个肝掉的深夜，几十张车票，“北境不遗忘”，“我要成为海贼王”，“Run as one”….</p><p>少了许多少年心事，不再说华丽辞藻含蓄故事。多了肚子、大腿上的肉，愈发坚定且直抒胸臆。</p><p>前两天采访时候，问研究生规划我并未作答。并非毫无愿景。四年的际遇奇迹满满，三年后亦未可知，不设限，任我行。希望能够各自攀峰，山顶再会 </p><p>毕业后要变成一个真正的男人，要控制情绪，处理好生活与工作，爱自己，爱他人，眼里有光。</p><p>感谢不可能的和可能的。</p><p>遇见你之前，幻想高考多对一道选择题，物理大题第一题没有算错，或许人生的轨迹就会大不相同。</p><p>遇见你之后，无法形容自己有多幸运。在人生的这条马氏链上，我似乎找到了Best policy，援引The big bang theroy剧内插曲的歌词。</p><p>I couldn’t have imagined </p><p>How good my life would get </p><p>From the moment that I met you</p><p>过去的遗憾也不能算是遗憾了，现在拥有的就是现在了。</p><p>穿过人潮汹涌灯火阑珊，</p><p>没有想过回头。</p><p>再 update 日期2020/9/15</p><p>经过一段阵痛期，之后再寒假后陪女票找实习，npy太强了，先后拿下跟谁学，美团，字节，阿里的实习offer，实习后更加知道了追求的东西和出路。</p><p>之前的一些幼稚想法也变得成熟起来。</p><p>前路坦荡，可别走歪了。</p>]]></content>
      
      
      <categories>
          
          <category> 保研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析</title>
      <link href="/2019/04/27/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/27/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="\images\1556345446610.png" alt="1556345446610"></p><p>标识符是一个大的集合。</p><h4 id="记号的数据结构定义"><a href="#记号的数据结构定义" class="headerlink" title="记号的数据结构定义"></a>记号的数据结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> kind &#123;IF,LPAREN,ID,INTLIT,...&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> kind k;</span><br><span class="line">    <span class="keyword">char</span> *lexeme;<span class="comment">// 单词</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">/*eg  if(x&gt;5) </span></span><br><span class="line"><span class="comment">===&gt;&gt;  </span></span><br><span class="line"><span class="comment">token&#123;k=IF,lexeme=0&#125;;</span></span><br><span class="line"><span class="comment">token&#123;k=LPAREN,lexeme=0&#125;；</span></span><br><span class="line"><span class="comment">token&#123;k=ID,lexeme="x"&#125;;</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>词法分析器的任务，字符流到记号流。</p><p>记号流是编译器内部定义的数据结构，编码所识别出的词法单元。</p><h4 id="词法分析—手工构造法"><a href="#词法分析—手工构造法" class="headerlink" title="词法分析—手工构造法"></a>词法分析—手工构造法</h4><p>相对复杂，容易出错。</p><p>词法分析器的生成器（自动化）：可快速原型、代码量少，但难控制细节。</p><h5 id="转移图"><a href="#转移图" class="headerlink" title="转移图"></a>转移图</h5><p><img src="\images\1556345908254.png" alt="1556345908254"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">token <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    c = getChar();</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">            c= getChar();</span><br><span class="line">            <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'='</span>: <span class="keyword">return</span> LE;</span><br><span class="line">                <span class="keyword">case</span>=<span class="string">'&gt;'</span>:<span class="keyword">return</span> NE;</span><br><span class="line">                <span class="keyword">default</span>: rollback();<span class="keyword">return</span> LT;    </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'='</span>:<span class="keyword">return</span> EQ;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&gt;'</span>: c= getChar();</span><br><span class="line">            <span class="keyword">switch</span>(c):&#123;</span><br><span class="line">                .....<span class="comment">//和上面类似</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识符的转移图：</p><p><img src="\images\1556346239830.png" alt="1556346239830"></p><h5 id="识别关键字"><a href="#识别关键字" class="headerlink" title="识别关键字"></a>识别关键字</h5><p><img src="\images\1556346305746.png" alt="1556346305746"></p><p>也可以弄关键字构成的哈希表，先统一按照关键符的转移图进行识别，进一步查表看是否是关键字。<strong>完美哈希</strong></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><img src="\images\1556346585122.png" alt="1556346585122"></p><p>kleene闭包。</p><h5 id="例子：标识符"><a href="#例子：标识符" class="headerlink" title="例子：标识符"></a>例子：标识符</h5><p>c语言：以字母或下划线开头，后面跟多个或0个字母数字或下划线</p><p>（a|b|c|…..z|A|B|C|….|Z|–<em>)(a|b|c|…..z|A|B|C|….|Z|</em>–|0|1|…|9|)*</p><p><img src="\images\1556347030449.png" alt="1556347030449"></p><h4 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h4><p><img src="\images\1556347210990.png" alt="1556347210990"></p><p><img src="\images\1556347330767.png" alt="1556347330767"></p><p><img src="\images\1556347508085.png" alt="1556347508085"></p><p>非确定有限状态自动机（NFA）</p><p>确定有限状态自动机（DFA)</p><p>NFA难以判断字符串是否可接受。需要进行搜索。需要将NFA转化为等价的DFA。</p><p><img src="\images\1556347919744.png" alt="1556347919744"></p><h5 id="DFA的实现"><a href="#DFA的实现" class="headerlink" title="DFA的实现"></a>DFA的实现</h5><p>带有边和节点的有向图。</p><p>边上面有信息</p><p>节点上有信息</p><h4 id="正则表达式到NFA（Thompson算法）"><a href="#正则表达式到NFA（Thompson算法）" class="headerlink" title="正则表达式到NFA（Thompson算法）"></a>正则表达式到NFA（Thompson算法）</h4><p>RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码</p><p><img src="\images\1556348118187.png" alt="1556348118187"></p><p>对基本的RE直接构造</p><p>对复合的RE递归构造</p><h4 id="NFA转化为DFA（子集构造法）"><a href="#NFA转化为DFA（子集构造法）" class="headerlink" title="NFA转化为DFA（子集构造法）"></a>NFA转化为DFA（子集构造法）</h4><p> <img src="\images\1556352481806.png" alt="1556352481806"></p><p>不动点算法：why能终止？</p><p><img src="\images\1556352933809.png" alt="1556352933809"></p><p><img src="\images\1556353096339.png" alt="1556353096339"></p><p><img src="\images\1556364959944.png" alt="1556364959944"></p><h4 id="DFA最小化"><a href="#DFA最小化" class="headerlink" title="DFA最小化"></a>DFA最小化</h4><h5 id="Hopcroft算法"><a href="#Hopcroft算法" class="headerlink" title="Hopcroft算法"></a>Hopcroft算法</h5><p><img src="\images\1556365643462.png" alt="1556365643462"></p><p>什么叫做能切分？</p><p>首先切分成非终结符和终结符两类</p><h4 id="DFA的代码表示"><a href="#DFA的代码表示" class="headerlink" title="DFA的代码表示"></a>DFA的代码表示</h4><p>转移表</p><p>哈希表</p><p>跳转表</p><ol><li><p>转移表：还要有词法分析驱动代码。</p><p><img src="\images\1556366207999.png" alt="1556366207999"></p></li></ol><p>   <img src="\images\1556366321276.png" alt="1556366321276"></p><p>​    最长匹配思想。</p><ol start="2"><li>跳转表:</li></ol><p><img src="\images/1556369224478.png" alt="1556369224478"></p><p><img src="\images/1556369247701.png" alt="1556369247701"></p><p>跳转表不需要维护一个大的转移数组。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
