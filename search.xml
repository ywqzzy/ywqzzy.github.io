<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cppcon2020 Back to basics: The Abstract Machine</title>
      <link href="/2020/10/09/cppcon2020-Back-to-basics-The-Abstract-Machine/"/>
      <url>/2020/10/09/cppcon2020-Back-to-basics-The-Abstract-Machine/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-C-Abstract-Machine"><a href="#什么是-C-Abstract-Machine" class="headerlink" title="什么是 C++ Abstract Machine"></a>什么是 C++ Abstract Machine</h3><p>“The C++ Abstract machine is a portable abstraction of your operating system, kernel and hardware. The abstract machine is the intermediary between your c++ program and the system that it is run on.”</p><p>C++ defines how programs work in terms of an abstract machine deliberately defined to be “close to the hardware”.</p><p>When we write c++ code, we are writing to the c++ abstract machine.</p><p><img src="\images\image-20201009111642176.png" alt=""></p><h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p>Memory</p><p>Objects</p><p>Threads</p><p><img src="\images/image-20201009113635803.png" alt=""></p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul><li><p>A single flat space. </p></li><li><p>No memory hierarchy</p><ul><li>No concept of statck, registers or cache</li><li>No concept of heterogeneous memory</li></ul></li><li>All parts of memory are equally reachable by the am</li><li>Access to memory hash uniform latency</li></ul><p><img src="\images/image-20201009114127850.png" alt=""></p><h4 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h4><p><img src="\images/image-20201009114314098.png" alt=""></p><p><img src="\images/image-20201009114359211.png" alt=""></p><p><img src="\images/image-20201009114442364.png" alt=""></p><p><img src="\images/image-20201009114542360.png" alt=""></p><p><img src="\images/image-20201009114659700.png" alt=""></p><p><img src="\images/image-20201009115101605.png" alt=""></p><p><img src="\images/image-20201009115240794.png" alt=""></p><p><img src="\images/image-20201009115530530.png" alt=""></p><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p><img src="\images/image-20201009115713108.png" alt=""></p><p><img src="\images/image-20201009145927525.png" alt=""></p><p><img src="\images/image-20201009150034948.png" alt=""></p><p><img src="\images/image-20201009150334369.png" alt=""></p><p><img src="\images/image-20201009150559904.png" alt=""></p><p><img src="\images/image-20201009150818521.png" alt=""></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="\images/image-20201009151024517.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1YA411J7Pe?from=search&amp;seid=13344390530045708226" target="_blank" rel="noopener">cpp conference 2020 bilibili</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>testt</title>
      <link href="/2020/09/15/%E5%9C%A8%E7%9F%A5%E4%B9%8E%E4%B8%8A%E5%88%A0%E9%99%A4%E6%8E%89%E7%9A%84%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/"/>
      <url>/2020/09/15/%E5%9C%A8%E7%9F%A5%E4%B9%8E%E4%B8%8A%E5%88%A0%E9%99%A4%E6%8E%89%E7%9A%84%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>本科是帝都211，数字媒体技术专业（偏通信专业）。<br>从大一下开始对编程产生了浓郁的兴趣，最开始的时候是自学c语言，当时快速学完了语法，以致于学校的c语言课都没怎么听过，考试轻松过。<br>大一暑假接触前端，当时对于编程了解尚浅，所以更喜欢可视化的东西。跟着慕课网的课程看，也算是对前端有了初步的了解。<br>大二课业繁重，加上大一成绩也不算特别好，就开始专心学习专业课（包括数电模电信号等课），最终得到了一个还不错的绩点，但是这段时间内对于编程的学习也就断断续续了。寒假期间陪女朋友学车的时候在驾校的咖啡厅看完了整套的邓俊辉数据结构，算是入了门，但是具体的代码也没有实践过。大二下学期由于要和做大创，又对unity浅尝辄止，算是了解了点面向对象的思想。<br>之后参加了学校ACM集训，暑假在学校呆了一个月，每天刷题（虽然都是些简单题），倒也算是把基本的数据结构熟悉了，也锻炼了编程思维。同时又学了一些机器学习，看了《机器学习基石》系列教程，还有CS231n（当然仍然浅尝辄止）。大二下本想转专业去计科，后权衡再三，没有转。<br>大三上。<br>身边的大佬师哥拿到了很好的offer，交谈中其实很是振奋，觉得一直自学下去其实也是可行的，故决心放弃绩点专心刷计算机基础课，期间简略看完CSAPP,看了大半部SICP，刷了算法橙书，计算机网络（自顶向下），并且坚持ACM训练，6级考了577。有幸参加了两次ACM区域赛，均打铁（不过还是不甘）。<br>寒假决定找工作，匆忙间看了李航的《统计学习方法》，一刷了《王道数据结构》和《剑指offer》。又知道自己基础薄弱，开始看操作系统，这门课起初学起来十分吃力，前后换了很多教程和课本，最终靠孙志岗老师的教程初步了解了操作系统。期间还看了点java和javaweb，跟着教程完成了小的项目。可以说那段时间是慌乱和迷茫的，知道自己很差却只能拼了命地弥补。</p><p>大三下继续ACM训练和计算机专业课的学习，先是看了东南徐立臻老师的《数据库》教程。又在一阵慌乱中继续着算法的训练。参加过春招（内推），打击过大，遂放弃（电话面试一问三不知，一点b-树都没有），还得感谢师哥模拟面试，虽然我最后砸的不行。决意考研，和女票一起考南大软件。在正式复习考研前，参加acm邀请赛，意外拿了银牌，算是一个很大的惊喜，可能是“杨超越附体”了。<br>考研专业课有四门（数据结构，操作系统，计算机网络和软件工程）。从5月底到9月中旬，就是充实的考研复习阶段了。期间专业课至少过了2遍，数据结构的算法题应该都刷了不止一遍，基本的题目应该是很熟悉了。南软的软件工程专业课让我收获颇丰，一是面向对象的思想，二是一个中型系统项目对自己的启发。软件工程这门课包括了uml和一些设计模式和面向对象的知识，课程设置独树一帜。</p><p>￼</p><p>考研复习期间还做过php和java的项目。php项目算是学了设计模式之后的一次练兵，算是自己第一次不跟着教程写项目，对于代码不断进行重构，成就感max。</p><p>然后转机来了，机缘巧合，本不该进入保研圈的我因为之前得到的奖和相对较高的绩点幸运保研，真实的幸运，感激地一塌糊涂！！</p><p>保研名单下来的迟，准备的少，还得感谢 @邱锐 大佬给的申请经验，成功推免至北邮网研院。</p><p>#update</p><p>更新下保研的过程吧。中秋去女票家的时候收到学校推免成功的消息后才开始投简历。之前一直准备考研，心里觉得只有拿到学校推免才能完全放下考研的复习全身心准备面试。</p><p>陆续投了一堆江浙沪和南方的学校（家在南京），包括华师，同济，复旦，华东理工，南大，中科大，中南大学之类的。当时想着就是海投了。北京投了北邮之后也就没管了。从女票家回来之后第一天就去北邮面试，上午面试计算机学院，下午网研院，网研院当场收到offer（面试官：这题你是不是都做过了？我：嗯，复习考研这些题刷过了）而且他们超棒啊，直接劝我别直博，因为我数学差的要死。王道数据结构课后题我从寒假开始刷，直到面试的时候已经刷了3遍了QAQ。</p><p>后来陆续收到科大，华师，中南的面试通知（貌似都稳了），再三考虑后全鸽了，对不起对不起对不起。</p><p>可能是大学前三年压抑太久了（翘过无数必修课选修课，就为了学会自己怎么都学不会的算法）最后想让我顺一回吧。</p><p>大学三年经历过各种迷茫困顿，总觉得无法消弭和科班大佬之间的差距，一直都在追赶，也一直在本专业的课程和计算机课程之间游离。所幸两者得兼，所幸不负韶华。</p><p>￼￼</p><p>一定得感谢体贴的女票一直的照顾和陪伴，你最终还是支持了我的决定。虽然你我将有短暂的分别，但是相信读完研后，我们都会是更好的自己了。</p><p>具体的学习历程还有恋爱历程之后可以更。</p><p>保研到北京还是心疼女票啊啊啊啊啊啊啊啊啊啊啊。</p><p>update </p><p>女票成功上岸南大软件。%%%%tql</p><p>转眼就到毕业。</p><p>最近才稍有些毕业的感觉。</p><p>四年是日渐拥挤的书架，日均12000步的行走，零星几个肝掉的深夜，几十张车票，“北境不遗忘”，“我要成为海贼王”，“Run as one”….</p><p>少了许多少年心事，不再说华丽辞藻含蓄故事。多了肚子、大腿上的肉，愈发坚定且直抒胸臆。</p><p>前两天采访时候，问研究生规划我并未作答。并非毫无愿景。四年的际遇奇迹满满，三年后亦未可知，不设限，任我行。希望能够各自攀峰，山顶再会 </p><p>毕业后要变成一个真正的男人，要控制情绪，处理好生活与工作，爱自己，爱他人，眼里有光。</p><p>感谢不可能的和可能的。</p><p>遇见你之前，幻想高考多对一道选择题，物理大题第一题没有算错，或许人生的轨迹就会大不相同。</p><p>遇见你之后，无法形容自己有多幸运。在人生的这条马氏链上，我似乎找到了Best policy，援引The big bang theroy剧内插曲的歌词。</p><p>I couldn’t have imagined </p><p>How good my life would get </p><p>From the moment that I met you</p><p>过去的遗憾也不能算是遗憾了，现在拥有的就是现在了。</p><p>穿过人潮汹涌灯火阑珊，</p><p>没有想过回头。</p><p>再 update 日期2020/9/15</p><p>经过一段阵痛期，之后再寒假后陪女票找实习，npy太强了，先后拿下跟谁学，美团，字节，阿里的实习offer，实习后更加知道了追求的东西和出路。</p><p>之前的一些幼稚想法也变得成熟起来。</p><p>前路坦荡，可别走歪了。</p>]]></content>
      
      
      <categories>
          
          <category> 保研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析</title>
      <link href="/2019/04/27/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/27/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="\images\1556345446610.png" alt="1556345446610"></p><p>标识符是一个大的集合。</p><h4 id="记号的数据结构定义"><a href="#记号的数据结构定义" class="headerlink" title="记号的数据结构定义"></a>记号的数据结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> kind &#123;IF,LPAREN,ID,INTLIT,...&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> kind k;</span><br><span class="line">    <span class="keyword">char</span> *lexeme;<span class="comment">// 单词</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">/*eg  if(x&gt;5) </span></span><br><span class="line"><span class="comment">===&gt;&gt;  </span></span><br><span class="line"><span class="comment">token&#123;k=IF,lexeme=0&#125;;</span></span><br><span class="line"><span class="comment">token&#123;k=LPAREN,lexeme=0&#125;；</span></span><br><span class="line"><span class="comment">token&#123;k=ID,lexeme="x"&#125;;</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>词法分析器的任务，字符流到记号流。</p><p>记号流是编译器内部定义的数据结构，编码所识别出的词法单元。</p><h4 id="词法分析—手工构造法"><a href="#词法分析—手工构造法" class="headerlink" title="词法分析—手工构造法"></a>词法分析—手工构造法</h4><p>相对复杂，容易出错。</p><p>词法分析器的生成器（自动化）：可快速原型、代码量少，但难控制细节。</p><h5 id="转移图"><a href="#转移图" class="headerlink" title="转移图"></a>转移图</h5><p><img src="\images\1556345908254.png" alt="1556345908254"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">token <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    c = getChar();</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">            c= getChar();</span><br><span class="line">            <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'='</span>: <span class="keyword">return</span> LE;</span><br><span class="line">                <span class="keyword">case</span>=<span class="string">'&gt;'</span>:<span class="keyword">return</span> NE;</span><br><span class="line">                <span class="keyword">default</span>: rollback();<span class="keyword">return</span> LT;    </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'='</span>:<span class="keyword">return</span> EQ;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&gt;'</span>: c= getChar();</span><br><span class="line">            <span class="keyword">switch</span>(c):&#123;</span><br><span class="line">                .....<span class="comment">//和上面类似</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识符的转移图：</p><p><img src="\images\1556346239830.png" alt="1556346239830"></p><h5 id="识别关键字"><a href="#识别关键字" class="headerlink" title="识别关键字"></a>识别关键字</h5><p><img src="\images\1556346305746.png" alt="1556346305746"></p><p>也可以弄关键字构成的哈希表，先统一按照关键符的转移图进行识别，进一步查表看是否是关键字。<strong>完美哈希</strong></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><img src="\images\1556346585122.png" alt="1556346585122"></p><p>kleene闭包。</p><h5 id="例子：标识符"><a href="#例子：标识符" class="headerlink" title="例子：标识符"></a>例子：标识符</h5><p>c语言：以字母或下划线开头，后面跟多个或0个字母数字或下划线</p><p>（a|b|c|…..z|A|B|C|….|Z|–<em>)(a|b|c|…..z|A|B|C|….|Z|</em>–|0|1|…|9|)*</p><p><img src="\images\1556347030449.png" alt="1556347030449"></p><h4 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h4><p><img src="\images\1556347210990.png" alt="1556347210990"></p><p><img src="\images\1556347330767.png" alt="1556347330767"></p><p><img src="\images\1556347508085.png" alt="1556347508085"></p><p>非确定有限状态自动机（NFA）</p><p>确定有限状态自动机（DFA)</p><p>NFA难以判断字符串是否可接受。需要进行搜索。需要将NFA转化为等价的DFA。</p><p><img src="\images\1556347919744.png" alt="1556347919744"></p><h5 id="DFA的实现"><a href="#DFA的实现" class="headerlink" title="DFA的实现"></a>DFA的实现</h5><p>带有边和节点的有向图。</p><p>边上面有信息</p><p>节点上有信息</p><h4 id="正则表达式到NFA（Thompson算法）"><a href="#正则表达式到NFA（Thompson算法）" class="headerlink" title="正则表达式到NFA（Thompson算法）"></a>正则表达式到NFA（Thompson算法）</h4><p>RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码</p><p><img src="\images\1556348118187.png" alt="1556348118187"></p><p>对基本的RE直接构造</p><p>对复合的RE递归构造</p><h4 id="NFA转化为DFA（子集构造法）"><a href="#NFA转化为DFA（子集构造法）" class="headerlink" title="NFA转化为DFA（子集构造法）"></a>NFA转化为DFA（子集构造法）</h4><p> <img src="\images\1556352481806.png" alt="1556352481806"></p><p>不动点算法：why能终止？</p><p><img src="\images\1556352933809.png" alt="1556352933809"></p><p><img src="\images\1556353096339.png" alt="1556353096339"></p><p><img src="\images\1556364959944.png" alt="1556364959944"></p><h4 id="DFA最小化"><a href="#DFA最小化" class="headerlink" title="DFA最小化"></a>DFA最小化</h4><h5 id="Hopcroft算法"><a href="#Hopcroft算法" class="headerlink" title="Hopcroft算法"></a>Hopcroft算法</h5><p><img src="\images\1556365643462.png" alt="1556365643462"></p><p>什么叫做能切分？</p><p>首先切分成非终结符和终结符两类</p><h4 id="DFA的代码表示"><a href="#DFA的代码表示" class="headerlink" title="DFA的代码表示"></a>DFA的代码表示</h4><p>转移表</p><p>哈希表</p><p>跳转表</p><ol><li><p>转移表：还要有词法分析驱动代码。</p><p><img src="\images\1556366207999.png" alt="1556366207999"></p></li></ol><p>   <img src="\images\1556366321276.png" alt="1556366321276"></p><p>​    最长匹配思想。</p><ol start="2"><li>跳转表:</li></ol><p><img src="\images/1556369224478.png" alt="1556369224478"></p><p><img src="\images/1556369247701.png" alt="1556369247701"></p><p>跳转表不需要维护一个大的转移数组。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/01/22/test/"/>
      <url>/2019/01/22/test/</url>
      
        <content type="html"><![CDATA[<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>Unix有五种IO模型，</p><ol><li>阻塞式I/O</li><li>非阻塞式I/O</li><li>I/0复用（select/poll）</li><li>信号驱动式（SIGIO）</li><li>异步I/O(AIO)</li></ol><h4 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率效率会比较高。</p><p>下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
